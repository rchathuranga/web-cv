function Marsaglia(t, e) {
    var i = t || 362436069, n = e || 521288629, r = function () {
        return i = 36969 * (65535 & i) + (i >>> 16) & 4294967295, n = 18e3 * (65535 & n) + (n >>> 16) & 4294967295, 4294967295 & ((65535 & i) << 16 | 65535 & n)
    };
    this.nextDouble = function () {
        var t = r() / 4294967296;
        return t < 0 ? 1 + t : t
    }, this.nextInt = r
}

function PerlinNoise(t) {
    function e(t, e, i, n) {
        var r = 15 & t, a = r < 8 ? e : i, o = r < 4 ? i : 12 === r || 14 === r ? e : n;
        return (0 == (1 & r) ? a : -a) + (0 == (2 & r) ? o : -o)
    }

    function i(t, e, i) {
        var n = 0 == (1 & t) ? e : i;
        return 0 == (2 & t) ? -n : n
    }

    function n(t, e) {
        return 0 == (1 & t) ? -e : e
    }

    function r(t, e, i) {
        return e + t * (i - e)
    }

    var a = void 0 !== t ? new Marsaglia(t) : Marsaglia.createRandomized(), o, s, l = new Array(512);
    for (o = 0; o < 256; ++o) l[o] = o;
    for (o = 0; o < 256; ++o) {
        var c = l[s = 255 & a.nextInt()];
        l[s] = l[o], l[o] = c
    }
    for (o = 0; o < 256; ++o) l[o + 256] = l[o];
    this.noise3d = function (t, i, n) {
        var a = 255 & Math.floor(t), o = 255 & Math.floor(i), s = 255 & Math.floor(n);
        t -= Math.floor(t), i -= Math.floor(i), n -= Math.floor(n);
        var c = (3 - 2 * t) * t * t, h = (3 - 2 * i) * i * i, u = (3 - 2 * n) * n * n, p = l[a] + o, d = l[p] + s,
            f = l[p + 1] + s, m = l[a + 1] + o, g = l[m] + s, v = l[m + 1] + s;
        return r(u, r(h, r(c, e(l[d], t, i, n), e(l[g], t - 1, i, n)), r(c, e(l[f], t, i - 1, n), e(l[v], t - 1, i - 1, n))), r(h, r(c, e(l[d + 1], t, i, n - 1), e(l[g + 1], t - 1, i, n - 1)), r(c, e(l[f + 1], t, i - 1, n - 1), e(l[v + 1], t - 1, i - 1, n - 1))))
    }, this.noise2d = function (t, e) {
        var n = 255 & Math.floor(t), a = 255 & Math.floor(e);
        t -= Math.floor(t), e -= Math.floor(e);
        var o = (3 - 2 * t) * t * t, s = (3 - 2 * e) * e * e, c = l[n] + a, h = l[n + 1] + a;
        return r(s, r(o, i(l[c], t, e), i(l[h], t - 1, e)), r(o, i(l[c + 1], t, e - 1), i(l[h + 1], t - 1, e - 1)))
    }, this.noise1d = function (t) {
        var e = 255 & Math.floor(t);
        return t -= Math.floor(t), r((3 - 2 * t) * t * t, n(l[e], t), n(l[e + 1], t - 1))
    }
}

function noise(t, e, i) {
    void 0 === noiseProfile.generator && (noiseProfile.generator = new PerlinNoise(noiseProfile.seed));
    for (var n = noiseProfile.generator, r = 1, a = 1, o = 0, s = 0; s < noiseProfile.octaves; ++s) {
        switch (r *= noiseProfile.fallout, arguments.length) {
            case 1:
                o += r * (1 + n.noise1d(a * t)) / 2;
                break;
            case 2:
                o += r * (1 + n.noise2d(a * t, a * e)) / 2;
                break;
            case 3:
                o += r * (1 + n.noise3d(a * t, a * e, a * i)) / 2
        }
        a *= 2
    }
    return o
}

function Marsaglia(t, e) {
    var i = t || 362436069, n = e || 521288629, r = function () {
        return i = 36969 * (65535 & i) + (i >>> 16) & 4294967295, n = 18e3 * (65535 & n) + (n >>> 16) & 4294967295, 4294967295 & ((65535 & i) << 16 | 65535 & n)
    };
    this.nextDouble = function () {
        var t = r() / 4294967296;
        return t < 0 ? 1 + t : t
    }, this.nextInt = r
}

function PerlinNoise(t) {
    function e(t, e, i, n) {
        var r = 15 & t, a = r < 8 ? e : i, o = r < 4 ? i : 12 === r || 14 === r ? e : n;
        return (0 == (1 & r) ? a : -a) + (0 == (2 & r) ? o : -o)
    }

    function i(t, e, i) {
        var n = 0 == (1 & t) ? e : i;
        return 0 == (2 & t) ? -n : n
    }

    function n(t, e) {
        return 0 == (1 & t) ? -e : e
    }

    function r(t, e, i) {
        return e + t * (i - e)
    }

    var a = void 0 !== t ? new Marsaglia(t) : Marsaglia.createRandomized(), o, s, l = new Array(512);
    for (o = 0; o < 256; ++o) l[o] = o;
    for (o = 0; o < 256; ++o) {
        var c = l[s = 255 & a.nextInt()];
        l[s] = l[o], l[o] = c
    }
    for (o = 0; o < 256; ++o) l[o + 256] = l[o];
    this.noise3d = function (t, i, n) {
        var a = 255 & Math.floor(t), o = 255 & Math.floor(i), s = 255 & Math.floor(n);
        t -= Math.floor(t), i -= Math.floor(i), n -= Math.floor(n);
        var c = (3 - 2 * t) * t * t, h = (3 - 2 * i) * i * i, u = (3 - 2 * n) * n * n, p = l[a] + o, d = l[p] + s,
            f = l[p + 1] + s, m = l[a + 1] + o, g = l[m] + s, v = l[m + 1] + s;
        return r(u, r(h, r(c, e(l[d], t, i, n), e(l[g], t - 1, i, n)), r(c, e(l[f], t, i - 1, n), e(l[v], t - 1, i - 1, n))), r(h, r(c, e(l[d + 1], t, i, n - 1), e(l[g + 1], t - 1, i, n - 1)), r(c, e(l[f + 1], t, i - 1, n - 1), e(l[v + 1], t - 1, i - 1, n - 1))))
    }, this.noise2d = function (t, e) {
        var n = 255 & Math.floor(t), a = 255 & Math.floor(e);
        t -= Math.floor(t), e -= Math.floor(e);
        var o = (3 - 2 * t) * t * t, s = (3 - 2 * e) * e * e, c = l[n] + a, h = l[n + 1] + a;
        return r(s, r(o, i(l[c], t, e), i(l[h], t - 1, e)), r(o, i(l[c + 1], t, e - 1), i(l[h + 1], t - 1, e - 1)))
    }, this.noise1d = function (t) {
        var e = 255 & Math.floor(t);
        return t -= Math.floor(t), r((3 - 2 * t) * t * t, n(l[e], t), n(l[e + 1], t - 1))
    }
}

function noise(t, e, i) {
    void 0 === noiseProfile.generator && (noiseProfile.generator = new PerlinNoise(noiseProfile.seed));
    for (var n = noiseProfile.generator, r = 1, a = 1, o = 0, s = 0; s < noiseProfile.octaves; ++s) {
        switch (r *= noiseProfile.fallout, arguments.length) {
            case 1:
                o += r * (1 + n.noise1d(a * t)) / 2;
                break;
            case 2:
                o += r * (1 + n.noise2d(a * t, a * e)) / 2;
                break;
            case 3:
                o += r * (1 + n.noise3d(a * t, a * e, a * i)) / 2
        }
        a *= 2
    }
    return o
}

!function (t, e) {
    "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e(t.THREE = {})
}(this, function (t) {
    function e() {
    }

    function i(t, e) {
        this.x = t || 0, this.y = e || 0
    }

    function n() {
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.")
    }

    function r(t, e, i, n) {
        this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1
    }

    function a(t, e, i) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0
    }

    function o() {
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.")
    }

    function s(t, e, n, r, a, l, c, h, u, p) {
        Object.defineProperty(this, "id", {value: ua++}), this.uuid = la.generateUUID(), this.name = "", this.image = void 0 !== t ? t : s.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : s.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== a ? a : 1006, this.minFilter = void 0 !== l ? l : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== c ? c : 1023, this.type = void 0 !== h ? h : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== p ? p : 3e3, this.version = 0, this.onUpdate = null
    }

    function l(t, e, i, n) {
        this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1
    }

    function c(t, e, i) {
        this.width = t, this.height = e, this.scissor = new l(0, 0, t, e), this.scissorTest = !1, this.viewport = new l(0, 0, t, e), i = i || {}, this.texture = new s(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null
    }

    function h(t, e, i) {
        c.call(this, t, e, i), this.samples = 4
    }

    function u(t, e, i) {
        c.call(this, t, e, i), this.activeMipMapLevel = this.activeCubeFace = 0
    }

    function p(t, e, i, n, r, a, o, l, c, h, u, p) {
        s.call(this, null, a, o, l, c, h, n, r, u, p), this.image = {
            data: t,
            width: e,
            height: i
        }, this.magFilter = void 0 !== c ? c : 1003, this.minFilter = void 0 !== h ? h : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1
    }

    function d(t, e) {
        this.min = void 0 !== t ? t : new a(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new a(-(1 / 0), -(1 / 0), -(1 / 0))
    }

    function f(t, e) {
        this.center = void 0 !== t ? t : new a, this.radius = void 0 !== e ? e : 0
    }

    function m(t, e) {
        this.normal = void 0 !== t ? t : new a(1, 0, 0), this.constant = void 0 !== e ? e : 0
    }

    function g(t, e, i, n, r, a) {
        this.planes = [void 0 !== t ? t : new m, void 0 !== e ? e : new m, void 0 !== i ? i : new m, void 0 !== n ? n : new m, void 0 !== r ? r : new m, void 0 !== a ? a : new m]
    }

    function v(t) {
        var e = {}, i;
        for (i in t) {
            e[i] = {};
            for (var n in t[i]) {
                var r = t[i][n];
                r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? e[i][n] = r.clone() : Array.isArray(r) ? e[i][n] = r.slice() : e[i][n] = r
            }
        }
        return e
    }

    function y(t) {
        for (var e = {}, i = 0; i < t.length; i++) {
            var n = v(t[i]), r;
            for (r in n) e[r] = n[r]
        }
        return e
    }

    function x(t, e, i) {
        return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i)
    }

    function _() {
        function t(r, a) {
            !1 !== i && (n(r, a), e.requestAnimationFrame(t))
        }

        var e = null, i = !1, n = null;
        return {
            start: function () {
                !0 !== i && null !== n && (e.requestAnimationFrame(t), i = !0)
            }, stop: function () {
                i = !1
            }, setAnimationLoop: function (t) {
                n = t
            }, setContext: function (t) {
                e = t
            }
        }
    }

    function b(t) {
        function e(e, i) {
            var n = e.array, r = e.dynamic ? 35048 : 35044, a = t.createBuffer();
            return t.bindBuffer(i, a), t.bufferData(i, n, r), e.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), {
                buffer: a,
                type: i,
                bytesPerElement: n.BYTES_PER_ELEMENT,
                version: e.version
            }
        }

        var i = new WeakMap;
        return {
            get: function (t) {
                return t.isInterleavedBufferAttribute && (t = t.data), i.get(t)
            }, remove: function (e) {
                e.isInterleavedBufferAttribute && (e = e.data);
                var n = i.get(e);
                n && (t.deleteBuffer(n.buffer), i.delete(e))
            }, update: function (n, r) {
                n.isInterleavedBufferAttribute && (n = n.data);
                var a = i.get(n);
                if (void 0 === a) i.set(n, e(n, r)); else if (a.version < n.version) {
                    var o = n, s = o.array, l = o.updateRange;
                    t.bindBuffer(r, a.buffer), !1 === o.dynamic ? t.bufferData(r, s, 35044) : -1 === l.count ? t.bufferSubData(r, 0, s) : 0 === l.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(r, l.offset * s.BYTES_PER_ELEMENT, s.subarray(l.offset, l.offset + l.count)), l.count = -1), a.version = n.version
                }
            }
        }
    }

    function w(t, e, i, n, r, o) {
        this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new a, this.vertexNormals = Array.isArray(n) ? n : [], this.color = r && r.isColor ? r : new x, this.vertexColors = Array.isArray(r) ? r : [], this.materialIndex = void 0 !== o ? o : 0
    }

    function M(t, e, i, n) {
        this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || M.DefaultOrder
    }

    function T() {
        this.mask = 1
    }

    function S() {
        Object.defineProperty(this, "id", {value: va++}), this.uuid = la.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = S.DefaultUp.clone();
        var t = new a, e = new M, i = new r, s = new a(1, 1, 1);
        e.onChange(function () {
            i.setFromEuler(e, !1)
        }), i.onChange(function () {
            e.setFromQuaternion(i, void 0, !1)
        }), Object.defineProperties(this, {
            position: {configurable: !0, enumerable: !0, value: t},
            rotation: {configurable: !0, enumerable: !0, value: e},
            quaternion: {configurable: !0, enumerable: !0, value: i},
            scale: {configurable: !0, enumerable: !0, value: s},
            modelViewMatrix: {value: new n},
            normalMatrix: {value: new o}
        }), this.matrix = new n, this.matrixWorld = new n, this.matrixAutoUpdate = S.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new T, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {}
    }

    function E() {
        Object.defineProperty(this, "id", {value: ya += 2}), this.uuid = la.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1
    }

    function A(t, e, i) {
        if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function P(t, e, i) {
        A.call(this, new Int8Array(t), e, i)
    }

    function L(t, e, i) {
        A.call(this, new Uint8Array(t), e, i)
    }

    function C(t, e, i) {
        A.call(this, new Uint8ClampedArray(t), e, i)
    }

    function R(t, e, i) {
        A.call(this, new Int16Array(t), e, i)
    }

    function O(t, e, i) {
        A.call(this, new Uint16Array(t), e, i)
    }

    function D(t, e, i) {
        A.call(this, new Int32Array(t), e, i)
    }

    function I(t, e, i) {
        A.call(this, new Uint32Array(t), e, i)
    }

    function N(t, e, i) {
        A.call(this, new Float32Array(t), e, i)
    }

    function z(t, e, i) {
        A.call(this, new Float64Array(t), e, i)
    }

    function k() {
        this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1
    }

    function B(t) {
        if (0 === t.length) return -(1 / 0);
        for (var e = t[0], i = 1, n = t.length; i < n; ++i) t[i] > e && (e = t[i]);
        return e
    }

    function F() {
        Object.defineProperty(this, "id", {value: xa += 2}), this.uuid = la.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }

    function H(t, e, i, n, r, a) {
        E.call(this), this.type = "BoxGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: a
        }, this.fromBufferGeometry(new U(t, e, i, n, r, a)), this.mergeVertices()
    }

    function U(t, e, i, n, r, o) {
        function s(t, e, i, n, r, o, s, m, g, v, y) {
            var x = o / g, _ = s / v, b = o / 2, w = s / 2, M = m / 2;
            s = g + 1;
            var T = v + 1, S = o = 0, E, A, P = new a;
            for (A = 0; A < T; A++) {
                var L = A * _ - w;
                for (E = 0; E < s; E++) P[t] = (E * x - b) * n, P[e] = L * r, P[i] = M, h.push(P.x, P.y, P.z), P[t] = 0, P[e] = 0, P[i] = 0 < m ? 1 : -1, u.push(P.x, P.y, P.z), p.push(E / g), p.push(1 - A / v), o += 1
            }
            for (A = 0; A < v; A++) for (E = 0; E < g; E++) t = d + E + s * (A + 1), e = d + (E + 1) + s * (A + 1), i = d + (E + 1) + s * A, c.push(d + E + s * A, t, i), c.push(t, e, i), S += 6;
            l.addGroup(f, S, y), f += S, d += o
        }

        F.call(this), this.type = "BoxBufferGeometry", this.parameters = {
            width: t,
            height: e,
            depth: i,
            widthSegments: n,
            heightSegments: r,
            depthSegments: o
        };
        var l = this;
        t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, r = Math.floor(r) || 1, o = Math.floor(o) || 1;
        var c = [], h = [], u = [], p = [], d = 0, f = 0;
        s("z", "y", "x", -1, -1, i, e, t, o, r, 0), s("z", "y", "x", 1, -1, i, e, -t, o, r, 1), s("x", "z", "y", 1, 1, t, i, e, n, o, 2), s("x", "z", "y", 1, -1, t, i, -e, n, o, 3), s("x", "y", "z", 1, -1, t, e, i, n, r, 4), s("x", "y", "z", -1, -1, t, e, -i, n, r, 5), this.setIndex(c), this.addAttribute("position", new N(h, 3)), this.addAttribute("normal", new N(u, 3)), this.addAttribute("uv", new N(p, 2))
    }

    function G(t, e, i, n) {
        E.call(this), this.type = "PlaneGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        }, this.fromBufferGeometry(new j(t, e, i, n)), this.mergeVertices()
    }

    function j(t, e, i, n) {
        F.call(this), this.type = "PlaneBufferGeometry", this.parameters = {
            width: t,
            height: e,
            widthSegments: i,
            heightSegments: n
        }, t = t || 1, e = e || 1;
        var r = t / 2, a = e / 2;
        i = Math.floor(i) || 1, n = Math.floor(n) || 1;
        var o = i + 1, s = n + 1, l = t / i, c = e / n, h = [], u = [], p = [], d = [];
        for (t = 0; t < s; t++) {
            var f = t * c - a;
            for (e = 0; e < o; e++) u.push(e * l - r, -f, 0), p.push(0, 0, 1), d.push(e / i), d.push(1 - t / n)
        }
        for (t = 0; t < n; t++) for (e = 0; e < i; e++) r = e + o * (t + 1), a = e + 1 + o * (t + 1), s = e + 1 + o * t, h.push(e + o * t, r, s), h.push(r, a, s);
        this.setIndex(h), this.addAttribute("position", new N(u, 3)), this.addAttribute("normal", new N(p, 3)), this.addAttribute("uv", new N(d, 2))
    }

    function V() {
        Object.defineProperty(this, "id", {value: _a++}), this.uuid = la.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0
    }

    function W(t) {
        V.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = {
            derivatives: !1,
            fragDepth: !1,
            drawBuffers: !1,
            shaderTextureLOD: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv2: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t))
    }

    function q(t, e) {
        this.origin = void 0 !== t ? t : new a, this.direction = void 0 !== e ? e : new a
    }

    function X(t, e, i) {
        this.a = void 0 !== t ? t : new a, this.b = void 0 !== e ? e : new a, this.c = void 0 !== i ? i : new a
    }

    function Y(t) {
        V.call(this), this.type = "MeshBasicMaterial", this.color = new x(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t)
    }

    function J(t, e) {
        S.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new F, this.material = void 0 !== e ? e : new Y({color: 16777215 * Math.random()}), this.drawMode = 0, this.updateMorphTargets()
    }

    function Z(t, e, i, n) {
        function r(t, i) {
            e.buffers.color.setClear(t.r, t.g, t.b, i, n)
        }

        var a = new x(0), o = 0, s, l, c = null, h = 0;
        return {
            getClearColor: function () {
                return a
            }, setClearColor: function (t, e) {
                a.set(t), o = void 0 !== e ? e : 1, r(a, o)
            }, getClearAlpha: function () {
                return o
            }, setClearAlpha: function (t) {
                o = t, r(a, o)
            }, render: function (e, n, u, p) {
                n = n.background, null === n ? (r(a, o), c = null, h = 0) : n && n.isColor && (r(n, 1), p = !0, c = null, h = 0), (t.autoClear || p) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === l && (l = new J(new U(1, 1, 1), new W({
                    type: "BackgroundCubeMaterial",
                    uniforms: v(ga.cube.uniforms),
                    vertexShader: ga.cube.vertexShader,
                    fragmentShader: ga.cube.fragmentShader,
                    side: 1,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), l.geometry.removeAttribute("normal"), l.geometry.removeAttribute("uv"), l.onBeforeRender = function (t, e, i) {
                    this.matrixWorld.copyPosition(i.matrixWorld)
                }, Object.defineProperty(l.material, "map", {
                    get: function () {
                        return this.uniforms.tCube.value
                    }
                }), i.update(l)), p = n.isWebGLRenderTargetCube ? n.texture : n, l.material.uniforms.tCube.value = p, l.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, c === n && h === p.version || (l.material.needsUpdate = !0, c = n, h = p.version), e.unshift(l, l.geometry, l.material, 0, 0, null)) : n && n.isTexture && (void 0 === s && (s = new J(new j(2, 2), new W({
                    type: "BackgroundMaterial",
                    uniforms: v(ga.background.uniforms),
                    vertexShader: ga.background.vertexShader,
                    fragmentShader: ga.background.fragmentShader,
                    side: 0,
                    depthTest: !1,
                    depthWrite: !1,
                    fog: !1
                })), s.geometry.removeAttribute("normal"), Object.defineProperty(s.material, "map", {
                    get: function () {
                        return this.uniforms.t2D.value
                    }
                }), i.update(s)), s.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), s.material.uniforms.uvTransform.value.copy(n.matrix), c === n && h === n.version || (s.material.needsUpdate = !0, c = n, h = n.version), e.unshift(s, s.geometry, s.material, 0, 0, null))
            }
        }
    }

    function Q(t, e, i, n) {
        var r;
        this.setMode = function (t) {
            r = t
        }, this.render = function (e, n) {
            t.drawArrays(r, e, n), i.update(n, r)
        }, this.renderInstances = function (a, o, s) {
            if (n.isWebGL2) var l = t; else if (null === (l = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            l[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, o, s, a.maxInstancedCount), i.update(s, r, a.maxInstancedCount)
        }
    }

    function K(t, e, i) {
        function n(e) {
            if ("highp" === e) {
                if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp";
                e = "mediump"
            }
            return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp"
        }

        var r, a = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext,
            o = void 0 !== i.precision ? i.precision : "highp", s = n(o);
        s !== o && (console.warn("THREE.WebGLRenderer:", o, "not supported, using", s, "instead."), o = s), i = !0 === i.logarithmicDepthBuffer, s = t.getParameter(34930);
        var l = t.getParameter(35660), c = t.getParameter(3379), h = t.getParameter(34076), u = t.getParameter(34921),
            p = t.getParameter(36347), d = t.getParameter(36348), f = t.getParameter(36349), m = 0 < l,
            g = a || !!e.get("OES_texture_float"), v = m && g, y = a ? t.getParameter(36183) : 0;
        return {
            isWebGL2: a,
            getMaxAnisotropy: function () {
                if (void 0 !== r) return r;
                var i = e.get("EXT_texture_filter_anisotropic");
                return r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0
            },
            getMaxPrecision: n,
            precision: o,
            logarithmicDepthBuffer: i,
            maxTextures: s,
            maxVertexTextures: l,
            maxTextureSize: c,
            maxCubemapSize: h,
            maxAttributes: u,
            maxVertexUniforms: p,
            maxVaryings: d,
            maxFragmentUniforms: f,
            vertexTextures: m,
            floatFragmentTextures: g,
            floatVertexTextures: v,
            maxSamples: y
        }
    }

    function tt() {
        function t() {
            h.value !== n && (h.value = n, h.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0
        }

        function e(t, e, n, r) {
            var a = null !== t ? t.length : 0, o = null;
            if (0 !== a) {
                if (o = h.value, !0 !== r || null === o) for (r = n + 4 * a, e = e.matrixWorldInverse, c.getNormalMatrix(e), (null === o || o.length < r) && (o = new Float32Array(r)), r = 0; r !== a; ++r, n += 4) l.copy(t[r]).applyMatrix4(e, c), l.normal.toArray(o, n), o[n + 3] = l.constant;
                h.value = o, h.needsUpdate = !0
            }
            return i.numPlanes = a, o
        }

        var i = this, n = null, r = 0, a = !1, s = !1, l = new m, c = new o, h = {value: null, needsUpdate: !1};
        this.uniform = h, this.numIntersection = this.numPlanes = 0, this.init = function (t, i, o) {
            var s = 0 !== t.length || i || 0 !== r || a;
            return a = i, n = e(t, o, 0), r = t.length, s
        }, this.beginShadows = function () {
            s = !0, e(null)
        }, this.endShadows = function () {
            s = !1, t()
        }, this.setState = function (i, o, l, c, u, p) {
            if (!a || null === i || 0 === i.length || s && !l) s ? e(null) : t(); else {
                l = s ? 0 : r;
                var d = 4 * l, f = u.clippingState || null;
                for (h.value = f, f = e(i, c, d, p), i = 0; i !== d; ++i) f[i] = n[i];
                u.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += l
            }
        }
    }

    function et(t) {
        var e = {};
        return {
            get: function (i) {
                if (void 0 !== e[i]) return e[i];
                switch (i) {
                    case"WEBGL_depth_texture":
                        var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture");
                        break;
                    case"EXT_texture_filter_anisotropic":
                        n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                        break;
                    case"WEBGL_compressed_texture_s3tc":
                        n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                        break;
                    case"WEBGL_compressed_texture_pvrtc":
                        n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                        break;
                    default:
                        n = t.getExtension(i)
                }
                return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n
            }
        }
    }

    function it(t, e, i) {
        function n(t) {
            var o = t.target;
            t = r[o.id], null !== t.index && e.remove(t.index);
            for (var s in t.attributes) e.remove(t.attributes[s]);
            o.removeEventListener("dispose", n), delete r[o.id], (s = a[t.id]) && (e.remove(s), delete a[t.id]), i.memory.geometries--
        }

        var r = {}, a = {};
        return {
            get: function (t, e) {
                var a = r[e.id];
                return a ? a : (e.addEventListener("dispose", n), e.isBufferGeometry ? a = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new F).setFromObject(t)), a = e._bufferGeometry), r[e.id] = a, i.memory.geometries++, a)
            }, update: function (t) {
                var i = t.index, n = t.attributes;
                null !== i && e.update(i, 34963);
                for (var r in n) e.update(n[r], 34962);
                t = t.morphAttributes;
                for (r in t) {
                    i = t[r], n = 0;
                    for (var a = i.length; n < a; n++) e.update(i[n], 34962)
                }
            }, getWireframeAttribute: function (t) {
                var i = a[t.id];
                if (i) return i;
                i = [];
                var n = t.index, r = t.attributes;
                if (null !== n) {
                    n = n.array, r = 0;
                    for (var o = n.length; r < o; r += 3) {
                        var s = n[r + 0], l = n[r + 1], c = n[r + 2];
                        i.push(s, l, l, c, c, s)
                    }
                } else for (n = r.position.array, r = 0, o = n.length / 3 - 1; r < o; r += 3) s = r + 0, l = r + 1, c = r + 2, i.push(s, l, l, c, c, s);
                return i = new (65535 < B(i) ? I : O)(i, 1), e.update(i, 34963), a[t.id] = i
            }
        }
    }

    function nt(t, e, i, n) {
        var r, a, o;
        this.setMode = function (t) {
            r = t
        }, this.setIndex = function (t) {
            a = t.type, o = t.bytesPerElement
        }, this.render = function (e, n) {
            t.drawElements(r, n, a, e * o), i.update(n, r)
        }, this.renderInstances = function (s, l, c) {
            if (n.isWebGL2) var h = t; else if (null === (h = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
            h[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, c, a, l * o, s.maxInstancedCount), i.update(c, r, s.maxInstancedCount)
        }
    }

    function rt(t) {
        var e = {frame: 0, calls: 0, triangles: 0, points: 0, lines: 0};
        return {
            memory: {geometries: 0, textures: 0}, render: e, programs: null, autoReset: !0, reset: function () {
                e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0
            }, update: function (t, i, n) {
                switch (n = n || 1, e.calls++, i) {
                    case 4:
                        e.triangles += t / 3 * n;
                        break;
                    case 5:
                    case 6:
                        e.triangles += n * (t - 2);
                        break;
                    case 1:
                        e.lines += t / 2 * n;
                        break;
                    case 3:
                        e.lines += n * (t - 1);
                        break;
                    case 2:
                        e.lines += n * t;
                        break;
                    case 0:
                        e.points += n * t;
                        break;
                    default:
                        console.error("THREE.WebGLInfo: Unknown draw mode:", i)
                }
            }
        }
    }

    function at(t, e) {
        return Math.abs(e[1]) - Math.abs(t[1])
    }

    function ot(t) {
        var e = {}, i = new Float32Array(8);
        return {
            update: function (n, r, a, o) {
                var s = n.morphTargetInfluences, l = s.length;
                if (void 0 === (n = e[r.id])) {
                    n = [];
                    for (var c = 0; c < l; c++) n[c] = [c, 0];
                    e[r.id] = n
                }
                var h = a.morphTargets && r.morphAttributes.position;
                for (a = a.morphNormals && r.morphAttributes.normal, c = 0; c < l; c++) {
                    var u = n[c];
                    0 !== u[1] && (h && r.removeAttribute("morphTarget" + c), a && r.removeAttribute("morphNormal" + c))
                }
                for (c = 0; c < l; c++) u = n[c], u[0] = c, u[1] = s[c];
                for (n.sort(at), c = 0; 8 > c; c++) (u = n[c]) && (s = u[0], l = u[1]) ? (h && r.addAttribute("morphTarget" + c, h[s]), a && r.addAttribute("morphNormal" + c, a[s]), i[c] = l) : i[c] = 0;
                o.getUniforms().setValue(t, "morphTargetInfluences", i)
            }
        }
    }

    function st(t, e) {
        var i = {};
        return {
            update: function (n) {
                var r = e.render.frame, a = n.geometry, o = t.get(n, a);
                return i[o.id] !== r && (a.isGeometry && o.updateFromObject(n), t.update(o), i[o.id] = r), o
            }, dispose: function () {
                i = {}
            }
        }
    }

    function lt(t, e, i, n, r, a, o, l, c, h) {
        t = void 0 !== t ? t : [], s.call(this, t, void 0 !== e ? e : 301, i, n, r, a, o, l, c, h), this.flipY = !1
    }

    function ct(t, e, i, n) {
        s.call(this, null), this.image = {
            data: t,
            width: e,
            height: i,
            depth: n
        }, this.minFilter = this.magFilter = 1003, this.flipY = this.generateMipmaps = !1
    }

    function ht(t, e, i) {
        var n = t[0];
        if (0 >= n || 0 < n) return t;
        var r = e * i, a = Ta[r];
        if (void 0 === a && (a = new Float32Array(r), Ta[r] = a), 0 !== e) for (n.toArray(a, 0), n = 1, r = 0; n !== e; ++n) r += i, t[n].toArray(a, r);
        return a
    }

    function ut(t, e) {
        if (t.length !== e.length) return !1;
        for (var i = 0, n = t.length; i < n; i++) if (t[i] !== e[i]) return !1;
        return !0
    }

    function pt(t, e) {
        for (var i = 0, n = e.length; i < n; i++) t[i] = e[i]
    }

    function dt(t, e) {
        var i = Sa[e];
        void 0 === i && (i = new Int32Array(e), Sa[e] = i);
        for (var n = 0; n !== e; ++n) i[n] = t.allocTextureUnit();
        return i
    }

    function ft(t, e) {
        var i = this.cache;
        i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e)
    }

    function mt(t, e) {
        var i = this.cache;
        i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e)
    }

    function gt(t, e) {
        var i = this.cache;
        void 0 !== e.x ? i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : ut(i, e) || (t.uniform2fv(this.addr, e), pt(i, e))
    }

    function vt(t, e) {
        var i = this.cache;
        void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : void 0 !== e.r ? i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : ut(i, e) || (t.uniform3fv(this.addr, e), pt(i, e))
    }

    function yt(t, e) {
        var i = this.cache;
        void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : ut(i, e) || (t.uniform4fv(this.addr, e), pt(i, e))
    }

    function xt(t, e) {
        var i = this.cache, n = e.elements;
        void 0 === n ? ut(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), pt(i, e)) : ut(i, n) || (Pa.set(n), t.uniformMatrix2fv(this.addr, !1, Pa), pt(i, n))
    }

    function _t(t, e) {
        var i = this.cache, n = e.elements;
        void 0 === n ? ut(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), pt(i, e)) : ut(i, n) || (Aa.set(n), t.uniformMatrix3fv(this.addr, !1, Aa), pt(i, n))
    }

    function bt(t, e) {
        var i = this.cache, n = e.elements;
        void 0 === n ? ut(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), pt(i, e)) : ut(i, n) || (Ea.set(n), t.uniformMatrix4fv(this.addr, !1, Ea), pt(i, n))
    }

    function wt(t, e, i) {
        var n = this.cache, r = i.allocTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2D(e || ba, r)
    }

    function Mt(t, e, i) {
        var n = this.cache, r = i.allocTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || wa, r)
    }

    function Tt(t, e, i) {
        var n = this.cache, r = i.allocTextureUnit();
        n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTextureCube(e || Ma, r)
    }

    function St(t, e) {
        var i = this.cache;
        ut(i, e) || (t.uniform2iv(this.addr, e), pt(i, e))
    }

    function Et(t, e) {
        var i = this.cache;
        ut(i, e) || (t.uniform3iv(this.addr, e), pt(i, e))
    }

    function At(t, e) {
        var i = this.cache;
        ut(i, e) || (t.uniform4iv(this.addr, e), pt(i, e))
    }

    function Pt(t) {
        switch (t) {
            case 5126:
                return ft;
            case 35664:
                return gt;
            case 35665:
                return vt;
            case 35666:
                return yt;
            case 35674:
                return xt;
            case 35675:
                return _t;
            case 35676:
                return bt;
            case 35678:
            case 36198:
                return wt;
            case 35679:
                return Mt;
            case 35680:
                return Tt;
            case 5124:
            case 35670:
                return mt;
            case 35667:
            case 35671:
                return St;
            case 35668:
            case 35672:
                return Et;
            case 35669:
            case 35673:
                return At
        }
    }

    function Lt(t, e) {
        var i = this.cache;
        ut(i, e) || (t.uniform1fv(this.addr, e), pt(i, e))
    }

    function Ct(t, e) {
        var i = this.cache;
        ut(i, e) || (t.uniform1iv(this.addr, e), pt(i, e))
    }

    function Rt(t, e) {
        var i = this.cache;
        e = ht(e, this.size, 2), ut(i, e) || (t.uniform2fv(this.addr, e), this.updateCache(e))
    }

    function Ot(t, e) {
        var i = this.cache;
        e = ht(e, this.size, 3), ut(i, e) || (t.uniform3fv(this.addr, e), this.updateCache(e))
    }

    function Dt(t, e) {
        var i = this.cache;
        e = ht(e, this.size, 4), ut(i, e) || (t.uniform4fv(this.addr, e), this.updateCache(e))
    }

    function It(t, e) {
        var i = this.cache;
        e = ht(e, this.size, 4), ut(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), this.updateCache(e))
    }

    function Nt(t, e) {
        var i = this.cache;
        e = ht(e, this.size, 9), ut(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), this.updateCache(e))
    }

    function zt(t, e) {
        var i = this.cache;
        e = ht(e, this.size, 16), ut(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), this.updateCache(e))
    }

    function kt(t, e, i) {
        var n = this.cache, r = e.length, a = dt(i, r);
        for (!1 === ut(n, a) && (t.uniform1iv(this.addr, a), pt(n, a)), t = 0; t !== r; ++t) i.setTexture2D(e[t] || ba, a[t])
    }

    function Bt(t, e, i) {
        var n = this.cache, r = e.length, a = dt(i, r);
        for (!1 === ut(n, a) && (t.uniform1iv(this.addr, a), pt(n, a)), t = 0; t !== r; ++t) i.setTextureCube(e[t] || Ma, a[t])
    }

    function Ft(t) {
        switch (t) {
            case 5126:
                return Lt;
            case 35664:
                return Rt;
            case 35665:
                return Ot;
            case 35666:
                return Dt;
            case 35674:
                return It;
            case 35675:
                return Nt;
            case 35676:
                return zt;
            case 35678:
                return kt;
            case 35680:
                return Bt;
            case 5124:
            case 35670:
                return Ct;
            case 35667:
            case 35671:
                return St;
            case 35668:
            case 35672:
                return Et;
            case 35669:
            case 35673:
                return At
        }
    }

    function Ht(t, e, i) {
        this.id = t, this.addr = i, this.cache = [], this.setValue = Pt(e.type)
    }

    function Ut(t, e, i) {
        this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = Ft(e.type)
    }

    function Gt(t) {
        this.id = t, this.seq = [], this.map = {}
    }

    function jt(t, e, i) {
        this.seq = [], this.map = {}, this.renderer = i, i = t.getProgramParameter(e, 35718);
        for (var n = 0; n < i; ++n) {
            var r = t.getActiveUniform(e, n), a = t.getUniformLocation(e, r.name), o = this, s = r.name, l = s.length;
            for (La.lastIndex = 0; ;) {
                var c = La.exec(s), h = La.lastIndex, u = c[1], p = c[3];
                if ("]" === c[2] && (u |= 0), void 0 === p || "[" === p && h + 2 === l) {
                    s = o, r = void 0 === p ? new Ht(u, r, a) : new Ut(u, r, a), s.seq.push(r), s.map[r.id] = r;
                    break
                }
                p = o.map[u], void 0 === p && (p = new Gt(u), u = o, o = p, u.seq.push(o), u.map[o.id] = o), o = p
            }
        }
    }

    function Vt(t) {
        t = t.split("\n");
        for (var e = 0; e < t.length; e++) t[e] = e + 1 + ": " + t[e];
        return t.join("\n")
    }

    function Wt(t, e, i) {
        var n = t.createShader(e);
        return t.shaderSource(n, i), t.compileShader(n), !1 === t.getShaderParameter(n, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(n) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(n), Vt(i)), n
    }

    function qt(t) {
        switch (t) {
            case 3e3:
                return ["Linear", "( value )"];
            case 3001:
                return ["sRGB", "( value )"];
            case 3002:
                return ["RGBE", "( value )"];
            case 3004:
                return ["RGBM", "( value, 7.0 )"];
            case 3005:
                return ["RGBM", "( value, 16.0 )"];
            case 3006:
                return ["RGBD", "( value, 256.0 )"];
            case 3007:
                return ["Gamma", "( value, float( GAMMA_FACTOR ) )"];
            default:
                throw Error("unsupported encoding: " + t)
        }
    }

    function Xt(t, e) {
        return e = qt(e), "vec4 " + t + "( vec4 value ) { return " + e[0] + "ToLinear" + e[1] + "; }"
    }

    function Yt(t, e) {
        return e = qt(e), "vec4 " + t + "( vec4 value ) { return LinearTo" + e[0] + e[1] + "; }"
    }

    function Jt(t, e) {
        switch (e) {
            case 1:
                e = "Linear";
                break;
            case 2:
                e = "Reinhard";
                break;
            case 3:
                e = "Uncharted2";
                break;
            case 4:
                e = "OptimizedCineon";
                break;
            case 5:
                e = "ACESFilmic";
                break;
            default:
                throw Error("unsupported toneMapping: " + e)
        }
        return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }"
    }

    function Zt(t, e, i) {
        return t = t || {},
            [t.derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qt).join("\n")
    }

    function $t(t) {
        var e = [], i;
        for (i in t) {
            var n = t[i];
            !1 !== n && e.push("#define " + i + " " + n)
        }
        return e.join("\n")
    }

    function Qt(t) {
        return "" !== t
    }

    function Kt(t, e) {
        return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights)
    }

    function te(t, e) {
        return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
    }

    function ee(t) {
        return t.replace(/^[ \t]*#include +<([\w\d.\/]+)>/gm, function (t, e) {
            if (void 0 === (t = pa[e])) throw Error("Can not resolve #include <" + e + ">");
            return ee(t)
        })
    }

    function ie(t) {
        return t.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, function (t, e, i, n) {
            for (t = "", e = parseInt(e); e < parseInt(i); e++) t += n.replace(/\[ i \]/g, "[ " + e + " ]");
            return t
        })
    }

    function ne(t, e, i, n, r, a, o) {
        var s = t.context, l = n.defines, c = r.vertexShader, h = r.fragmentShader, u = "SHADOWMAP_TYPE_BASIC";
        1 === a.shadowMapType ? u = "SHADOWMAP_TYPE_PCF" : 2 === a.shadowMapType && (u = "SHADOWMAP_TYPE_PCF_SOFT");
        var p = "ENVMAP_TYPE_CUBE", d = "ENVMAP_MODE_REFLECTION", f = "ENVMAP_BLENDING_MULTIPLY";
        if (a.envMap) {
            switch (n.envMap.mapping) {
                case 301:
                case 302:
                    p = "ENVMAP_TYPE_CUBE";
                    break;
                case 306:
                case 307:
                    p = "ENVMAP_TYPE_CUBE_UV";
                    break;
                case 303:
                case 304:
                    p = "ENVMAP_TYPE_EQUIREC";
                    break;
                case 305:
                    p = "ENVMAP_TYPE_SPHERE"
            }
            switch (n.envMap.mapping) {
                case 302:
                case 304:
                    d = "ENVMAP_MODE_REFRACTION"
            }
            switch (n.combine) {
                case 0:
                    f = "ENVMAP_BLENDING_MULTIPLY";
                    break;
                case 1:
                    f = "ENVMAP_BLENDING_MIX";
                    break;
                case 2:
                    f = "ENVMAP_BLENDING_ADD"
            }
        }
        var m = 0 < t.gammaFactor ? t.gammaFactor : 1, g = o.isWebGL2 ? "" : Zt(n.extensions, a, e), v = $t(l),
            y = s.createProgram();
        n.isRawShaderMaterial ? (l = [v].filter(Qt).join("\n"), 0 < l.length && (l += "\n"), e = [g, v].filter(Qt).join("\n"), 0 < e.length && (e += "\n")) : (l = ["precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, v, a.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + m, "#define MAX_BONES " + a.maxBones, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + d : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.displacementMap && a.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.skinning ? "#define USE_SKINNING" : "", a.useVertexTexture ? "#define BONE_TEXTURE" : "", a.morphTargets ? "#define USE_MORPHTARGETS" : "", a.morphNormals && !1 === a.flatShading ? "#define USE_MORPHNORMALS" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qt).join("\n"), e = [g, "precision " + a.precision + " float;", "precision " + a.precision + " int;", "#define SHADER_NAME " + r.name, v, a.alphaTest ? "#define ALPHATEST " + a.alphaTest + (a.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + m, a.useFog && a.fog ? "#define USE_FOG" : "", a.useFog && a.fogExp ? "#define FOG_EXP2" : "", a.map ? "#define USE_MAP" : "", a.matcap ? "#define USE_MATCAP" : "", a.envMap ? "#define USE_ENVMAP" : "", a.envMap ? "#define " + p : "", a.envMap ? "#define " + d : "", a.envMap ? "#define " + f : "", a.lightMap ? "#define USE_LIGHTMAP" : "", a.aoMap ? "#define USE_AOMAP" : "", a.emissiveMap ? "#define USE_EMISSIVEMAP" : "", a.bumpMap ? "#define USE_BUMPMAP" : "", a.normalMap ? "#define USE_NORMALMAP" : "", a.normalMap && a.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", a.specularMap ? "#define USE_SPECULARMAP" : "", a.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", a.metalnessMap ? "#define USE_METALNESSMAP" : "", a.alphaMap ? "#define USE_ALPHAMAP" : "", a.vertexColors ? "#define USE_COLOR" : "", a.gradientMap ? "#define USE_GRADIENTMAP" : "", a.flatShading ? "#define FLAT_SHADED" : "", a.doubleSided ? "#define DOUBLE_SIDED" : "", a.flipSided ? "#define FLIP_SIDED" : "", a.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", a.shadowMapEnabled ? "#define " + u : "", a.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", a.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", a.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", a.logarithmicDepthBuffer && (o.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", a.envMap && (o.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== a.toneMapping ? "#define TONE_MAPPING" : "", 0 !== a.toneMapping ? pa.tonemapping_pars_fragment : "", 0 !== a.toneMapping ? Jt("toneMapping", a.toneMapping) : "", a.dithering ? "#define DITHERING" : "", a.outputEncoding || a.mapEncoding || a.matcapEncoding || a.envMapEncoding || a.emissiveMapEncoding ? pa.encodings_pars_fragment : "", a.mapEncoding ? Xt("mapTexelToLinear", a.mapEncoding) : "", a.matcapEncoding ? Xt("matcapTexelToLinear", a.matcapEncoding) : "", a.envMapEncoding ? Xt("envMapTexelToLinear", a.envMapEncoding) : "", a.emissiveMapEncoding ? Xt("emissiveMapTexelToLinear", a.emissiveMapEncoding) : "", a.outputEncoding ? Yt("linearToOutputTexel", a.outputEncoding) : "", a.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Qt).join("\n")), c = ee(c), c = Kt(c, a), c = te(c, a), h = ee(h), h = Kt(h, a), h = te(h, a), c = ie(c), h = ie(h), o.isWebGL2 && !n.isRawShaderMaterial && (o = !1, u = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== c.match(u) && null !== h.match(u) && (o = !0, c = c.replace(u, ""), h = h.replace(u, "")), l = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + l, e = ["#version 300 es\n\n#define varying in", o ? "" : "out highp vec4 pc_fragColor;", o ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + e), h = e + h, c = Wt(s, 35633, l + c), h = Wt(s, 35632, h), s.attachShader(y, c), s.attachShader(y, h), void 0 !== n.index0AttributeName ? s.bindAttribLocation(y, 0, n.index0AttributeName) : !0 === a.morphTargets && s.bindAttribLocation(y, 0, "position"), s.linkProgram(y), a = s.getProgramInfoLog(y).trim(), o = s.getShaderInfoLog(c).trim(), u = s.getShaderInfoLog(h).trim(), d = p = !0, !1 === s.getProgramParameter(y, 35714) ? (p = !1, console.error("THREE.WebGLProgram: shader error: ", s.getError(), "35715", s.getProgramParameter(y, 35715), "gl.getProgramInfoLog", a, o, u)) : "" !== a ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", a) : "" !== o && "" !== u || (d = !1), d && (this.diagnostics = {
            runnable: p,
            material: n,
            programLog: a,
            vertexShader: {log: o, prefix: l},
            fragmentShader: {log: u, prefix: e}
        }), s.deleteShader(c), s.deleteShader(h);
        var x;
        this.getUniforms = function () {
            return void 0 === x && (x = new jt(s, y, t)), x
        };
        var _;
        return this.getAttributes = function () {
            if (void 0 === _) {
                for (var t = {}, e = s.getProgramParameter(y, 35721), i = 0; i < e; i++) {
                    var n = s.getActiveAttrib(y, i).name;
                    t[n] = s.getAttribLocation(y, n)
                }
                _ = t
            }
            return _
        }, this.destroy = function () {
            s.deleteProgram(y), this.program = void 0
        }, Object.defineProperties(this, {
            uniforms: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms()
                }
            }, attributes: {
                get: function () {
                    return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes()
                }
            }
        }), this.name = r.name, this.id = Ca++, this.code = i, this.usedTimes = 1, this.program = y, this.vertexShader = c, this.fragmentShader = h, this
    }

    function re(t, e, i) {
        function n(t, e) {
            if (t) t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding); else var i = 3e3;
            return 3e3 === i && e && (i = 3007), i
        }

        var r = [], a = {
                MeshDepthMaterial: "depth",
                MeshDistanceMaterial: "distanceRGBA",
                MeshNormalMaterial: "normal",
                MeshBasicMaterial: "basic",
                MeshLambertMaterial: "lambert",
                MeshPhongMaterial: "phong",
                MeshToonMaterial: "phong",
                MeshStandardMaterial: "physical",
                MeshPhysicalMaterial: "physical",
                MeshMatcapMaterial: "matcap",
                LineBasicMaterial: "basic",
                LineDashedMaterial: "dashed",
                PointsMaterial: "points",
                ShadowMaterial: "shadow",
                SpriteMaterial: "sprite"
            },
            o = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" ");
        this.getParameters = function (e, r, o, s, l, c, h) {
            var u = a[e.type];
            if (h.isSkinnedMesh) {
                var p = h.skeleton.bones;
                if (i.floatVertexTextures) p = 1024; else {
                    var d = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), p.length);
                    d < p.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + p.length + " bones. This GPU supports " + d + "."), p = 0) : p = d
                }
            } else p = 0;
            d = i.precision, null !== e.precision && (d = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", d, "instead.");
            var f = t.getRenderTarget();
            return {
                shaderID: u,
                precision: d,
                supportsVertexTextures: i.vertexTextures,
                outputEncoding: n(f ? f.texture : null, t.gammaOutput),
                map: !!e.map,
                mapEncoding: n(e.map, t.gammaInput),
                matcap: !!e.matcap,
                matcapEncoding: n(e.matcap, t.gammaInput),
                envMap: !!e.envMap,
                envMapMode: e.envMap && e.envMap.mapping,
                envMapEncoding: n(e.envMap, t.gammaInput),
                envMapCubeUV: !!e.envMap && (306 === e.envMap.mapping || 307 === e.envMap.mapping),
                lightMap: !!e.lightMap,
                aoMap: !!e.aoMap,
                emissiveMap: !!e.emissiveMap,
                emissiveMapEncoding: n(e.emissiveMap, t.gammaInput),
                bumpMap: !!e.bumpMap,
                normalMap: !!e.normalMap,
                objectSpaceNormalMap: 1 === e.normalMapType,
                displacementMap: !!e.displacementMap,
                roughnessMap: !!e.roughnessMap,
                metalnessMap: !!e.metalnessMap,
                specularMap: !!e.specularMap,
                alphaMap: !!e.alphaMap,
                gradientMap: !!e.gradientMap,
                combine: e.combine,
                vertexColors: e.vertexColors,
                fog: !!s,
                useFog: e.fog,
                fogExp: s && s.isFogExp2,
                flatShading: e.flatShading,
                sizeAttenuation: e.sizeAttenuation,
                logarithmicDepthBuffer: i.logarithmicDepthBuffer,
                skinning: e.skinning && 0 < p,
                maxBones: p,
                useVertexTexture: i.floatVertexTextures,
                morphTargets: e.morphTargets,
                morphNormals: e.morphNormals,
                maxMorphTargets: t.maxMorphTargets,
                maxMorphNormals: t.maxMorphNormals,
                numDirLights: r.directional.length,
                numPointLights: r.point.length,
                numSpotLights: r.spot.length,
                numRectAreaLights: r.rectArea.length,
                numHemiLights: r.hemi.length,
                numClippingPlanes: l,
                numClipIntersection: c,
                dithering: e.dithering,
                shadowMapEnabled: t.shadowMap.enabled && h.receiveShadow && 0 < o.length,
                shadowMapType: t.shadowMap.type,
                toneMapping: t.toneMapping,
                physicallyCorrectLights: t.physicallyCorrectLights,
                premultipliedAlpha: e.premultipliedAlpha,
                alphaTest: e.alphaTest,
                doubleSided: 2 === e.side,
                flipSided: 1 === e.side,
                depthPacking: void 0 !== e.depthPacking && e.depthPacking
            }
        }, this.getProgramCode = function (e, i) {
            var n = [];
            if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (var r in e.defines) n.push(r), n.push(e.defines[r]);
            for (r = 0; r < o.length; r++) n.push(i[o[r]]);
            return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join()
        }, this.acquireProgram = function (n, a, o, s) {
            for (var l, c = 0, h = r.length; c < h; c++) {
                var u = r[c];
                if (u.code === s) {
                    l = u, ++l.usedTimes;
                    break
                }
            }
            return void 0 === l && (l = new ne(t, e, s, n, a, o, i), r.push(l)), l
        }, this.releaseProgram = function (t) {
            if (0 == --t.usedTimes) {
                r[r.indexOf(t)] = r[r.length - 1], r.pop(), t.destroy()
            }
        }, this.programs = r
    }

    function ae() {
        var t = new WeakMap;
        return {
            get: function (e) {
                var i = t.get(e);
                return void 0 === i && (i = {}, t.set(e, i)), i
            }, remove: function (e) {
                t.delete(e)
            }, update: function (e, i, n) {
                t.get(e)[i] = n
            }, dispose: function () {
                t = new WeakMap
            }
        }
    }

    function oe(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program && e.program && t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id
    }

    function se(t, e) {
        return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id
    }

    function le() {
        function t(t, n, r, a, o, s) {
            var l = e[i];
            return void 0 === l ? (l = {
                id: t.id,
                object: t,
                geometry: n,
                material: r,
                program: r.program,
                groupOrder: a,
                renderOrder: t.renderOrder,
                z: o,
                group: s
            }, e[i] = l) : (l.id = t.id, l.object = t, l.geometry = n, l.material = r, l.program = r.program, l.groupOrder = a, l.renderOrder = t.renderOrder, l.z = o, l.group = s), i++, l
        }

        var e = [], i = 0, n = [], r = [];
        return {
            opaque: n, transparent: r, init: function () {
                i = 0, n.length = 0, r.length = 0
            }, push: function (e, i, a, o, s, l) {
                e = t(e, i, a, o, s, l), (!0 === a.transparent ? r : n).push(e)
            }, unshift: function (e, i, a, o, s, l) {
                e = t(e, i, a, o, s, l), (!0 === a.transparent ? r : n).unshift(e)
            }, sort: function () {
                1 < n.length && n.sort(oe), 1 < r.length && r.sort(se)
            }
        }
    }

    function ce() {
        function t(i) {
            i = i.target, i.removeEventListener("dispose", t), delete e[i.id]
        }

        var e = {};
        return {
            get: function (i, n) {
                var r = e[i.id];
                if (void 0 === r) {
                    var a = new le;
                    e[i.id] = {}, e[i.id][n.id] = a, i.addEventListener("dispose", t)
                } else void 0 === (a = r[n.id]) && (a = new le, r[n.id] = a);
                return a
            }, dispose: function () {
                e = {}
            }
        }
    }

    function he() {
        var t = {};
        return {
            get: function (e) {
                if (void 0 !== t[e.id]) return t[e.id];
                switch (e.type) {
                    case"DirectionalLight":
                        var n = {
                            direction: new a,
                            color: new x,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case"SpotLight":
                        n = {
                            position: new a,
                            direction: new a,
                            color: new x,
                            distance: 0,
                            coneCos: 0,
                            penumbraCos: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i
                        };
                        break;
                    case"PointLight":
                        n = {
                            position: new a,
                            color: new x,
                            distance: 0,
                            decay: 0,
                            shadow: !1,
                            shadowBias: 0,
                            shadowRadius: 1,
                            shadowMapSize: new i,
                            shadowCameraNear: 1,
                            shadowCameraFar: 1e3
                        };
                        break;
                    case"HemisphereLight":
                        n = {direction: new a, skyColor: new x, groundColor: new x};
                        break;
                    case"RectAreaLight":
                        n = {color: new x, position: new a, halfWidth: new a, halfHeight: new a}
                }
                return t[e.id] = n
            }
        }
    }

    function ue() {
        var t = new he, e = {
            id: Ra++,
            hash: {
                stateID: -1,
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                shadowsLength: -1
            },
            ambient: [0, 0, 0],
            directional: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotShadowMap: [],
            spotShadowMatrix: [],
            rectArea: [],
            point: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: []
        }, i = new a, r = new n, o = new n;
        return {
            setup: function (n, a, s) {
                var l = 0, c = 0, h = 0, u = 0, p = 0, d = 0, f = 0, m = 0;
                s = s.matrixWorldInverse;
                for (var g = 0, v = n.length; g < v; g++) {
                    var y = n[g], x = y.color, _ = y.intensity, b = y.distance,
                        w = y.shadow && y.shadow.map ? y.shadow.map.texture : null;
                    if (y.isAmbientLight) l += x.r * _, c += x.g * _, h += x.b * _; else if (y.isDirectionalLight) {
                        var M = t.get(y);
                        M.color.copy(y.color).multiplyScalar(y.intensity), M.direction.setFromMatrixPosition(y.matrixWorld), i.setFromMatrixPosition(y.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(s), (M.shadow = y.castShadow) && (x = y.shadow, M.shadowBias = x.bias, M.shadowRadius = x.radius, M.shadowMapSize = x.mapSize), e.directionalShadowMap[u] = w, e.directionalShadowMatrix[u] = y.shadow.matrix, e.directional[u] = M, u++
                    } else y.isSpotLight ? (M = t.get(y), M.position.setFromMatrixPosition(y.matrixWorld), M.position.applyMatrix4(s), M.color.copy(x).multiplyScalar(_), M.distance = b, M.direction.setFromMatrixPosition(y.matrixWorld), i.setFromMatrixPosition(y.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(s), M.coneCos = Math.cos(y.angle), M.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), M.decay = y.decay, (M.shadow = y.castShadow) && (x = y.shadow, M.shadowBias = x.bias, M.shadowRadius = x.radius, M.shadowMapSize = x.mapSize), e.spotShadowMap[d] = w, e.spotShadowMatrix[d] = y.shadow.matrix, e.spot[d] = M, d++) : y.isRectAreaLight ? (M = t.get(y), M.color.copy(x).multiplyScalar(_), M.position.setFromMatrixPosition(y.matrixWorld), M.position.applyMatrix4(s), o.identity(), r.copy(y.matrixWorld), r.premultiply(s), o.extractRotation(r), M.halfWidth.set(.5 * y.width, 0, 0), M.halfHeight.set(0, .5 * y.height, 0), M.halfWidth.applyMatrix4(o), M.halfHeight.applyMatrix4(o), e.rectArea[f] = M, f++) : y.isPointLight ? (M = t.get(y), M.position.setFromMatrixPosition(y.matrixWorld), M.position.applyMatrix4(s), M.color.copy(y.color).multiplyScalar(y.intensity), M.distance = y.distance, M.decay = y.decay, (M.shadow = y.castShadow) && (x = y.shadow, M.shadowBias = x.bias, M.shadowRadius = x.radius, M.shadowMapSize = x.mapSize, M.shadowCameraNear = x.camera.near, M.shadowCameraFar = x.camera.far), e.pointShadowMap[p] = w, e.pointShadowMatrix[p] = y.shadow.matrix, e.point[p] = M, p++) : y.isHemisphereLight && (M = t.get(y), M.direction.setFromMatrixPosition(y.matrixWorld), M.direction.transformDirection(s), M.direction.normalize(), M.skyColor.copy(y.color).multiplyScalar(_), M.groundColor.copy(y.groundColor).multiplyScalar(_), e.hemi[m] = M, m++)
                }
                e.ambient[0] = l, e.ambient[1] = c, e.ambient[2] = h, e.directional.length = u, e.spot.length = d, e.rectArea.length = f, e.point.length = p, e.hemi.length = m, e.hash.stateID = e.id, e.hash.directionalLength = u, e.hash.pointLength = p, e.hash.spotLength = d, e.hash.rectAreaLength = f, e.hash.hemiLength = m, e.hash.shadowsLength = a.length
            }, state: e
        }
    }

    function pe() {
        var t = new ue, e = [], i = [];
        return {
            init: function () {
                e.length = 0, i.length = 0
            }, state: {lightsArray: e, shadowsArray: i, lights: t}, setupLights: function (n) {
                t.setup(e, i, n)
            }, pushLight: function (t) {
                e.push(t)
            }, pushShadow: function (t) {
                i.push(t)
            }
        }
    }

    function de() {
        function t(i) {
            i = i.target, i.removeEventListener("dispose", t), delete e[i.id]
        }

        var e = {};
        return {
            get: function (i, n) {
                if (void 0 === e[i.id]) {
                    var r = new pe;
                    e[i.id] = {}, e[i.id][n.id] = r, i.addEventListener("dispose", t)
                } else void 0 === e[i.id][n.id] ? (r = new pe, e[i.id][n.id] = r) : r = e[i.id][n.id];
                return r
            }, dispose: function () {
                e = {}
            }
        }
    }

    function fe(t) {
        V.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t)
    }

    function me(t) {
        V.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new a, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t)
    }

    function ge(t, e, r) {
        function o(e, i, n, r, a, o) {
            var s = e.geometry, l = v, c = e.customDepthMaterial;
            return n && (l = y, c = e.customDistanceMaterial), c ? l = c : (c = !1, i.morphTargets && (s && s.isBufferGeometry ? c = s.morphAttributes && s.morphAttributes.position && 0 < s.morphAttributes.position.length : s && s.isGeometry && (c = s.morphTargets && 0 < s.morphTargets.length)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e), e = e.isSkinnedMesh && i.skinning, s = 0, c && (s |= 1), e && (s |= 2), l = l[s]), t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (s = l.uuid, c = i.uuid, e = x[s], void 0 === e && (e = {}, x[s] = e), s = e[c], void 0 === s && (s = l.clone(), e[c] = s), l = s), l.visible = i.visible, l.wireframe = i.wireframe, l.side = null != i.shadowSide ? i.shadowSide : _[i.side], l.clipShadows = i.clipShadows, l.clippingPlanes = i.clippingPlanes, l.clipIntersection = i.clipIntersection, l.wireframeLinewidth = i.wireframeLinewidth, l.linewidth = i.linewidth, n && l.isMeshDistanceMaterial && (l.referencePosition.copy(r), l.nearDistance = a, l.farDistance = o), l
        }

        function s(i, n, r, a) {
            if (!1 !== i.visible) {
                if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || h.intersectsObject(i))) {
                    i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
                    var l = e.update(i), c = i.material;
                    if (Array.isArray(c)) for (var u = l.groups, p = 0, d = u.length; p < d; p++) {
                        var f = u[p], g = c[f.materialIndex];
                        g && g.visible && (g = o(i, g, a, m, r.near, r.far), t.renderBufferDirect(r, null, l, g, i, f))
                    } else c.visible && (g = o(i, c, a, m, r.near, r.far), t.renderBufferDirect(r, null, l, g, i, null))
                }
                for (i = i.children, l = 0, c = i.length; l < c; l++) s(i[l], n, r, a)
            }
        }

        var h = new g, u = new n, p = new i, d = new i(r, r), f = new a, m = new a, v = Array(4), y = Array(4), x = {},
            _ = {0: 1, 1: 0, 2: 2},
            b = [new a(1, 0, 0), new a(-1, 0, 0), new a(0, 0, 1), new a(0, 0, -1), new a(0, 1, 0), new a(0, -1, 0)],
            w = [new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 1, 0), new a(0, 0, 1), new a(0, 0, -1)],
            M = [new l, new l, new l, new l, new l, new l];
        for (r = 0; 4 !== r; ++r) {
            var T = 0 != (1 & r), S = 0 != (2 & r), E = new fe({depthPacking: 3201, morphTargets: T, skinning: S});
            v[r] = E, T = new me({morphTargets: T, skinning: S}), y[r] = T
        }
        var A = this;
        this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, i, n) {
            if (!1 !== A.enabled && (!1 !== A.autoUpdate || !1 !== A.needsUpdate) && 0 !== e.length) {
                var r = t.state;
                r.setBlending(0), r.buffers.color.setClear(1, 1, 1, 1), r.buffers.depth.setTest(!0), r.setScissorTest(!1);
                for (var a, o = 0, l = e.length; o < l; o++) {
                    var g = e[o];
                    a = g.shadow;
                    var v = g && g.isPointLight;
                    if (void 0 === a) console.warn("THREE.WebGLShadowMap:", g, "has no shadow."); else {
                        var y = a.camera;
                        if (p.copy(a.mapSize), p.min(d), v) {
                            var x = p.x, _ = p.y;
                            M[0].set(2 * x, _, x, _), M[1].set(0, _, x, _), M[2].set(3 * x, _, x, _), M[3].set(x, _, x, _), M[4].set(3 * x, 0, x, _), M[5].set(x, 0, x, _), p.x *= 4, p.y *= 2
                        }
                        for (null === a.map && (a.map = new c(p.x, p.y, {
                            minFilter: 1003,
                            magFilter: 1003,
                            format: 1023
                        }), a.map.texture.name = g.name + ".shadowMap", y.updateProjectionMatrix()), a.isSpotLightShadow && a.update(g), x = a.map, _ = a.matrix, m.setFromMatrixPosition(g.matrixWorld), y.position.copy(m), v ? (a = 6, _.makeTranslation(-m.x, -m.y, -m.z)) : (a = 1, f.setFromMatrixPosition(g.target.matrixWorld), y.lookAt(f), y.updateMatrixWorld(), _.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), _.multiply(y.projectionMatrix), _.multiply(y.matrixWorldInverse)), t.setRenderTarget(x), t.clear(), g = 0; g < a; g++) v && (f.copy(y.position), f.add(b[g]), y.up.copy(w[g]), y.lookAt(f), y.updateMatrixWorld(), r.viewport(M[g])), u.multiplyMatrices(y.projectionMatrix, y.matrixWorldInverse), h.setFromMatrix(u), s(i, n, y, v)
                    }
                }
                A.needsUpdate = !1
            }
        }
    }

    function ve(t, e, i, n) {
        function r(e, i, n) {
            var r = new Uint8Array(4), a = t.createTexture();
            for (t.bindTexture(e, a), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728), e = 0; e < n; e++) t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r);
            return a
        }

        function a(i, r) {
            y[i] = 1, 0 === x[i] && (t.enableVertexAttribArray(i), x[i] = 1), _[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), _[i] = r)
        }

        function o(e) {
            !0 !== b[e] && (t.enable(e), b[e] = !0)
        }

        function s(e) {
            !1 !== b[e] && (t.disable(e), b[e] = !1)
        }

        function c(e, n, r, a, l, c, h, u) {
            if (0 === e) T && (s(3042), T = !1); else if (T || (o(3042), T = !0), 5 !== e) {
                if (e !== S || u !== O) {
                    if (100 === E && 100 === L || (t.blendEquation(32774), L = E = 100), u) switch (e) {
                        case 1:
                            t.blendFuncSeparate(1, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(1, 1);
                            break;
                        case 3:
                            t.blendFuncSeparate(0, 0, 769, 771);
                            break;
                        case 4:
                            t.blendFuncSeparate(0, 768, 0, 770);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    } else switch (e) {
                        case 1:
                            t.blendFuncSeparate(770, 771, 1, 771);
                            break;
                        case 2:
                            t.blendFunc(770, 1);
                            break;
                        case 3:
                            t.blendFunc(0, 769);
                            break;
                        case 4:
                            t.blendFunc(0, 768);
                            break;
                        default:
                            console.error("THREE.WebGLState: Invalid blending: ", e)
                    }
                    R = C = P = A = null, S = e, O = u
                }
            } else l = l || n, c = c || r, h = h || a, n === E && l === L || (t.blendEquationSeparate(i.convert(n), i.convert(l)), E = n, L = l), r === A && a === P && c === C && h === R || (t.blendFuncSeparate(i.convert(r), i.convert(a), i.convert(c), i.convert(h)), A = r, P = a, C = c, R = h), S = e, O = null
        }

        function h(e) {
            D !== e && (e ? t.frontFace(2304) : t.frontFace(2305), D = e)
        }

        function u(e) {
            0 !== e ? (o(2884), e !== I && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : s(2884), I = e
        }

        function p(e, i, n) {
            e ? (o(32823), (z !== i || k !== n) && (t.polygonOffset(i, n), z = i, k = n)) : s(32823)
        }

        function d(e) {
            void 0 === e && (e = 33984 + B - 1), H !== e && (t.activeTexture(e), H = e)
        }

        var f = new function () {
                var e = !1, i = new l, n = null, r = new l(0, 0, 0, 0);
                return {
                    setMask: function (i) {
                        n === i || e || (t.colorMask(i, i, i, i), n = i)
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e, n, a, o, s) {
                        !0 === s && (e *= o, n *= o, a *= o), i.set(e, n, a, o), !1 === r.equals(i) && (t.clearColor(e, n, a, o), r.copy(i))
                    }, reset: function () {
                        e = !1, n = null, r.set(-1, 0, 0, 0)
                    }
                }
            }, m = new function () {
                var e = !1, i = null, n = null, r = null;
                return {
                    setTest: function (t) {
                        t ? o(2929) : s(2929)
                    }, setMask: function (n) {
                        i === n || e || (t.depthMask(n), i = n)
                    }, setFunc: function (e) {
                        if (n !== e) {
                            if (e) switch (e) {
                                case 0:
                                    t.depthFunc(512);
                                    break;
                                case 1:
                                    t.depthFunc(519);
                                    break;
                                case 2:
                                    t.depthFunc(513);
                                    break;
                                case 3:
                                    t.depthFunc(515);
                                    break;
                                case 4:
                                    t.depthFunc(514);
                                    break;
                                case 5:
                                    t.depthFunc(518);
                                    break;
                                case 6:
                                    t.depthFunc(516);
                                    break;
                                case 7:
                                    t.depthFunc(517);
                                    break;
                                default:
                                    t.depthFunc(515)
                            } else t.depthFunc(515);
                            n = e
                        }
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e) {
                        r !== e && (t.clearDepth(e), r = e)
                    }, reset: function () {
                        e = !1, r = n = i = null
                    }
                }
            }, g = new function () {
                var e = !1, i = null, n = null, r = null, a = null, l = null, c = null, h = null, u = null;
                return {
                    setTest: function (t) {
                        t ? o(2960) : s(2960)
                    }, setMask: function (n) {
                        i === n || e || (t.stencilMask(n), i = n)
                    }, setFunc: function (e, i, o) {
                        n === e && r === i && a === o || (t.stencilFunc(e, i, o), n = e, r = i, a = o)
                    }, setOp: function (e, i, n) {
                        l === e && c === i && h === n || (t.stencilOp(e, i, n), l = e, c = i, h = n)
                    }, setLocked: function (t) {
                        e = t
                    }, setClear: function (e) {
                        u !== e && (t.clearStencil(e), u = e)
                    }, reset: function () {
                        e = !1, u = h = c = l = a = r = n = i = null
                    }
                }
            }, v = t.getParameter(34921), y = new Uint8Array(v), x = new Uint8Array(v), _ = new Uint8Array(v), b = {},
            w = null, M = null, T = null, S = null, E = null, A = null, P = null, L = null, C = null, R = null, O = !1,
            D = null, I = null, N = null, z = null, k = null, B = t.getParameter(35661), F = !1;
        v = 0, v = t.getParameter(7938), -1 !== v.indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), F = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), F = 2 <= v);
        var H = null, U = {}, G = new l, j = new l, V = {};
        return V[3553] = r(3553, 3553, 1), V[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), o(2929), m.setFunc(3), h(!1), u(1), o(2884), c(0), {
            buffers: {color: f, depth: m, stencil: g}, initAttributes: function () {
                for (var t = 0, e = y.length; t < e; t++) y[t] = 0
            }, enableAttribute: function (t) {
                a(t, 0)
            }, enableAttributeAndDivisor: a, disableUnusedAttributes: function () {
                for (var e = 0, i = x.length; e !== i; ++e) x[e] !== y[e] && (t.disableVertexAttribArray(e), x[e] = 0)
            }, enable: o, disable: s, getCompressedTextureFormats: function () {
                if (null === w && (w = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc"))) for (var i = t.getParameter(34467), n = 0; n < i.length; n++) w.push(i[n]);
                return w
            }, useProgram: function (e) {
                return M !== e && (t.useProgram(e), M = e, !0)
            }, setBlending: c, setMaterial: function (t, e) {
                2 === t.side ? s(2884) : o(2884);
                var i = 1 === t.side;
                e && (i = !i), h(i), 1 === t.blending && !1 === t.transparent ? c(0) : c(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), m.setFunc(t.depthFunc), m.setTest(t.depthTest), m.setMask(t.depthWrite), f.setMask(t.colorWrite), p(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits)
            }, setFlipSided: h, setCullFace: u, setLineWidth: function (e) {
                e !== N && (F && t.lineWidth(e), N = e)
            }, setPolygonOffset: p, setScissorTest: function (t) {
                t ? o(3089) : s(3089)
            }, activeTexture: d, bindTexture: function (e, i) {
                null === H && d();
                var n = U[H];
                void 0 === n && (n = {
                    type: void 0,
                    texture: void 0
                }, U[H] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || V[e]), n.type = e, n.texture = i)
            }, compressedTexImage2D: function () {
                try {
                    t.compressedTexImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            }, texImage2D: function () {
                try {
                    t.texImage2D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            }, texImage3D: function () {
                try {
                    t.texImage3D.apply(t, arguments)
                } catch (t) {
                    console.error("THREE.WebGLState:", t)
                }
            }, scissor: function (e) {
                !1 === G.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), G.copy(e))
            }, viewport: function (e) {
                !1 === j.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), j.copy(e))
            }, reset: function () {
                for (var e = 0; e < x.length; e++) 1 === x[e] && (t.disableVertexAttribArray(e), x[e] = 0);
                b = {}, H = w = null, U = {}, I = D = S = M = null, f.reset(), m.reset(), g.reset()
            }
        }
    }

    function ye(t, e, i, n, r, a, o) {
        function s(t, e, i, n) {
            var r = 1;
            if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), 1 > r || !0 === e) {
                if (t instanceof HTMLImageElement || t instanceof HTMLCanvasElement || t instanceof ImageBitmap) return void 0 === w && (w = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), i = i ? document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") : w, e = e ? la.floorPowerOfTwo : Math.floor, i.width = e(r * t.width), i.height = e(r * t.height), i.getContext("2d").drawImage(t, 0, 0, i.width, i.height), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + i.width + "x" + i.height + ")."), i;
                "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ").")
            }
            return t
        }

        function l(t) {
            return la.isPowerOfTwo(t.width) && la.isPowerOfTwo(t.height)
        }

        function c(t, e) {
            return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter
        }

        function h(e, i, r, a) {
            t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log(Math.max(r, a)) * Math.LOG2E
        }

        function u(t, i) {
            if (!r.isWebGL2) return t;
            var n = t;
            return 6403 === t && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === t && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === t && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? e.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n
        }

        function p(t) {
            return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729
        }

        function d(e) {
            e = e.target, e.removeEventListener("dispose", d);
            t:{
                var i = n.get(e);
                if (e.image && i.__image__webglTextureCube) t.deleteTexture(i.__image__webglTextureCube); else {
                    if (void 0 === i.__webglInit) break t;
                    t.deleteTexture(i.__webglTexture)
                }
                n.remove(e)
            }
            e.isVideoTexture && delete b[e.id], o.memory.textures--
        }

        function f(e) {
            e = e.target, e.removeEventListener("dispose", f);
            var i = n.get(e), r = n.get(e.texture);
            if (e) {
                if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube) for (r = 0; 6 > r; r++) t.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]); else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer);
                n.remove(e.texture), n.remove(e)
            }
            o.memory.textures--
        }

        function m(t, e) {
            var r = n.get(t);
            if (t.isVideoTexture) {
                var a = t.id, s = o.render.frame;
                b[a] !== s && (b[a] = s, t.update())
            }
            if (0 < t.version && r.__version !== t.version) if (void 0 === (a = t.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else {
                if (!1 !== a.complete) return void v(r, t, e);
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete")
            }
            i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture)
        }

        function g(i, o, s) {
            s ? (t.texParameteri(i, 10242, a.convert(o.wrapS)), t.texParameteri(i, 10243, a.convert(o.wrapT)), t.texParameteri(i, 10240, a.convert(o.magFilter)), t.texParameteri(i, 10241, a.convert(o.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 1001 === o.wrapS && 1001 === o.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, p(o.magFilter)), t.texParameteri(i, 10241, p(o.minFilter)), 1003 !== o.minFilter && 1006 !== o.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(s = e.get("EXT_texture_filter_anisotropic")) || 1015 === o.type && null === e.get("OES_texture_float_linear") || 1016 === o.type && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear")) || !(1 < o.anisotropy || n.get(o).__currentAnisotropy) || (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(o.anisotropy, r.getMaxAnisotropy())), n.get(o).__currentAnisotropy = o.anisotropy)
        }

        function v(e, n, p) {
            var f = n.isDataTexture3D ? 32879 : 3553;
            void 0 === e.__webglInit && (e.__webglInit = !0, n.addEventListener("dispose", d), e.__webglTexture = t.createTexture(), o.memory.textures++), i.activeTexture(33984 + p), i.bindTexture(f, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), p = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter), p = p && !1 === l(n.image), p = s(n.image, p, !1, r.maxTextureSize);
            var m = l(p) || r.isWebGL2, v = a.convert(n.format), y = a.convert(n.type), x = u(v, y);
            g(f, n, m);
            var _ = n.mipmaps;
            if (n.isDepthTexture) {
                if (x = 6402, 1015 === n.type) {
                    if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0");
                    x = 36012
                } else r.isWebGL2 && (x = 33189);
                1026 === n.format && 6402 === x && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, y = a.convert(n.type)), 1027 === n.format && (x = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, y = a.convert(n.type))), i.texImage2D(3553, 0, x, p.width, p.height, 0, v, y, null)
            } else if (n.isDataTexture) if (0 < _.length && m) {
                for (var b = 0, w = _.length; b < w; b++) f = _[b], i.texImage2D(3553, b, x, f.width, f.height, 0, v, y, f.data);
                n.generateMipmaps = !1, e.__maxMipLevel = _.length - 1
            } else i.texImage2D(3553, 0, x, p.width, p.height, 0, v, y, p.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) {
                for (b = 0, w = _.length; b < w; b++) f = _[b], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(v) ? i.compressedTexImage2D(3553, b, x, f.width, f.height, 0, f.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, b, x, f.width, f.height, 0, v, y, f.data);
                e.__maxMipLevel = _.length - 1
            } else if (n.isDataTexture3D) i.texImage3D(32879, 0, x, p.width, p.height, p.depth, 0, v, y, p.data), e.__maxMipLevel = 0; else if (0 < _.length && m) {
                for (b = 0, w = _.length; b < w; b++) f = _[b], i.texImage2D(3553, b, x, v, y, f);
                n.generateMipmaps = !1, e.__maxMipLevel = _.length - 1
            } else i.texImage2D(3553, 0, x, v, y, p), e.__maxMipLevel = 0;
            c(n, m) && h(3553, n, p.width, p.height), e.__version = n.version, n.onUpdate && n.onUpdate(n)
        }

        function y(e, r, o, s) {
            var l = a.convert(r.texture.format), c = a.convert(r.texture.type), h = u(l, c);
            i.texImage2D(s, 0, h, r.width, r.height, 0, l, c, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, o, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null)
        }

        function x(e, i, n) {
            if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) n ? (n = _(i), t.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : t.renderbufferStorage(36161, 33189, i.width, i.height), t.framebufferRenderbuffer(36160, 36096, 36161, e); else if (i.depthBuffer && i.stencilBuffer) n ? (n = _(i), t.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : t.renderbufferStorage(36161, 34041, i.width, i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e); else {
                e = a.convert(i.texture.format);
                var r = a.convert(i.texture.type);
                e = u(e, r), n ? (n = _(i), t.renderbufferStorageMultisample(36161, n, e, i.width, i.height)) : t.renderbufferStorage(36161, e, i.width, i.height)
            }
            t.bindRenderbuffer(36161, null)
        }

        function _(t) {
            return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0
        }

        var b = {}, w;
        this.setTexture2D = m, this.setTexture3D = function (t, e) {
            var r = n.get(t);
            0 < t.version && r.__version !== t.version ? v(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture))
        }, this.setTextureCube = function (e, p) {
            var f = n.get(e);
            if (6 === e.image.length) if (0 < e.version && f.__version !== e.version) {
                f.__image__webglTextureCube || (e.addEventListener("dispose", d), f.__image__webglTextureCube = t.createTexture(), o.memory.textures++), i.activeTexture(33984 + p), i.bindTexture(34067, f.__image__webglTextureCube), t.pixelStorei(37440, e.flipY), p = e && e.isCompressedTexture;
                for (var m = e.image[0] && e.image[0].isDataTexture, v = [], y = 0; 6 > y; y++) v[y] = p || m ? m ? e.image[y].image : e.image[y] : s(e.image[y], !1, !0, r.maxCubemapSize);
                var x = v[0], _ = l(x) || r.isWebGL2, b = a.convert(e.format), w = a.convert(e.type), M = u(b, w);
                for (g(34067, e, _), y = 0; 6 > y; y++) if (p) for (var T, S = v[y].mipmaps, E = 0, A = S.length; E < A; E++) T = S[E], 1023 !== e.format && 1022 !== e.format ? -1 < i.getCompressedTextureFormats().indexOf(b) ? i.compressedTexImage2D(34069 + y, E, M, T.width, T.height, 0, T.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + y, E, M, T.width, T.height, 0, b, w, T.data); else m ? i.texImage2D(34069 + y, 0, M, v[y].width, v[y].height, 0, b, w, v[y].data) : i.texImage2D(34069 + y, 0, M, b, w, v[y]);
                f.__maxMipLevel = p ? S.length - 1 : 0, c(e, _) && h(34067, e, x.width, x.height), f.__version = e.version, e.onUpdate && e.onUpdate(e)
            } else i.activeTexture(33984 + p), i.bindTexture(34067, f.__image__webglTextureCube)
        }, this.setTextureCubeDynamic = function (t, e) {
            i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture)
        }, this.setupRenderTarget = function (e) {
            var s = n.get(e), p = n.get(e.texture);
            e.addEventListener("dispose", f), p.__webglTexture = t.createTexture(), o.memory.textures++;
            var d = !0 === e.isWebGLRenderTargetCube, v = !0 === e.isWebGLMultisampleRenderTarget,
                b = l(e) || r.isWebGL2;
            if (d) for (s.__webglFramebuffer = [], v = 0; 6 > v; v++) s.__webglFramebuffer[v] = t.createFramebuffer(); else if (s.__webglFramebuffer = t.createFramebuffer(), v) if (r.isWebGL2) {
                s.__webglMultisampledFramebuffer = t.createFramebuffer(), s.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, s.__webglColorRenderbuffer), v = a.convert(e.texture.format);
                var w = a.convert(e.texture.type);
                v = u(v, w), w = _(e), t.renderbufferStorageMultisample(36161, w, v, e.width, e.height), t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(), x(s.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null)
            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.");
            if (d) {
                for (i.bindTexture(34067, p.__webglTexture), g(34067, e.texture, b), v = 0; 6 > v; v++) y(s.__webglFramebuffer[v], e, 36064, 34069 + v);
                c(e.texture, b) && h(34067, e.texture, e.width, e.height), i.bindTexture(34067, null)
            } else i.bindTexture(3553, p.__webglTexture), g(3553, e.texture, b), y(s.__webglFramebuffer, e, 36064, 3553), c(e.texture, b) && h(3553, e.texture, e.width, e.height), i.bindTexture(3553, null);
            if (e.depthBuffer) {
                if (s = n.get(e), p = !0 === e.isWebGLRenderTargetCube, e.depthTexture) {
                    if (p) throw Error("target.depthTexture not supported in Cube render targets");
                    if (e && e.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported");
                    if (t.bindFramebuffer(36160, s.__webglFramebuffer), !e.depthTexture || !e.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
                    if (n.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), m(e.depthTexture, 0), s = n.get(e.depthTexture).__webglTexture, 1026 === e.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, s, 0); else {
                        if (1027 !== e.depthTexture.format) throw Error("Unknown depthTexture format");
                        t.framebufferTexture2D(36160, 33306, 3553, s, 0)
                    }
                } else if (p) for (s.__webglDepthbuffer = [], p = 0; 6 > p; p++) t.bindFramebuffer(36160, s.__webglFramebuffer[p]), s.__webglDepthbuffer[p] = t.createRenderbuffer(), x(s.__webglDepthbuffer[p], e); else t.bindFramebuffer(36160, s.__webglFramebuffer), s.__webglDepthbuffer = t.createRenderbuffer(), x(s.__webglDepthbuffer, e);
                t.bindFramebuffer(36160, null)
            }
        }, this.updateRenderTargetMipmap = function (t) {
            var e = t.texture, a = l(t) || r.isWebGL2;
            if (c(e, a)) {
                a = t.isWebGLRenderTargetCube ? 34067 : 3553;
                var o = n.get(e).__webglTexture;
                i.bindTexture(a, o), h(a, e, t.width, t.height), i.bindTexture(a, null)
            }
        }, this.updateMultisampleRenderTarget = function (e) {
            if (e.isWebGLMultisampleRenderTarget) if (r.isWebGL2) {
                var i = n.get(e);
                t.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, i.__webglFramebuffer), i = e.width;
                var a = e.height, o = 16384;
                e.depthBuffer && (o |= 256), e.stencilBuffer && (o |= 1024), t.blitFramebuffer(0, 0, i, a, 0, 0, i, a, o, 9728)
            } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.")
        }
    }

    function xe(t, e, i) {
        return {
            convert: function (t) {
                if (1e3 === t) return 10497;
                if (1001 === t) return 33071;
                if (1002 === t) return 33648;
                if (1003 === t) return 9728;
                if (1004 === t) return 9984;
                if (1005 === t) return 9986;
                if (1006 === t) return 9729;
                if (1007 === t) return 9985;
                if (1008 === t) return 9987;
                if (1009 === t) return 5121;
                if (1017 === t) return 32819;
                if (1018 === t) return 32820;
                if (1019 === t) return 33635;
                if (1010 === t) return 5120;
                if (1011 === t) return 5122;
                if (1012 === t) return 5123;
                if (1013 === t) return 5124;
                if (1014 === t) return 5125;
                if (1015 === t) return 5126;
                if (1016 === t) {
                    if (i.isWebGL2) return 5131;
                    var n = e.get("OES_texture_half_float");
                    if (null !== n) return n.HALF_FLOAT_OES
                }
                if (1021 === t) return 6406;
                if (1022 === t) return 6407;
                if (1023 === t) return 6408;
                if (1024 === t) return 6409;
                if (1025 === t) return 6410;
                if (1026 === t) return 6402;
                if (1027 === t) return 34041;
                if (1028 === t) return 6403;
                if (100 === t) return 32774;
                if (101 === t) return 32778;
                if (102 === t) return 32779;
                if (200 === t) return 0;
                if (201 === t) return 1;
                if (202 === t) return 768;
                if (203 === t) return 769;
                if (204 === t) return 770;
                if (205 === t) return 771;
                if (206 === t) return 772;
                if (207 === t) return 773;
                if (208 === t) return 774;
                if (209 === t) return 775;
                if (210 === t) return 776;
                if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) {
                    if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT;
                    if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                    if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                    if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT
                }
                if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) {
                    if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                    if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                    if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                    if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
                }
                if (36196 === t && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL;
                if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t;
                if (103 === t || 104 === t) {
                    if (i.isWebGL2) {
                        if (103 === t) return 32775;
                        if (104 === t) return 32776
                    }
                    if (null !== (n = e.get("EXT_blend_minmax"))) {
                        if (103 === t) return n.MIN_EXT;
                        if (104 === t) return n.MAX_EXT
                    }
                }
                if (1020 === t) {
                    if (i.isWebGL2) return 34042;
                    if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL
                }
                return 0
            }
        }
    }

    function _e() {
        S.call(this), this.type = "Group"
    }

    function be() {
        S.call(this), this.type = "Camera", this.matrixWorldInverse = new n, this.projectionMatrix = new n, this.projectionMatrixInverse = new n
    }

    function we(t, e, i, n) {
        be.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }

    function Me(t) {
        we.call(this), this.cameras = t || []
    }

    function Te(t, e, i) {
        Oa.setFromMatrixPosition(e.matrixWorld), Da.setFromMatrixPosition(i.matrixWorld);
        var n = Oa.distanceTo(Da), r = e.projectionMatrix.elements, a = i.projectionMatrix.elements,
            o = r[14] / (r[10] - 1);
        i = r[14] / (r[10] + 1);
        var s = (r[9] + 1) / r[5], l = (r[9] - 1) / r[5], c = (r[8] - 1) / r[0], h = (a[8] + 1) / a[0];
        r = o * c, a = o * h, h = n / (-c + h), c = h * -c, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(c), t.translateZ(h), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = o + h, o = i + h, t.projectionMatrix.makePerspective(r - c, a + (n - c), s * i / o * e, l * i / o * e, e, o)
    }

    function Se(t) {
        function e() {
            return null !== s && !0 === s.isPresenting
        }

        function i() {
            if (e()) {
                var i = s.getEyeParameters("left"), n = i.renderWidth * f;
                i = i.renderHeight * f, T = t.getPixelRatio(), M = t.getSize(), t.setDrawingBufferSize(2 * n, i, 1), E.start()
            } else o.enabled && t.setDrawingBufferSize(M.width, M.height, T), E.stop()
        }

        var o = this, s = null, c = null, h = null, u = [], p = new n, d = new n, f = 1, m = "stage";
        "undefined" != typeof window && "VRFrameData" in window && (c = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", i, !1));
        var g = new n, v = new r, y = new a, x = new we;
        x.bounds = new l(0, 0, .5, 1), x.layers.enable(1);
        var b = new we;
        b.bounds = new l(.5, 0, .5, 1), b.layers.enable(2);
        var w = new Me([x, b]);
        w.layers.enable(1), w.layers.enable(2);
        var M, T, S = [];
        this.enabled = !1, this.getController = function (t) {
            var e = u[t];
            return void 0 === e && (e = new _e, e.matrixAutoUpdate = !1, e.visible = !1, u[t] = e), e
        }, this.getDevice = function () {
            return s
        }, this.setDevice = function (t) {
            void 0 !== t && (s = t), E.setContext(t)
        }, this.setFramebufferScaleFactor = function (t) {
            f = t
        }, this.setFrameOfReferenceType = function (t) {
            m = t
        }, this.setPoseTarget = function (t) {
            void 0 !== t && (h = t)
        }, this.getCamera = function (t) {
            var e = "stage" === m ? 1.6 : 0;
            if (null === s) return t.position.set(0, e, 0), t;
            if (s.depthNear = t.near, s.depthFar = t.far, s.getFrameData(c), "stage" === m) {
                var i = s.stageParameters;
                i ? p.fromArray(i.sittingToStandingTransform) : p.makeTranslation(0, e, 0)
            }
            if (e = c.pose, i = null !== h ? h : t, i.matrix.copy(p), i.matrix.decompose(i.position, i.quaternion, i.scale), null !== e.orientation && (v.fromArray(e.orientation), i.quaternion.multiply(v)), null !== e.position && (v.setFromRotationMatrix(p), y.fromArray(e.position), y.applyQuaternion(v), i.position.add(y)), i.updateMatrixWorld(), !1 === s.isPresenting) return t;
            x.near = t.near, b.near = t.near, x.far = t.far, b.far = t.far, x.matrixWorldInverse.fromArray(c.leftViewMatrix), b.matrixWorldInverse.fromArray(c.rightViewMatrix), d.getInverse(p), "stage" === m && (x.matrixWorldInverse.multiply(d), b.matrixWorldInverse.multiply(d)), t = i.parent, null !== t && (g.getInverse(t.matrixWorld), x.matrixWorldInverse.multiply(g), b.matrixWorldInverse.multiply(g)), x.matrixWorld.getInverse(x.matrixWorldInverse), b.matrixWorld.getInverse(b.matrixWorldInverse), x.projectionMatrix.fromArray(c.leftProjectionMatrix), b.projectionMatrix.fromArray(c.rightProjectionMatrix), Te(w, x, b), t = s.getLayers(), t.length && (t = t[0], null !== t.leftBounds && 4 === t.leftBounds.length && x.bounds.fromArray(t.leftBounds), null !== t.rightBounds && 4 === t.rightBounds.length && b.bounds.fromArray(t.rightBounds));
            t:for (t = 0; t < u.length; t++) {
                e = u[t];
                e:{
                    i = t;
                    for (var n = navigator.getGamepads && navigator.getGamepads(), r = 0, a = 0, o = n.length; r < o; r++) {
                        var l = n[r];
                        if (l && ("Daydream Controller" === l.id || "Gear VR Controller" === l.id || "Oculus Go Controller" === l.id || "OpenVR Gamepad" === l.id || l.id.startsWith("Oculus Touch") || l.id.startsWith("Spatial Controller"))) {
                            if (a === i) {
                                i = l;
                                break e
                            }
                            a++
                        }
                    }
                    i = void 0
                }
                if (void 0 !== i && void 0 !== i.pose) {
                    if (null === i.pose) break t;
                    n = i.pose, !1 === n.hasPosition && e.position.set(.2, -.6, -.05), null !== n.position && e.position.fromArray(n.position), null !== n.orientation && e.quaternion.fromArray(n.orientation), e.matrix.compose(e.position, e.quaternion, e.scale), e.matrix.premultiply(p), e.matrix.decompose(e.position, e.quaternion, e.scale), e.matrixWorldNeedsUpdate = !0, e.visible = !0, n = "Daydream Controller" === i.id ? 0 : 1, S[t] !== i.buttons[n].pressed && (S[t] = i.buttons[n].pressed, !0 === S[t] ? e.dispatchEvent({type: "selectstart"}) : (e.dispatchEvent({type: "selectend"}), e.dispatchEvent({type: "select"})))
                } else e.visible = !1
            }
            return w
        }, this.getStandingMatrix = function () {
            return p
        }, this.isPresenting = e;
        var E = new _;
        this.setAnimationLoop = function (t) {
            E.setAnimationLoop(t)
        }, this.submitFrame = function () {
            e() && s.submitFrame()
        }, this.dispose = function () {
            "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", i)
        }
    }

    function Ee(t) {
        function e() {
            return null !== s && null !== h
        }

        function i(t) {
            var e = d[f.indexOf(t.inputSource)];
            e && e.dispatchEvent({type: t.type})
        }

        function n() {
            t.setFramebuffer(null), x.stop()
        }

        function r(t, e) {
            null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld)
        }

        var a = t.context, o = null, s = null, c = 1, h = null, u = "stage", p = null, d = [], f = [], m = new we;
        m.layers.enable(1), m.viewport = new l;
        var g = new we;
        g.layers.enable(2), g.viewport = new l;
        var v = new Me([m, g]);
        v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (t) {
            var e = d[t];
            return void 0 === e && (e = new _e, e.matrixAutoUpdate = !1, e.visible = !1, d[t] = e), e
        }, this.getDevice = function () {
            return o
        }, this.setDevice = function (t) {
            void 0 !== t && (o = t), t instanceof XRDevice && a.setCompatibleXRDevice(t)
        }, this.setFramebufferScaleFactor = function (t) {
            c = t
        }, this.setFrameOfReferenceType = function (t) {
            u = t
        }, this.setSession = function (e) {
            null !== (s = e) && (s.addEventListener("select", i), s.addEventListener("selectstart", i), s.addEventListener("selectend", i), s.addEventListener("end", n), s.baseLayer = new XRWebGLLayer(s, a, {framebufferScaleFactor: c}), s.requestFrameOfReference(u).then(function (e) {
                h = e, t.setFramebuffer(s.baseLayer.framebuffer), x.setContext(s), x.start()
            }), f = s.getInputSources(), s.addEventListener("inputsourceschange", function () {
                f = s.getInputSources(), console.log(f);
                for (var t = 0; t < d.length; t++) d[t].userData.inputSource = f[t]
            }))
        }, this.getCamera = function (t) {
            if (e()) {
                var i = t.parent, n = v.cameras;
                r(v, i);
                for (var a = 0; a < n.length; a++) r(n[a], i);
                for (t.matrixWorld.copy(v.matrixWorld), t = t.children, a = 0, i = t.length; a < i; a++) t[a].updateMatrixWorld(!0);
                return Te(v, m, g), v
            }
            return t
        }, this.isPresenting = e;
        var y = null, x = new _;
        x.setAnimationLoop(function (t, e) {
            if (null !== (p = e.getDevicePose(h))) for (var i = s.baseLayer, n = e.views, r = 0; r < n.length; r++) {
                var a = n[r], o = i.getViewport(a), l = p.getViewMatrix(a), c = v.cameras[r];
                c.matrix.fromArray(l).getInverse(c.matrix), c.projectionMatrix.fromArray(a.projectionMatrix), c.viewport.set(o.x, o.y, o.width, o.height), 0 === r && v.matrix.copy(c.matrix)
            }
            for (r = 0; r < d.length; r++) i = d[r], (n = f[r]) && null !== (n = e.getInputPose(n, h)) ? ("targetRay" in n ? i.matrix.elements = n.targetRay.transformMatrix : "pointerMatrix" in n && (i.matrix.elements = n.pointerMatrix), i.matrix.decompose(i.position, i.rotation, i.scale), i.visible = !0) : i.visible = !1;
            y && y(t)
        }), this.setAnimationLoop = function (t) {
            y = t
        }, this.dispose = function () {
        }, this.getStandingMatrix = function () {
            return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new THREE.Matrix4
        }, this.submitFrame = function () {
        }
    }

    function Ae(t) {
        function e() {
            xt = new et(yt), _t = new K(yt, xt, t), _t.isWebGL2 || (xt.get("WEBGL_depth_texture"), xt.get("OES_texture_float"), xt.get("OES_texture_half_float"), xt.get("OES_texture_half_float_linear"), xt.get("OES_standard_derivatives"), xt.get("OES_element_index_uint"), xt.get("ANGLE_instanced_arrays")), xt.get("OES_texture_float_linear"), Nt = new xe(yt, xt, _t), bt = new ve(yt, xt, Nt, _t), bt.scissor(q.copy(ht).multiplyScalar(lt)), bt.viewport(W.copy(ct).multiplyScalar(lt)), wt = new rt(yt), Mt = new ae, Tt = new ye(yt, xt, bt, Mt, _t, Nt, wt), St = new b(yt), Et = new it(yt, St, wt), At = new st(Et, wt), Ot = new ot(yt), Pt = new re(N, xt, _t), Lt = new ce, Ct = new de, Rt = new Z(N, bt, At, C), Dt = new Q(yt, xt, wt, _t), It = new nt(yt, xt, wt, _t), wt.programs = Pt.programs, N.context = yt, N.capabilities = _t, N.extensions = xt, N.properties = Mt, N.renderLists = Lt, N.state = bt, N.info = wt
        }

        function i(t) {
            t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), z = !0
        }

        function r() {
            console.log("THREE.WebGLRenderer: Context Restored."), z = !1, e()
        }

        function o(t) {
            t = t.target, t.removeEventListener("dispose", o), s(t), Mt.remove(t)
        }

        function s(t) {
            var e = Mt.get(t).program;
            t.program = void 0, void 0 !== e && Pt.releaseProgram(e)
        }

        function c(t, e) {
            t.render(function (t) {
                N.renderBufferImmediate(t, e)
            })
        }

        function h(t, e, i, n) {
            if (!1 !== t.visible) {
                if (t.layers.test(e.layers)) if (t.isGroup) i = t.renderOrder; else if (t.isLight) I.pushLight(t), t.castShadow && I.pushShadow(t); else if (t.isSprite) {
                    if (!t.frustumCulled || pt.intersectsSprite(t)) {
                        n && vt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(gt);
                        var r = At.update(t), a = t.material;
                        D.push(t, r, a, i, vt.z, null)
                    }
                } else if (t.isImmediateRenderObject) n && vt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(gt), D.push(t, null, t.material, i, vt.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || pt.intersectsObject(t))) if (n && vt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(gt), r = At.update(t), a = t.material, Array.isArray(a)) for (var o = r.groups, s = 0, l = o.length; s < l; s++) {
                    var c = o[s], u = a[c.materialIndex];
                    u && u.visible && D.push(t, r, u, i, vt.z, c)
                } else a.visible && D.push(t, r, a, i, vt.z, null);
                for (t = t.children, s = 0, l = t.length; s < l; s++) h(t[s], e, i, n)
            }
        }

        function u(t, e, i, n) {
            for (var r = 0, a = t.length; r < a; r++) {
                var o = t[r], s = o.object, l = o.geometry, c = void 0 === n ? o.material : n;
                if (o = o.group, i.isArrayCamera) {
                    V = i;
                    for (var h = i.cameras, u = 0, p = h.length; u < p; u++) {
                        var f = h[u];
                        if (s.layers.test(f.layers)) {
                            if ("viewport" in f) bt.viewport(W.copy(f.viewport)); else {
                                var m = f.bounds;
                                bt.viewport(W.set(m.x * J, m.y * at, m.z * J, m.w * at).multiplyScalar(lt))
                            }
                            I.setupLights(f), d(s, e, f, l, c, o)
                        }
                    }
                } else V = null, d(s, e, i, l, c, o)
            }
        }

        function d(t, e, i, n, r, a) {
            if (t.onBeforeRender(N, e, i, n, r, a), I = Ct.get(e, V || i), t.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) {
                bt.setMaterial(r);
                var o = m(i, e.fog, r, t);
                U = M = null, G = !1, c(t, o)
            } else N.renderBufferDirect(i, e.fog, n, r, t, a);
            t.onAfterRender(N, e, i, n, r, a), I = Ct.get(e, V || i)
        }

        function f(t, e, i) {
            var n = Mt.get(t), r = I.state.lights, a = n.lightsHash, l = r.state.hash;
            i = Pt.getParameters(t, r.state, I.state.shadowsArray, e, dt.numPlanes, dt.numIntersection, i);
            var c = Pt.getProgramCode(t, i), h = n.program, u = !0;
            if (void 0 === h) t.addEventListener("dispose", o); else if (h.code !== c) s(t); else {
                if (a.stateID !== l.stateID || a.directionalLength !== l.directionalLength || a.pointLength !== l.pointLength || a.spotLength !== l.spotLength || a.rectAreaLength !== l.rectAreaLength || a.hemiLength !== l.hemiLength || a.shadowsLength !== l.shadowsLength) a.stateID = l.stateID, a.directionalLength = l.directionalLength, a.pointLength = l.pointLength, a.spotLength = l.spotLength, a.rectAreaLength = l.rectAreaLength, a.hemiLength = l.hemiLength, a.shadowsLength = l.shadowsLength; else if (void 0 !== i.shaderID) return;
                u = !1
            }
            if (u && (i.shaderID ? (c = ga[i.shaderID], n.shader = {
                name: t.type,
                uniforms: v(c.uniforms),
                vertexShader: c.vertexShader,
                fragmentShader: c.fragmentShader
            }) : n.shader = {
                name: t.type,
                uniforms: t.uniforms,
                vertexShader: t.vertexShader,
                fragmentShader: t.fragmentShader
            }, t.onBeforeCompile(n.shader, N), c = Pt.getProgramCode(t, i), h = Pt.acquireProgram(t, n.shader, i, c), n.program = h, t.program = h), i = h.getAttributes(), t.morphTargets) for (c = t.numSupportedMorphTargets = 0; c < N.maxMorphTargets; c++) 0 <= i["morphTarget" + c] && t.numSupportedMorphTargets++;
            if (t.morphNormals) for (c = t.numSupportedMorphNormals = 0; c < N.maxMorphNormals; c++) 0 <= i["morphNormal" + c] && t.numSupportedMorphNormals++;
            i = n.shader.uniforms, (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = dt.numPlanes, n.numIntersection = dt.numIntersection, i.clippingPlanes = dt.uniform), n.fog = e, void 0 === a && (n.lightsHash = a = {}), a.stateID = l.stateID, a.directionalLength = l.directionalLength, a.pointLength = l.pointLength, a.spotLength = l.spotLength, a.rectAreaLength = l.rectAreaLength, a.hemiLength = l.hemiLength, a.shadowsLength = l.shadowsLength, t.lights && (i.ambientLightColor.value = r.state.ambient, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), t = n.program.getUniforms(), t = jt.seqWithValue(t.seq, i), n.uniformsList = t
        }

        function m(t, e, i, n) {
            Y = 0;
            var r = Mt.get(i), a = r.lightsHash, o = I.state.lights.state.hash;
            ft && (mt || t !== j) && dt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, t === j && i.id === H), !1 === i.needsUpdate && (void 0 === r.program ? i.needsUpdate = !0 : i.fog && r.fog !== e ? i.needsUpdate = !0 : !i.lights || a.stateID === o.stateID && a.directionalLength === o.directionalLength && a.pointLength === o.pointLength && a.spotLength === o.spotLength && a.rectAreaLength === o.rectAreaLength && a.hemiLength === o.hemiLength && a.shadowsLength === o.shadowsLength ? void 0 === r.numClippingPlanes || r.numClippingPlanes === dt.numPlanes && r.numIntersection === dt.numIntersection || (i.needsUpdate = !0) : i.needsUpdate = !0), i.needsUpdate && (f(i, e, n), i.needsUpdate = !1);
            var s = !1, l = !1, c = !1;
            a = r.program, o = a.getUniforms();
            var h = r.shader.uniforms;
            if (bt.useProgram(a.program) && (c = l = s = !0), i.id !== H && (H = i.id, l = !0), (s || j !== t) && (o.setValue(yt, "projectionMatrix", t.projectionMatrix), _t.logarithmicDepthBuffer && o.setValue(yt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), j !== t && (j = t, c = l = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && void 0 !== (s = o.map.cameraPosition) && s.setValue(yt, vt.setFromMatrixPosition(t.matrixWorld)), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && o.setValue(yt, "viewMatrix", t.matrixWorldInverse)), i.skinning && (o.setOptional(yt, n, "bindMatrix"), o.setOptional(yt, n, "bindMatrixInverse"), t = n.skeleton)) if (s = t.bones, _t.floatVertexTextures) {
                if (void 0 === t.boneTexture) {
                    s = Math.sqrt(4 * s.length), s = la.ceilPowerOfTwo(s), s = Math.max(s, 4);
                    var u = new Float32Array(s * s * 4);
                    u.set(t.boneMatrices);
                    var d = new p(u, s, s, 1023, 1015);
                    d.needsUpdate = !0, t.boneMatrices = u, t.boneTexture = d, t.boneTextureSize = s
                }
                o.setValue(yt, "boneTexture", t.boneTexture), o.setValue(yt, "boneTextureSize", t.boneTextureSize)
            } else o.setOptional(yt, t, "boneMatrices");
            return l && (o.setValue(yt, "toneMappingExposure", N.toneMappingExposure), o.setValue(yt, "toneMappingWhitePoint", N.toneMappingWhitePoint), i.lights && (l = c, h.ambientLightColor.needsUpdate = l, h.directionalLights.needsUpdate = l, h.pointLights.needsUpdate = l, h.spotLights.needsUpdate = l, h.rectAreaLights.needsUpdate = l, h.hemisphereLights.needsUpdate = l), e && i.fog && (h.fogColor.value = e.color, e.isFog ? (h.fogNear.value = e.near, h.fogFar.value = e.far) : e.isFogExp2 && (h.fogDensity.value = e.density)), i.isMeshBasicMaterial ? y(h, i) : i.isMeshLambertMaterial ? (y(h, i), i.emissiveMap && (h.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (y(h, i), i.isMeshToonMaterial ? (x(h, i), i.gradientMap && (h.gradientMap.value = i.gradientMap)) : x(h, i)) : i.isMeshStandardMaterial ? (y(h, i), i.isMeshPhysicalMaterial ? (w(h, i), h.reflectivity.value = i.reflectivity, h.clearCoat.value = i.clearCoat, h.clearCoatRoughness.value = i.clearCoatRoughness) : w(h, i)) : i.isMeshMatcapMaterial ? (y(h, i), i.matcap && (h.matcap.value = i.matcap), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (y(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (y(h, i), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias), h.referencePosition.value.copy(i.referencePosition), h.nearDistance.value = i.nearDistance, h.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (y(h, i), i.bumpMap && (h.bumpMap.value = i.bumpMap, h.bumpScale.value = i.bumpScale, 1 === i.side && (h.bumpScale.value *= -1)), i.normalMap && (h.normalMap.value = i.normalMap, h.normalScale.value.copy(i.normalScale), 1 === i.side && h.normalScale.value.negate()), i.displacementMap && (h.displacementMap.value = i.displacementMap, h.displacementScale.value = i.displacementScale, h.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (h.diffuse.value = i.color, h.opacity.value = i.opacity, i.isLineDashedMaterial && (h.dashSize.value = i.dashSize, h.totalSize.value = i.dashSize + i.gapSize, h.scale.value = i.scale)) : i.isPointsMaterial ? (h.diffuse.value = i.color, h.opacity.value = i.opacity, h.size.value = i.size * lt, h.scale.value = .5 * at, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (h.diffuse.value = i.color, h.opacity.value = i.opacity, h.rotation.value = i.rotation, h.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), h.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (h.color.value = i.color, h.opacity.value = i.opacity), void 0 !== h.ltc_1 && (h.ltc_1.value = ma.LTC_1), void 0 !== h.ltc_2 && (h.ltc_2.value = ma.LTC_2), jt.upload(yt, r.uniformsList, h, N)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (jt.upload(yt, r.uniformsList, h, N), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && o.setValue(yt, "center", n.center), o.setValue(yt, "modelViewMatrix", n.modelViewMatrix), o.setValue(yt, "normalMatrix", n.normalMatrix), o.setValue(yt, "modelMatrix", n.matrixWorld), a
        }

        function y(t, e) {
            if (t.opacity.value = e.opacity, e.color && (t.diffuse.value = e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = Mt.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map) var i = e.map; else e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap);
            void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix))
        }

        function x(t, e) {
            t.specular.value = e.specular, t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias)
        }

        function w(t, e) {
            t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap),
            e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity)
        }

        var M;
        console.log("THREE.WebGLRenderer", "101"), t = t || {};
        var T = void 0 !== t.canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"),
            S = void 0 !== t.context ? t.context : null, E = void 0 !== t.alpha && t.alpha,
            A = void 0 === t.depth || t.depth, P = void 0 === t.stencil || t.stencil,
            L = void 0 !== t.antialias && t.antialias, C = void 0 === t.premultipliedAlpha || t.premultipliedAlpha,
            R = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer,
            O = void 0 !== t.powerPreference ? t.powerPreference : "default", D = null, I = null;
        this.domElement = T, this.context = null, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4;
        var N = this, z = !1, k = null, B = null, F = null, H = -1, U = M = null, G = !1, j = null, V = null, W = new l,
            q = new l, X = null, Y = 0, J = T.width, at = T.height, lt = 1, ct = new l(0, 0, J, at),
            ht = new l(0, 0, J, at), ut = !1, pt = new g, dt = new tt, ft = !1, mt = !1, gt = new n, vt = new a;
        try {
            E = {
                alpha: E,
                depth: A,
                stencil: P,
                antialias: L,
                premultipliedAlpha: C,
                preserveDrawingBuffer: R,
                powerPreference: O
            }, T.addEventListener("webglcontextlost", i, !1), T.addEventListener("webglcontextrestored", r, !1);
            var yt = S || T.getContext("webgl", E) || T.getContext("experimental-webgl", E);
            if (null === yt) {
                if (null !== T.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes.");
                throw Error("Error creating WebGL context.")
            }
            void 0 === yt.getShaderPrecisionFormat && (yt.getShaderPrecisionFormat = function () {
                return {rangeMin: 1, rangeMax: 1, precision: 1}
            })
        } catch (t) {
            console.error("THREE.WebGLRenderer: " + t.message)
        }
        var xt, _t, bt, wt, Mt, Tt, St, Et, At, Pt, Lt, Ct, Rt, Ot, Dt, It, Nt;
        e();
        var zt = null;
        "undefined" != typeof navigator && (zt = "xr" in navigator ? new Ee(N) : new Se(N)), this.vr = zt;
        var kt = new ge(N, At, _t.maxTextureSize);
        this.shadowMap = kt, this.getContext = function () {
            return yt
        }, this.getContextAttributes = function () {
            return yt.getContextAttributes()
        }, this.forceContextLoss = function () {
            var t = xt.get("WEBGL_lose_context");
            t && t.loseContext()
        }, this.forceContextRestore = function () {
            var t = xt.get("WEBGL_lose_context");
            t && t.restoreContext()
        }, this.getPixelRatio = function () {
            return lt
        }, this.setPixelRatio = function (t) {
            void 0 !== t && (lt = t, this.setSize(J, at, !1))
        }, this.getSize = function () {
            return {width: J, height: at}
        }, this.setSize = function (t, e, i) {
            zt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (J = t, at = e, T.width = t * lt, T.height = e * lt, !1 !== i && (T.style.width = t + "px", T.style.height = e + "px"), this.setViewport(0, 0, t, e))
        }, this.getDrawingBufferSize = function () {
            return {width: J * lt, height: at * lt}
        }, this.setDrawingBufferSize = function (t, e, i) {
            J = t, at = e, lt = i, T.width = t * i, T.height = e * i, this.setViewport(0, 0, t, e)
        }, this.getCurrentViewport = function () {
            return W
        }, this.setViewport = function (t, e, i, n) {
            ct.set(t, at - e - n, i, n), bt.viewport(W.copy(ct).multiplyScalar(lt))
        }, this.setScissor = function (t, e, i, n) {
            ht.set(t, at - e - n, i, n), bt.scissor(q.copy(ht).multiplyScalar(lt))
        }, this.setScissorTest = function (t) {
            bt.setScissorTest(ut = t)
        }, this.getClearColor = function () {
            return Rt.getClearColor()
        }, this.setClearColor = function () {
            Rt.setClearColor.apply(Rt, arguments)
        }, this.getClearAlpha = function () {
            return Rt.getClearAlpha()
        }, this.setClearAlpha = function () {
            Rt.setClearAlpha.apply(Rt, arguments)
        }, this.clear = function (t, e, i) {
            var n = 0;
            (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), yt.clear(n)
        }, this.clearColor = function () {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function () {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function () {
            this.clear(!1, !1, !0)
        }, this.dispose = function () {
            T.removeEventListener("webglcontextlost", i, !1), T.removeEventListener("webglcontextrestored", r, !1), Lt.dispose(), Ct.dispose(), Mt.dispose(), At.dispose(), zt.dispose(), Ft.stop()
        }, this.renderBufferImmediate = function (t, e) {
            bt.initAttributes();
            var i = Mt.get(t);
            t.hasPositions && !i.position && (i.position = yt.createBuffer()), t.hasNormals && !i.normal && (i.normal = yt.createBuffer()), t.hasUvs && !i.uv && (i.uv = yt.createBuffer()), t.hasColors && !i.color && (i.color = yt.createBuffer()), e = e.getAttributes(), t.hasPositions && (yt.bindBuffer(34962, i.position), yt.bufferData(34962, t.positionArray, 35048), bt.enableAttribute(e.position), yt.vertexAttribPointer(e.position, 3, 5126, !1, 0, 0)), t.hasNormals && (yt.bindBuffer(34962, i.normal), yt.bufferData(34962, t.normalArray, 35048), bt.enableAttribute(e.normal), yt.vertexAttribPointer(e.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (yt.bindBuffer(34962, i.uv), yt.bufferData(34962, t.uvArray, 35048), bt.enableAttribute(e.uv), yt.vertexAttribPointer(e.uv, 2, 5126, !1, 0, 0)), t.hasColors && (yt.bindBuffer(34962, i.color), yt.bufferData(34962, t.colorArray, 35048), bt.enableAttribute(e.color), yt.vertexAttribPointer(e.color, 3, 5126, !1, 0, 0)), bt.disableUnusedAttributes(), yt.drawArrays(4, 0, t.count), t.count = 0
        }, this.renderBufferDirect = function (t, e, i, n, r, a) {
            var o = r.isMesh && 0 > r.normalMatrix.determinant();
            bt.setMaterial(n, o);
            var s = m(t, e, n, r), l = !1;
            M === i.id && U === s.id && G === (!0 === n.wireframe) || (M = i.id, U = s.id, G = !0 === n.wireframe, l = !0), r.morphTargetInfluences && (Ot.update(r, i, n, s), l = !0), o = i.index;
            var c = i.attributes.position;
            if (e = 1, !0 === n.wireframe && (o = Et.getWireframeAttribute(i), e = 2), t = Dt, null !== o) {
                var h = St.get(o);
                t = It, t.setIndex(h)
            }
            if (l) {
                if (i && i.isInstancedBufferGeometry & !_t.isWebGL2 && null === xt.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else {
                    bt.initAttributes(), l = i.attributes, s = s.getAttributes();
                    var u = n.defaultAttributeValues;
                    for (w in s) {
                        var p = s[w];
                        if (0 <= p) {
                            var d = l[w];
                            if (void 0 !== d) {
                                var f = d.normalized, g = d.itemSize, v = St.get(d);
                                if (void 0 !== v) {
                                    var y = v.buffer, x = v.type;
                                    if (v = v.bytesPerElement, d.isInterleavedBufferAttribute) {
                                        var _ = d.data, b = _.stride;
                                        d = d.offset, _ && _.isInstancedInterleavedBuffer ? (bt.enableAttributeAndDivisor(p, _.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = _.meshPerAttribute * _.count)) : bt.enableAttribute(p), yt.bindBuffer(34962, y), yt.vertexAttribPointer(p, g, x, f, b * v, d * v)
                                    } else d.isInstancedBufferAttribute ? (bt.enableAttributeAndDivisor(p, d.meshPerAttribute), void 0 === i.maxInstancedCount && (i.maxInstancedCount = d.meshPerAttribute * d.count)) : bt.enableAttribute(p), yt.bindBuffer(34962, y), yt.vertexAttribPointer(p, g, x, f, 0, 0)
                                }
                            } else if (void 0 !== u && void 0 !== (f = u[w])) switch (f.length) {
                                case 2:
                                    yt.vertexAttrib2fv(p, f);
                                    break;
                                case 3:
                                    yt.vertexAttrib3fv(p, f);
                                    break;
                                case 4:
                                    yt.vertexAttrib4fv(p, f);
                                    break;
                                default:
                                    yt.vertexAttrib1fv(p, f)
                            }
                        }
                    }
                    bt.disableUnusedAttributes()
                }
                null !== o && yt.bindBuffer(34963, h.buffer)
            }
            h = 1 / 0, null !== o ? h = o.count : void 0 !== c && (h = c.count), o = i.drawRange.start * e, c = null !== a ? a.start * e : 0;
            var w = Math.max(o, c);
            if (0 !== (a = Math.max(0, Math.min(h, o + i.drawRange.count * e, c + (null !== a ? a.count * e : 1 / 0)) - 1 - w + 1))) {
                if (r.isMesh) if (!0 === n.wireframe) bt.setLineWidth(n.wireframeLinewidth * (null === B ? lt : 1)), t.setMode(1); else switch (r.drawMode) {
                    case 0:
                        t.setMode(4);
                        break;
                    case 1:
                        t.setMode(5);
                        break;
                    case 2:
                        t.setMode(6)
                } else r.isLine ? (n = n.linewidth, void 0 === n && (n = 1), bt.setLineWidth(n * (null === B ? lt : 1)), r.isLineSegments ? t.setMode(1) : r.isLineLoop ? t.setMode(2) : t.setMode(3)) : r.isPoints ? t.setMode(0) : r.isSprite && t.setMode(4);
                i && i.isInstancedBufferGeometry ? 0 < i.maxInstancedCount && t.renderInstances(i, w, a) : t.render(w, a)
            }
        }, this.compile = function (t, e) {
            I = Ct.get(t, e), I.init(), t.traverse(function (t) {
                t.isLight && (I.pushLight(t), t.castShadow && I.pushShadow(t))
            }), I.setupLights(e), t.traverse(function (e) {
                if (e.material) if (Array.isArray(e.material)) for (var i = 0; i < e.material.length; i++) f(e.material[i], t.fog, e); else f(e.material, t.fog, e)
            })
        };
        var Bt = null, Ft = new _;
        Ft.setAnimationLoop(function (t) {
            zt.isPresenting() || Bt && Bt(t)
        }), "undefined" != typeof window && Ft.setContext(window), this.setAnimationLoop = function (t) {
            Bt = t, zt.setAnimationLoop(t), Ft.start()
        }, this.render = function (t, e, i, n) {
            if (e && e.isCamera) {
                if (!z) {
                    U = M = null, G = !1, H = -1, j = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === e.parent && e.updateMatrixWorld(), zt.enabled && (e = zt.getCamera(e)), I = Ct.get(t, e), I.init(), t.onBeforeRender(N, t, e, i), gt.multiplyMatrices(e.projectionMatrix, e.matrixWorldInverse), pt.setFromMatrix(gt), mt = this.localClippingEnabled, ft = dt.init(this.clippingPlanes, mt, e), D = Lt.get(t, e), D.init(), h(t, e, 0, N.sortObjects), !0 === N.sortObjects && D.sort(), ft && dt.beginShadows(), kt.render(I.state.shadowsArray, t, e), I.setupLights(e), ft && dt.endShadows(), this.info.autoReset && this.info.reset(), void 0 === i && (i = null), this.setRenderTarget(i), Rt.render(D, t, e, n), n = D.opaque;
                    var r = D.transparent;
                    if (t.overrideMaterial) {
                        var a = t.overrideMaterial;
                        n.length && u(n, t, e, a), r.length && u(r, t, e, a)
                    } else n.length && u(n, t, e), r.length && u(r, t, e);
                    i && (Tt.updateRenderTargetMipmap(i), Tt.updateMultisampleRenderTarget(i)), bt.buffers.depth.setTest(!0), bt.buffers.depth.setMask(!0), bt.buffers.color.setMask(!0), bt.setPolygonOffset(!1), t.onAfterRender(N, t, e), zt.enabled && zt.submitFrame(), I = D = null
                }
            } else console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.")
        }, this.allocTextureUnit = function () {
            var t = Y;
            return t >= _t.maxTextures && console.warn("THREE.WebGLRenderer: Trying to use " + t + " texture units while this GPU supports only " + _t.maxTextures), Y += 1, t
        }, this.setTexture2D = function () {
            var t = !1;
            return function (e, i) {
                e && e.isWebGLRenderTarget && (t || (console.warn("THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), Tt.setTexture2D(e, i)
            }
        }(), this.setTexture3D = function () {
            return function (t, e) {
                Tt.setTexture3D(t, e)
            }
        }(), this.setTexture = function () {
            var t = !1;
            return function (e, i) {
                t || (console.warn("THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead."), t = !0), Tt.setTexture2D(e, i)
            }
        }(), this.setTextureCube = function () {
            var t = !1;
            return function (e, i) {
                e && e.isWebGLRenderTargetCube && (t || (console.warn("THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead."), t = !0), e = e.texture), e && e.isCubeTexture || Array.isArray(e.image) && 6 === e.image.length ? Tt.setTextureCube(e, i) : Tt.setTextureCubeDynamic(e, i)
            }
        }(), this.setFramebuffer = function (t) {
            k = t
        }, this.getRenderTarget = function () {
            return B
        }, this.setRenderTarget = function (t) {
            (B = t) && void 0 === Mt.get(t).__webglFramebuffer && Tt.setupRenderTarget(t);
            var e = k, i = !1;
            t ? (e = Mt.get(t).__webglFramebuffer, t.isWebGLRenderTargetCube ? (e = e[t.activeCubeFace], i = !0) : e = t.isWebGLMultisampleRenderTarget ? Mt.get(t).__webglMultisampledFramebuffer : e, W.copy(t.viewport), q.copy(t.scissor), X = t.scissorTest) : (W.copy(ct).multiplyScalar(lt), q.copy(ht).multiplyScalar(lt), X = ut), F !== e && (yt.bindFramebuffer(36160, e), F = e), bt.viewport(W), bt.scissor(q), bt.setScissorTest(X), i && (i = Mt.get(t.texture), yt.framebufferTexture2D(36160, 36064, 34069 + t.activeCubeFace, i.__webglTexture, t.activeMipMapLevel))
        }, this.readRenderTargetPixels = function (t, e, i, n, r, a) {
            if (t && t.isWebGLRenderTarget) {
                var o = Mt.get(t).__webglFramebuffer;
                if (o) {
                    var s = !1;
                    o !== F && (yt.bindFramebuffer(36160, o), s = !0);
                    try {
                        var l = t.texture, c = l.format, h = l.type;
                        1023 !== c && Nt.convert(c) !== yt.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === h || Nt.convert(h) === yt.getParameter(35738) || 1015 === h && (_t.isWebGL2 || xt.get("OES_texture_float") || xt.get("WEBGL_color_buffer_float")) || 1016 === h && (_t.isWebGL2 ? xt.get("EXT_color_buffer_float") : xt.get("EXT_color_buffer_half_float")) ? 36053 === yt.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && yt.readPixels(e, i, n, r, Nt.convert(c), Nt.convert(h), a) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")
                    } finally {
                        s && yt.bindFramebuffer(36160, F)
                    }
                }
            } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")
        }, this.copyFramebufferToTexture = function (t, e, i) {
            var n = e.image.width, r = e.image.height, a = Nt.convert(e.format);
            this.setTexture2D(e, 0), yt.copyTexImage2D(3553, i || 0, a, t.x, t.y, n, r, 0)
        }, this.copyTextureToTexture = function (t, e, i, n) {
            var r = e.image.width, a = e.image.height, o = Nt.convert(i.format), s = Nt.convert(i.type);
            this.setTexture2D(i, 0), e.isDataTexture ? yt.texSubImage2D(3553, n || 0, t.x, t.y, r, a, o, s, e.image.data) : yt.texSubImage2D(3553, n || 0, t.x, t.y, o, s, e.image)
        }
    }

    function Pe(t, e) {
        this.name = "", this.color = new x(t), this.density = void 0 !== e ? e : 25e-5
    }

    function Le(t, e, i) {
        this.name = "", this.color = new x(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3
    }

    function Ce() {
        S.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0
    }

    function Re(t, e) {
        this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = {
            offset: 0,
            count: -1
        }, this.version = 0
    }

    function Oe(t, e, i, n) {
        this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n
    }

    function De(t) {
        V.call(this), this.type = "SpriteMaterial", this.color = new x(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t)
    }

    function Ie(t) {
        if (S.call(this), this.type = "Sprite", void 0 === Ia) {
            Ia = new F;
            var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]);
            e = new Re(e, 5), Ia.setIndex([0, 1, 2, 0, 2, 3]), Ia.addAttribute("position", new Oe(e, 3, 0, !1)), Ia.addAttribute("uv", new Oe(e, 2, 3, !1))
        }
        this.geometry = Ia, this.material = void 0 !== t ? t : new De, this.center = new i(.5, .5)
    }

    function Ne() {
        S.call(this), this.type = "LOD", Object.defineProperties(this, {levels: {enumerable: !0, value: []}})
    }

    function ze(t, e) {
        t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), J.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new n, this.bindMatrixInverse = new n
    }

    function ke(t, e) {
        if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++) this.boneInverses.push(new n)
    }

    function Be() {
        S.call(this), this.type = "Bone"
    }

    function Fe(t) {
        V.call(this), this.type = "LineBasicMaterial", this.color = new x(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t)
    }

    function He(t, e, i) {
        1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), S.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new F, this.material = void 0 !== e ? e : new Fe({color: 16777215 * Math.random()})
    }

    function Ue(t, e) {
        He.call(this, t, e), this.type = "LineSegments"
    }

    function Ge(t, e) {
        He.call(this, t, e), this.type = "LineLoop"
    }

    function je(t) {
        V.call(this), this.type = "PointsMaterial", this.color = new x(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(t)
    }

    function Ve(t, e) {
        S.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new F, this.material = void 0 !== e ? e : new je({color: 16777215 * Math.random()})
    }

    function We(t, e, i, n, r, a, o, l, c) {
        s.call(this, t, e, i, n, r, a, o, l, c), this.format = void 0 !== o ? o : 1022, this.minFilter = void 0 !== a ? a : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1
    }

    function qe(t, e, i, n, r, a, o, l, c, h, u, p) {
        s.call(this, null, a, o, l, c, h, n, r, u, p), this.image = {
            width: e,
            height: i
        }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1
    }

    function Xe(t, e, i, n, r, a, o, l, c) {
        s.call(this, t, e, i, n, r, a, o, l, c), this.needsUpdate = !0
    }

    function Ye(t, e, i, n, r, a, o, l, c, h) {
        if (1026 !== (h = void 0 !== h ? h : 1026) && 1027 !== h) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        void 0 === i && 1026 === h && (i = 1012), void 0 === i && 1027 === h && (i = 1020), s.call(this, null, n, r, a, o, l, h, i, c), this.image = {
            width: t,
            height: e
        }, this.magFilter = void 0 !== o ? o : 1003, this.minFilter = void 0 !== l ? l : 1003, this.generateMipmaps = this.flipY = !1
    }

    function Je(t) {
        F.call(this), this.type = "WireframeGeometry";
        var e = [], i, n, r, o = [0, 0], s = {}, l = ["a", "b", "c"];
        if (t && t.isGeometry) {
            var c = t.faces, h = 0;
            for (n = c.length; h < n; h++) {
                var u = c[h];
                for (i = 0; 3 > i; i++) {
                    var p = u[l[i]], d = u[l[(i + 1) % 3]];
                    o[0] = Math.min(p, d), o[1] = Math.max(p, d), p = o[0] + "," + o[1], void 0 === s[p] && (s[p] = {
                        index1: o[0],
                        index2: o[1]
                    })
                }
            }
            for (p in s) h = s[p], l = t.vertices[h.index1], e.push(l.x, l.y, l.z), l = t.vertices[h.index2], e.push(l.x, l.y, l.z)
        } else if (t && t.isBufferGeometry) if (l = new a, null !== t.index) {
            c = t.attributes.position, u = t.index;
            var f = t.groups;
            for (0 === f.length && (f = [{
                start: 0,
                count: u.count,
                materialIndex: 0
            }]), t = 0, r = f.length; t < r; ++t) for (h = f[t], i = h.start, n = h.count, h = i, n = i + n; h < n; h += 3) for (i = 0; 3 > i; i++) p = u.getX(h + i), d = u.getX(h + (i + 1) % 3), o[0] = Math.min(p, d), o[1] = Math.max(p, d), p = o[0] + "," + o[1], void 0 === s[p] && (s[p] = {
                index1: o[0],
                index2: o[1]
            });
            for (p in s) h = s[p], l.fromBufferAttribute(c, h.index1), e.push(l.x, l.y, l.z), l.fromBufferAttribute(c, h.index2), e.push(l.x, l.y, l.z)
        } else for (c = t.attributes.position, h = 0, n = c.count / 3; h < n; h++) for (i = 0; 3 > i; i++) s = 3 * h + i, l.fromBufferAttribute(c, s), e.push(l.x, l.y, l.z), s = 3 * h + (i + 1) % 3, l.fromBufferAttribute(c, s), e.push(l.x, l.y, l.z);
        this.addAttribute("position", new N(e, 3))
    }

    function Ze(t, e, i) {
        E.call(this), this.type = "ParametricGeometry", this.parameters = {
            func: t,
            slices: e,
            stacks: i
        }, this.fromBufferGeometry(new $e(t, e, i)), this.mergeVertices()
    }

    function $e(t, e, i) {
        F.call(this), this.type = "ParametricBufferGeometry", this.parameters = {func: t, slices: e, stacks: i};
        var n = [], r = [], o = [], s = [], l = new a, c = new a, h = new a, u = new a, p = new a, d, f;
        3 > t.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.");
        var m = e + 1;
        for (d = 0; d <= i; d++) {
            var g = d / i;
            for (f = 0; f <= e; f++) {
                var v = f / e;
                t(v, g, c), r.push(c.x, c.y, c.z), 0 <= v - 1e-5 ? (t(v - 1e-5, g, h), u.subVectors(c, h)) : (t(v + 1e-5, g, h), u.subVectors(h, c)), 0 <= g - 1e-5 ? (t(v, g - 1e-5, h), p.subVectors(c, h)) : (t(v, g + 1e-5, h), p.subVectors(h, c)), l.crossVectors(u, p).normalize(), o.push(l.x, l.y, l.z), s.push(v, g)
            }
        }
        for (d = 0; d < i; d++) for (f = 0; f < e; f++) t = d * m + f + 1, l = (d + 1) * m + f + 1, c = (d + 1) * m + f, n.push(d * m + f, t, c), n.push(t, l, c);
        this.setIndex(n), this.addAttribute("position", new N(r, 3)), this.addAttribute("normal", new N(o, 3)), this.addAttribute("uv", new N(s, 2))
    }

    function Qe(t, e, i, n) {
        E.call(this), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: i,
            detail: n
        }, this.fromBufferGeometry(new Ke(t, e, i, n)), this.mergeVertices()
    }

    function Ke(t, e, n, r) {
        function o(t) {
            c.push(t.x, t.y, t.z)
        }

        function s(e, i) {
            e *= 3, i.x = t[e + 0], i.y = t[e + 1], i.z = t[e + 2]
        }

        function l(t, e, i, n) {
            0 > n && 1 === t.x && (h[e] = t.x - 1), 0 === i.x && 0 === i.z && (h[e] = n / 2 / Math.PI + .5)
        }

        F.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = {
            vertices: t,
            indices: e,
            radius: n,
            detail: r
        }, n = n || 1, r = r || 0;
        var c = [], h = [];
        !function (t) {
            for (var i = new a, n = new a, r = new a, l = 0; l < e.length; l += 3) {
                s(e[l + 0], i), s(e[l + 1], n), s(e[l + 2], r);
                var c, h, u = i, p = n, d = r, f = Math.pow(2, t), m = [];
                for (h = 0; h <= f; h++) {
                    m[h] = [];
                    var g = u.clone().lerp(d, h / f), v = p.clone().lerp(d, h / f), y = f - h;
                    for (c = 0; c <= y; c++) m[h][c] = 0 === c && h === f ? g : g.clone().lerp(v, c / y)
                }
                for (h = 0; h < f; h++) for (c = 0; c < 2 * (f - h) - 1; c++) u = Math.floor(c / 2), 0 == c % 2 ? (o(m[h][u + 1]), o(m[h + 1][u]), o(m[h][u])) : (o(m[h][u + 1]), o(m[h + 1][u + 1]), o(m[h + 1][u]))
            }
        }(r), function (t) {
            for (var e = new a, i = 0; i < c.length; i += 3) e.x = c[i + 0], e.y = c[i + 1], e.z = c[i + 2], e.normalize().multiplyScalar(t), c[i + 0] = e.x, c[i + 1] = e.y, c[i + 2] = e.z
        }(n), function () {
            for (var t = new a, e = 0; e < c.length; e += 3) t.x = c[e + 0], t.y = c[e + 1], t.z = c[e + 2], h.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5));
            t = new a, e = new a;
            for (var n = new a, r = new a, o = new i, s = new i, u = new i, p = 0, d = 0; p < c.length; p += 9, d += 6) {
                t.set(c[p + 0], c[p + 1], c[p + 2]), e.set(c[p + 3], c[p + 4], c[p + 5]), n.set(c[p + 6], c[p + 7], c[p + 8]), o.set(h[d + 0], h[d + 1]), s.set(h[d + 2], h[d + 3]), u.set(h[d + 4], h[d + 5]), r.copy(t).add(e).add(n).divideScalar(3);
                var f = Math.atan2(r.z, -r.x);
                l(o, d + 0, t, f), l(s, d + 2, e, f), l(u, d + 4, n, f)
            }
            for (t = 0; t < h.length; t += 6) e = h[t + 0], n = h[t + 2], r = h[t + 4], o = Math.min(e, n, r), .9 < Math.max(e, n, r) && .1 > o && (.2 > e && (h[t + 0] += 1), .2 > n && (h[t + 2] += 1), .2 > r && (h[t + 4] += 1))
        }(), this.addAttribute("position", new N(c, 3)), this.addAttribute("normal", new N(c.slice(), 3)), this.addAttribute("uv", new N(h, 2)), 0 === r ? this.computeVertexNormals() : this.normalizeNormals()
    }

    function ti(t, e) {
        E.call(this), this.type = "TetrahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ei(t, e)), this.mergeVertices()
    }

    function ei(t, e) {
        Ke.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ii(t, e) {
        E.call(this), this.type = "OctahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ni(t, e)), this.mergeVertices()
    }

    function ni(t, e) {
        Ke.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function ri(t, e) {
        E.call(this), this.type = "IcosahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new ai(t, e)), this.mergeVertices()
    }

    function ai(t, e) {
        var i = (1 + Math.sqrt(5)) / 2;
        Ke.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function oi(t, e) {
        E.call(this), this.type = "DodecahedronGeometry", this.parameters = {
            radius: t,
            detail: e
        }, this.fromBufferGeometry(new si(t, e)), this.mergeVertices()
    }

    function si(t, e) {
        var i = (1 + Math.sqrt(5)) / 2, n = 1 / i;
        Ke.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = {
            radius: t,
            detail: e
        }
    }

    function li(t, e, i, n, r, a) {
        E.call(this), this.type = "TubeGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: i,
            radialSegments: n,
            closed: r
        }, void 0 !== a && console.warn("THREE.TubeGeometry: taper has been removed."), t = new ci(t, e, i, n, r), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices()
    }

    function ci(t, e, n, r, o) {
        function s(i) {
            p = t.getPointAt(i / e, p);
            var a = l.normals[i];
            for (i = l.binormals[i], f = 0; f <= r; f++) {
                var o = f / r * Math.PI * 2, s = Math.sin(o);
                o = -Math.cos(o), h.x = o * a.x + s * i.x, h.y = o * a.y + s * i.y, h.z = o * a.z + s * i.z, h.normalize(), g.push(h.x, h.y, h.z), c.x = p.x + n * h.x, c.y = p.y + n * h.y, c.z = p.z + n * h.z, m.push(c.x, c.y, c.z)
            }
        }

        F.call(this), this.type = "TubeBufferGeometry", this.parameters = {
            path: t,
            tubularSegments: e,
            radius: n,
            radialSegments: r,
            closed: o
        }, e = e || 64, n = n || 1, r = r || 8, o = o || !1;
        var l = t.computeFrenetFrames(e, o);
        this.tangents = l.tangents, this.normals = l.normals, this.binormals = l.binormals;
        var c = new a, h = new a, u = new i, p = new a, d, f, m = [], g = [], v = [], y = [];
        for (d = 0; d < e; d++) s(d);
        for (s(!1 === o ? e : 0), d = 0; d <= e; d++) for (f = 0; f <= r; f++) u.x = d / e, u.y = f / r, v.push(u.x, u.y);
        !function () {
            for (f = 1; f <= e; f++) for (d = 1; d <= r; d++) {
                var t = (r + 1) * f + (d - 1), i = (r + 1) * f + d, n = (r + 1) * (f - 1) + d;
                y.push((r + 1) * (f - 1) + (d - 1), t, n), y.push(t, i, n)
            }
        }(), this.setIndex(y), this.addAttribute("position", new N(m, 3)), this.addAttribute("normal", new N(g, 3)), this.addAttribute("uv", new N(v, 2))
    }

    function hi(t, e, i, n, r, a, o) {
        E.call(this), this.type = "TorusKnotGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: a
        }, void 0 !== o && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new ui(t, e, i, n, r, a)), this.mergeVertices()
    }

    function ui(t, e, i, n, r, o) {
        function s(t, e, i, n, r) {
            var a = Math.sin(t);
            e = i / e * t, i = Math.cos(e), r.x = n * (2 + i) * .5 * Math.cos(t), r.y = n * (2 + i) * a * .5, r.z = n * Math.sin(e) * .5
        }

        F.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            tubularSegments: i,
            radialSegments: n,
            p: r,
            q: o
        }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, r = r || 2, o = o || 3;
        var l = [], c = [], h = [], u = [], p, d = new a, f = new a, m = new a, g = new a, v = new a, y = new a,
            x = new a;
        for (p = 0; p <= i; ++p) {
            var _ = p / i * r * Math.PI * 2;
            for (s(_, r, o, t, m), s(_ + .01, r, o, t, g), y.subVectors(g, m), x.addVectors(g, m), v.crossVectors(y, x), x.crossVectors(v, y), v.normalize(), x.normalize(), _ = 0; _ <= n; ++_) {
                var b = _ / n * Math.PI * 2, w = -e * Math.cos(b);
                b = e * Math.sin(b), d.x = m.x + (w * x.x + b * v.x), d.y = m.y + (w * x.y + b * v.y), d.z = m.z + (w * x.z + b * v.z), c.push(d.x, d.y, d.z), f.subVectors(d, m).normalize(), h.push(f.x, f.y, f.z), u.push(p / i), u.push(_ / n)
            }
        }
        for (_ = 1; _ <= i; _++) for (p = 1; p <= n; p++) t = (n + 1) * _ + (p - 1), e = (n + 1) * _ + p, r = (n + 1) * (_ - 1) + p, l.push((n + 1) * (_ - 1) + (p - 1), t, r), l.push(t, e, r);
        this.setIndex(l), this.addAttribute("position", new N(c, 3)), this.addAttribute("normal", new N(h, 3)), this.addAttribute("uv", new N(u, 2))
    }

    function pi(t, e, i, n, r) {
        E.call(this), this.type = "TorusGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, this.fromBufferGeometry(new di(t, e, i, n, r)), this.mergeVertices()
    }

    function di(t, e, i, n, r) {
        F.call(this), this.type = "TorusBufferGeometry", this.parameters = {
            radius: t,
            tube: e,
            radialSegments: i,
            tubularSegments: n,
            arc: r
        }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, r = r || 2 * Math.PI;
        var o = [], s = [], l = [], c = [], h = new a, u = new a, p = new a, d, f;
        for (d = 0; d <= i; d++) for (f = 0; f <= n; f++) {
            var m = f / n * r, g = d / i * Math.PI * 2;
            u.x = (t + e * Math.cos(g)) * Math.cos(m), u.y = (t + e * Math.cos(g)) * Math.sin(m), u.z = e * Math.sin(g), s.push(u.x, u.y, u.z), h.x = t * Math.cos(m), h.y = t * Math.sin(m), p.subVectors(u, h).normalize(), l.push(p.x, p.y, p.z), c.push(f / n), c.push(d / i)
        }
        for (d = 1; d <= i; d++) for (f = 1; f <= n; f++) t = (n + 1) * (d - 1) + f - 1, e = (n + 1) * (d - 1) + f, r = (n + 1) * d + f, o.push((n + 1) * d + f - 1, t, r), o.push(t, e, r);
        this.setIndex(o), this.addAttribute("position", new N(s, 3)), this.addAttribute("normal", new N(l, 3)), this.addAttribute("uv", new N(c, 2))
    }

    function fi(t, e, i, n, r) {
        for (var a, o = 0, s = e, l = i - n; s < i; s += n) o += (t[l] - t[s]) * (t[s + 1] + t[l + 1]), l = s;
        if (r === 0 < o) for (r = e; r < i; r += n) a = Ai(r, t[r], t[r + 1], a); else for (r = i - n; r >= e; r -= n) a = Ai(r, t[r], t[r + 1], a);
        return a && Mi(a, a.next) && (Pi(a), a = a.next), a
    }

    function mi(t, e) {
        if (!t) return t;
        e || (e = t);
        do {
            var i = !1;
            if (t.steiner || !Mi(t, t.next) && 0 !== wi(t.prev, t, t.next)) t = t.next; else {
                if (Pi(t), (t = e = t.prev) === t.next) break;
                i = !0
            }
        } while (i || t !== e);
        return e
    }

    function gi(t, e, i, n, r, a, o) {
        if (t) {
            if (!o && a) {
                var s = t, l = s;
                do {
                    null === l.z && (l.z = xi(l.x, l.y, n, r, a)), l.prevZ = l.prev, l = l.nextZ = l.next
                } while (l !== s);
                l.prevZ.nextZ = null, l.prevZ = null, s = l;
                var c, h, u, p, d = 1;
                do {
                    l = s;
                    var f = s = null;
                    for (h = 0; l;) {
                        h++;
                        var m = l;
                        for (c = u = 0; c < d && (u++, m = m.nextZ); c++) ;
                        for (p = d; 0 < u || 0 < p && m;) 0 !== u && (0 === p || !m || l.z <= m.z) ? (c = l, l = l.nextZ, u--) : (c = m, m = m.nextZ, p--), f ? f.nextZ = c : s = c, c.prevZ = f, f = c;
                        l = m
                    }
                    f.nextZ = null, d *= 2
                } while (1 < h)
            }
            for (s = t; t.prev !== t.next;) {
                if (l = t.prev, m = t.next, a) t:{
                    f = t, p = n;
                    var g = r, v = a;
                    if (h = f.prev, u = f, d = f.next, 0 <= wi(h, u, d)) f = !1; else {
                        var y = h.x > u.x ? h.x > d.x ? h.x : d.x : u.x > d.x ? u.x : d.x,
                            x = h.y > u.y ? h.y > d.y ? h.y : d.y : u.y > d.y ? u.y : d.y;
                        for (c = xi(h.x < u.x ? h.x < d.x ? h.x : d.x : u.x < d.x ? u.x : d.x, h.y < u.y ? h.y < d.y ? h.y : d.y : u.y < d.y ? u.y : d.y, p, g, v), p = xi(y, x, p, g, v), g = f.nextZ; g && g.z <= p;) {
                            if (g !== f.prev && g !== f.next && bi(h.x, h.y, u.x, u.y, d.x, d.y, g.x, g.y) && 0 <= wi(g.prev, g, g.next)) {
                                f = !1;
                                break t
                            }
                            g = g.nextZ
                        }
                        for (g = f.prevZ; g && g.z >= c;) {
                            if (g !== f.prev && g !== f.next && bi(h.x, h.y, u.x, u.y, d.x, d.y, g.x, g.y) && 0 <= wi(g.prev, g, g.next)) {
                                f = !1;
                                break t
                            }
                            g = g.prevZ
                        }
                        f = !0
                    }
                } else t:if (f = t, h = f.prev, u = f, d = f.next, 0 <= wi(h, u, d)) f = !1; else {
                    for (c = f.next.next; c !== f.prev;) {
                        if (bi(h.x, h.y, u.x, u.y, d.x, d.y, c.x, c.y) && 0 <= wi(c.prev, c, c.next)) {
                            f = !1;
                            break t
                        }
                        c = c.next
                    }
                    f = !0
                }
                if (f) e.push(l.i / i), e.push(t.i / i), e.push(m.i / i), Pi(t), s = t = m.next; else if ((t = m) === s) {
                    if (o) {
                        if (1 === o) {
                            o = e, s = i, l = t;
                            do {
                                m = l.prev, f = l.next.next, !Mi(m, f) && Ti(m, l, l.next, f) && Si(m, f) && Si(f, m) && (o.push(m.i / s), o.push(l.i / s), o.push(f.i / s), Pi(l), Pi(l.next), l = t = f), l = l.next
                            } while (l !== t);
                            t = l, gi(t, e, i, n, r, a, 2)
                        } else if (2 === o) t:{
                            o = t;
                            do {
                                for (s = o.next.next; s !== o.prev;) {
                                    if (l = o.i !== s.i) {
                                        if (l = o, m = s, f = l.next.i !== m.i && l.prev.i !== m.i) {
                                            e:{
                                                f = l;
                                                do {
                                                    if (f.i !== l.i && f.next.i !== l.i && f.i !== m.i && f.next.i !== m.i && Ti(f, f.next, l, m)) {
                                                        f = !0;
                                                        break e
                                                    }
                                                    f = f.next
                                                } while (f !== l);
                                                f = !1
                                            }
                                            f = !f
                                        }
                                        if (f = f && Si(l, m) && Si(m, l)) {
                                            f = l, h = !1, u = (l.x + m.x) / 2, m = (l.y + m.y) / 2;
                                            do {
                                                f.y > m != f.next.y > m && f.next.y !== f.y && u < (f.next.x - f.x) * (m - f.y) / (f.next.y - f.y) + f.x && (h = !h), f = f.next
                                            } while (f !== l);
                                            f = h
                                        }
                                        l = f
                                    }
                                    if (l) {
                                        t = Ei(o, s), o = mi(o, o.next), t = mi(t, t.next), gi(o, e, i, n, r, a), gi(t, e, i, n, r, a);
                                        break t
                                    }
                                    s = s.next
                                }
                                o = o.next
                            } while (o !== t)
                        }
                    } else gi(mi(t), e, i, n, r, a, 1);
                    break
                }
            }
        }
    }

    function vi(t, e) {
        return t.x - e.x
    }

    function yi(t, e) {
        var i = e, n = t.x, r = t.y, a = -(1 / 0);
        do {
            if (r <= i.y && r >= i.next.y && i.next.y !== i.y) {
                var o = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                if (o <= n && o > a) {
                    if (a = o, o === n) {
                        if (r === i.y) return i;
                        if (r === i.next.y) return i.next
                    }
                    var s = i.x < i.next.x ? i : i.next
                }
            }
            i = i.next
        } while (i !== e);
        if (!s) return null;
        if (n === a) return s.prev;
        e = s, o = s.x;
        var l = s.y, c = 1 / 0;
        for (i = s.next; i !== e;) {
            if (n >= i.x && i.x >= o && n !== i.x && bi(r < l ? n : a, r, o, l, r < l ? a : n, r, i.x, i.y)) {
                var h = Math.abs(r - i.y) / (n - i.x);
                (h < c || h === c && i.x > s.x) && Si(i, t) && (s = i, c = h)
            }
            i = i.next
        }
        return s
    }

    function xi(t, e, i, n, r) {
        return t = 32767 * (t - i) * r, e = 32767 * (e - n) * r, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), 1431655765 & (t | t << 1) | (1431655765 & (e | e << 1)) << 1
    }

    function _i(t) {
        var e = t, i = t;
        do {
            e.x < i.x && (i = e), e = e.next
        } while (e !== t);
        return i
    }

    function bi(t, e, i, n, r, a, o, s) {
        return 0 <= (r - o) * (e - s) - (t - o) * (a - s) && 0 <= (t - o) * (n - s) - (i - o) * (e - s) && 0 <= (i - o) * (a - s) - (r - o) * (n - s)
    }

    function wi(t, e, i) {
        return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
    }

    function Mi(t, e) {
        return t.x === e.x && t.y === e.y
    }

    function Ti(t, e, i, n) {
        return !!(Mi(t, e) && Mi(i, n) || Mi(t, n) && Mi(i, e)) || 0 < wi(t, e, i) != 0 < wi(t, e, n) && 0 < wi(i, n, t) != 0 < wi(i, n, e)
    }

    function Si(t, e) {
        return 0 > wi(t.prev, t, t.next) ? 0 <= wi(t, e, t.next) && 0 <= wi(t, t.prev, e) : 0 > wi(t, e, t.prev) || 0 > wi(t, t.next, e)
    }

    function Ei(t, e) {
        var i = new Li(t.i, t.x, t.y), n = new Li(e.i, e.x, e.y), r = t.next, a = e.prev;
        return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, a.next = n, n.prev = a, n
    }

    function Ai(t, e, i, n) {
        return t = new Li(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t
    }

    function Pi(t) {
        t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
    }

    function Li(t, e, i) {
        this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1
    }

    function Ci(t) {
        var e = t.length;
        2 < e && t[e - 1].equals(t[0]) && t.pop()
    }

    function Ri(t, e) {
        for (var i = 0; i < e.length; i++) t.push(e[i].x), t.push(e[i].y)
    }

    function Oi(t, e) {
        E.call(this), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: t,
            options: e
        }, this.fromBufferGeometry(new Di(t, e)), this.mergeVertices()
    }

    function Di(t, e) {
        function n(t) {
            function n(t, e, i) {
                return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t)
            }

            function l(t, e, n) {
                var r = t.x - e.x, a = t.y - e.y, o = n.x - t.x, s = n.y - t.y, l = r * r + a * a;
                if (Math.abs(r * s - a * o) > Number.EPSILON) {
                    var c = Math.sqrt(l), h = Math.sqrt(o * o + s * s);
                    if (l = e.x - a / c, e = e.y + r / c, s = ((n.x - s / h - l) * s - (n.y + o / h - e) * o) / (r * s - a * o), o = l + r * s - t.x, r = e + a * s - t.y, 2 >= (a = o * o + r * r)) return new i(o, r);
                    a = Math.sqrt(a / 2)
                } else t = !1, r > Number.EPSILON ? o > Number.EPSILON && (t = !0) : r < -Number.EPSILON ? o < -Number.EPSILON && (t = !0) : Math.sign(a) === Math.sign(s) && (t = !0), t ? (o = -a, a = Math.sqrt(l)) : (o = r, r = a, a = Math.sqrt(l / 2));
                return new i(o / a, r / a)
            }

            function c(t, e) {
                for (H = t.length; 0 <= --H;) {
                    var i = H, n = H - 1;
                    0 > n && (n = t.length - 1);
                    var a, s = g + 2 * b;
                    for (a = 0; a < s; a++) {
                        var l = k * a, c = k * (a + 1), h = e + n + l, u = e + n + c;
                        c = e + i + c, p(e + i + l), p(h), p(c), p(h), p(u), p(c), l = o.length / 3, l = M.generateSideWallUV(r, o, l - 6, l - 3, l - 2, l - 1), d(l[0]), d(l[1]), d(l[3]), d(l[1]), d(l[2]), d(l[3])
                    }
                }
            }

            function h(t, e, i) {
                f.push(t), f.push(e), f.push(i)
            }

            function u(t, e, i) {
                p(t), p(e), p(i), t = o.length / 3, t = M.generateTopUV(r, o, t - 3, t - 2, t - 1), d(t[0]), d(t[1]), d(t[2])
            }

            function p(t) {
                o.push(f[3 * t]), o.push(f[3 * t + 1]), o.push(f[3 * t + 2])
            }

            function d(t) {
                s.push(t.x), s.push(t.y)
            }

            var f = [], m = void 0 !== e.curveSegments ? e.curveSegments : 12, g = void 0 !== e.steps ? e.steps : 1,
                v = void 0 !== e.depth ? e.depth : 100, y = void 0 === e.bevelEnabled || e.bevelEnabled,
                x = void 0 !== e.bevelThickness ? e.bevelThickness : 6,
                _ = void 0 !== e.bevelSize ? e.bevelSize : x - 2, b = void 0 !== e.bevelSegments ? e.bevelSegments : 3,
                w = e.extrudePath, M = void 0 !== e.UVGenerator ? e.UVGenerator : ka;
            void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = e.amount);
            var T = !1;
            if (w) {
                var S = w.getSpacedPoints(g);
                T = !0, y = !1;
                var E = w.computeFrenetFrames(g, !1), A = new a, P = new a, L = new a
            }
            y || (_ = x = b = 0);
            var C;
            m = t.extractPoints(m), t = m.shape;
            var R = m.holes;
            if (!za.isClockWise(t)) {
                t = t.reverse();
                var O = 0;
                for (C = R.length; O < C; O++) {
                    var D = R[O];
                    za.isClockWise(D) && (R[O] = D.reverse())
                }
            }
            var I = za.triangulateShape(t, R), N = t;
            for (O = 0, C = R.length; O < C; O++) D = R[O], t = t.concat(D);
            var z, k = t.length, B, F = I.length;
            m = [];
            var H = 0, U = N.length, G = U - 1;
            for (z = H + 1; H < U; H++, G++, z++) G === U && (G = 0), z === U && (z = 0), m[H] = l(N[H], N[G], N[z]);
            w = [];
            var j = m.concat();
            for (O = 0, C = R.length; O < C; O++) {
                D = R[O];
                var V = [];
                for (H = 0, U = D.length, G = U - 1, z = H + 1; H < U; H++, G++, z++) G === U && (G = 0), z === U && (z = 0), V[H] = l(D[H], D[G], D[z]);
                w.push(V), j = j.concat(V)
            }
            for (G = 0; G < b; G++) {
                U = G / b;
                var W = x * Math.cos(U * Math.PI / 2);
                for (z = _ * Math.sin(U * Math.PI / 2), H = 0, U = N.length; H < U; H++) {
                    var q = n(N[H], m[H], z);
                    h(q.x, q.y, -W)
                }
                for (O = 0, C = R.length; O < C; O++) for (D = R[O], V = w[O], H = 0, U = D.length; H < U; H++) q = n(D[H], V[H], z), h(q.x, q.y, -W)
            }
            for (z = _, H = 0; H < k; H++) q = y ? n(t[H], j[H], z) : t[H], T ? (P.copy(E.normals[0]).multiplyScalar(q.x), A.copy(E.binormals[0]).multiplyScalar(q.y), L.copy(S[0]).add(P).add(A), h(L.x, L.y, L.z)) : h(q.x, q.y, 0);
            for (U = 1; U <= g; U++) for (H = 0; H < k; H++) q = y ? n(t[H], j[H], z) : t[H], T ? (P.copy(E.normals[U]).multiplyScalar(q.x), A.copy(E.binormals[U]).multiplyScalar(q.y), L.copy(S[U]).add(P).add(A), h(L.x, L.y, L.z)) : h(q.x, q.y, v / g * U);
            for (G = b - 1; 0 <= G; G--) {
                for (U = G / b, W = x * Math.cos(U * Math.PI / 2), z = _ * Math.sin(U * Math.PI / 2), H = 0, U = N.length; H < U; H++) q = n(N[H], m[H], z), h(q.x, q.y, v + W);
                for (O = 0, C = R.length; O < C; O++) for (D = R[O], V = w[O], H = 0, U = D.length; H < U; H++) q = n(D[H], V[H], z), T ? h(q.x, q.y + S[g - 1].y, S[g - 1].x + W) : h(q.x, q.y, v + W)
            }
            !function () {
                var t = o.length / 3;
                if (y) {
                    var e = 0 * k;
                    for (H = 0; H < F; H++) B = I[H], u(B[2] + e, B[1] + e, B[0] + e);
                    for (e = k * (g + 2 * b), H = 0; H < F; H++) B = I[H], u(B[0] + e, B[1] + e, B[2] + e)
                } else {
                    for (H = 0; H < F; H++) B = I[H], u(B[2], B[1], B[0]);
                    for (H = 0; H < F; H++) B = I[H], u(B[0] + k * g, B[1] + k * g, B[2] + k * g)
                }
                r.addGroup(t, o.length / 3 - t, 0)
            }(), function () {
                var t = o.length / 3, e = 0;
                for (c(N, e), e += N.length, O = 0, C = R.length; O < C; O++) D = R[O], c(D, e), e += D.length;
                r.addGroup(t, o.length / 3 - t, 1)
            }()
        }

        F.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = {
            shapes: t,
            options: e
        }, t = Array.isArray(t) ? t : [t];
        for (var r = this, o = [], s = [], l = 0, c = t.length; l < c; l++) n(t[l]);
        this.addAttribute("position", new N(o, 3)), this.addAttribute("uv", new N(s, 2)), this.computeVertexNormals()
    }

    function Ii(t, e, i) {
        if (i.shapes = [], Array.isArray(t)) for (var n = 0, r = t.length; n < r; n++) i.shapes.push(t[n].uuid); else i.shapes.push(t.uuid);
        return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i
    }

    function Ni(t, e) {
        E.call(this), this.type = "TextGeometry", this.parameters = {
            text: t,
            parameters: e
        }, this.fromBufferGeometry(new zi(t, e)), this.mergeVertices()
    }

    function zi(t, e) {
        e = e || {};
        var i = e.font;
        if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new E;
        t = i.generateShapes(t, e.size), e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Di.call(this, t, e), this.type = "TextBufferGeometry"
    }

    function ki(t, e, i, n, r, a, o) {
        E.call(this), this.type = "SphereGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: a,
            thetaLength: o
        }, this.fromBufferGeometry(new Bi(t, e, i, n, r, a, o)), this.mergeVertices()
    }

    function Bi(t, e, i, n, r, o, s) {
        F.call(this), this.type = "SphereBufferGeometry", this.parameters = {
            radius: t,
            widthSegments: e,
            heightSegments: i,
            phiStart: n,
            phiLength: r,
            thetaStart: o,
            thetaLength: s
        }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : Math.PI;
        var l = o + s, c, h, u = 0, p = [], d = new a, f = new a, m = [], g = [], v = [], y = [];
        for (h = 0; h <= i; h++) {
            var x = [], _ = h / i;
            for (c = 0; c <= e; c++) {
                var b = c / e;
                d.x = -t * Math.cos(n + b * r) * Math.sin(o + _ * s), d.y = t * Math.cos(o + _ * s), d.z = t * Math.sin(n + b * r) * Math.sin(o + _ * s), g.push(d.x, d.y, d.z), f.set(d.x, d.y, d.z).normalize(), v.push(f.x, f.y, f.z), y.push(b, 1 - _), x.push(u++)
            }
            p.push(x)
        }
        for (h = 0; h < i; h++) for (c = 0; c < e; c++) t = p[h][c + 1], n = p[h][c], r = p[h + 1][c], s = p[h + 1][c + 1], (0 !== h || 0 < o) && m.push(t, n, s), (h !== i - 1 || l < Math.PI) && m.push(n, r, s);
        this.setIndex(m), this.addAttribute("position", new N(g, 3)), this.addAttribute("normal", new N(v, 3)), this.addAttribute("uv", new N(y, 2))
    }

    function Fi(t, e, i, n, r, a) {
        E.call(this), this.type = "RingGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: i,
            phiSegments: n,
            thetaStart: r,
            thetaLength: a
        }, this.fromBufferGeometry(new Hi(t, e, i, n, r, a)), this.mergeVertices()
    }

    function Hi(t, e, n, r, o, s) {
        F.call(this), this.type = "RingBufferGeometry", this.parameters = {
            innerRadius: t,
            outerRadius: e,
            thetaSegments: n,
            phiSegments: r,
            thetaStart: o,
            thetaLength: s
        }, t = t || .5, e = e || 1, o = void 0 !== o ? o : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8, r = void 0 !== r ? Math.max(1, r) : 1;
        var l = [], c = [], h = [], u = [], p = t, d = (e - t) / r, f = new a, m = new i, g, v;
        for (g = 0; g <= r; g++) {
            for (v = 0; v <= n; v++) t = o + v / n * s, f.x = p * Math.cos(t), f.y = p * Math.sin(t), c.push(f.x, f.y, f.z), h.push(0, 0, 1), m.x = (f.x / e + 1) / 2, m.y = (f.y / e + 1) / 2, u.push(m.x, m.y);
            p += d
        }
        for (g = 0; g < r; g++) for (e = g * (n + 1), v = 0; v < n; v++) t = v + e, o = t + n + 1, s = t + n + 2, p = t + 1, l.push(t, o, p), l.push(o, s, p);
        this.setIndex(l), this.addAttribute("position", new N(c, 3)), this.addAttribute("normal", new N(h, 3)), this.addAttribute("uv", new N(u, 2))
    }

    function Ui(t, e, i, n) {
        E.call(this), this.type = "LatheGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: i,
            phiLength: n
        }, this.fromBufferGeometry(new Gi(t, e, i, n)), this.mergeVertices()
    }

    function Gi(t, e, n, r) {
        F.call(this), this.type = "LatheBufferGeometry", this.parameters = {
            points: t,
            segments: e,
            phiStart: n,
            phiLength: r
        }, e = Math.floor(e) || 12, n = n || 0, r = r || 2 * Math.PI, r = la.clamp(r, 0, 2 * Math.PI);
        var o = [], s = [], l = [], c = 1 / e, h = new a, u = new i, p;
        for (p = 0; p <= e; p++) {
            var d = n + p * c * r, f = Math.sin(d), m = Math.cos(d);
            for (d = 0; d <= t.length - 1; d++) h.x = t[d].x * f, h.y = t[d].y, h.z = t[d].x * m, s.push(h.x, h.y, h.z), u.x = p / e, u.y = d / (t.length - 1), l.push(u.x, u.y)
        }
        for (p = 0; p < e; p++) for (d = 0; d < t.length - 1; d++) n = d + p * t.length, c = n + t.length, h = n + t.length + 1, u = n + 1, o.push(n, c, u), o.push(c, h, u);
        if (this.setIndex(o), this.addAttribute("position", new N(s, 3)), this.addAttribute("uv", new N(l, 2)), this.computeVertexNormals(), r === 2 * Math.PI) for (r = this.attributes.normal.array, o = new a, s = new a, l = new a, n = e * t.length * 3, d = p = 0; p < t.length; p++, d += 3) o.x = r[d + 0], o.y = r[d + 1], o.z = r[d + 2], s.x = r[n + d + 0], s.y = r[n + d + 1], s.z = r[n + d + 2], l.addVectors(o, s).normalize(), r[d + 0] = r[n + d + 0] = l.x, r[d + 1] = r[n + d + 1] = l.y, r[d + 2] = r[n + d + 2] = l.z
    }

    function ji(t, e) {
        E.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = {
            shapes: t,
            curveSegments: e
        }, this.fromBufferGeometry(new Vi(t, e)), this.mergeVertices()
    }

    function Vi(t, e) {
        function i(t) {
            var i, s = r.length / 3;
            t = t.extractPoints(e);
            var c = t.shape, h = t.holes;
            for (!1 === za.isClockWise(c) && (c = c.reverse()), t = 0, i = h.length; t < i; t++) {
                var u = h[t];
                !0 === za.isClockWise(u) && (h[t] = u.reverse())
            }
            var p = za.triangulateShape(c, h);
            for (t = 0, i = h.length; t < i; t++) u = h[t], c = c.concat(u);
            for (t = 0, i = c.length; t < i; t++) u = c[t], r.push(u.x, u.y, 0), a.push(0, 0, 1), o.push(u.x, u.y);
            for (t = 0, i = p.length; t < i; t++) c = p[t], n.push(c[0] + s, c[1] + s, c[2] + s), l += 3
        }

        F.call(this), this.type = "ShapeBufferGeometry", this.parameters = {shapes: t, curveSegments: e}, e = e || 12;
        var n = [], r = [], a = [], o = [], s = 0, l = 0;
        if (!1 === Array.isArray(t)) i(t); else for (var c = 0; c < t.length; c++) i(t[c]), this.addGroup(s, l, c), s += l, l = 0;
        this.setIndex(n), this.addAttribute("position", new N(r, 3)), this.addAttribute("normal", new N(a, 3)), this.addAttribute("uv", new N(o, 2))
    }

    function Wi(t, e) {
        if (e.shapes = [], Array.isArray(t)) for (var i = 0, n = t.length; i < n; i++) e.shapes.push(t[i].uuid); else e.shapes.push(t.uuid);
        return e
    }

    function qi(t, e) {
        F.call(this), this.type = "EdgesGeometry", this.parameters = {thresholdAngle: e};
        var i = [];
        e = Math.cos(la.DEG2RAD * (void 0 !== e ? e : 1));
        var n = [0, 0], r = {}, a = ["a", "b", "c"];
        if (t.isBufferGeometry) {
            var o = new E;
            o.fromBufferGeometry(t)
        } else o = t.clone();
        o.mergeVertices(), o.computeFaceNormals(), t = o.vertices, o = o.faces;
        for (var s = 0, l = o.length; s < l; s++) for (var c = o[s], h = 0; 3 > h; h++) {
            var u = c[a[h]], p = c[a[(h + 1) % 3]];
            n[0] = Math.min(u, p), n[1] = Math.max(u, p), u = n[0] + "," + n[1], void 0 === r[u] ? r[u] = {
                index1: n[0],
                index2: n[1],
                face1: s,
                face2: void 0
            } : r[u].face2 = s
        }
        for (u in r) n = r[u], (void 0 === n.face2 || o[n.face1].normal.dot(o[n.face2].normal) <= e) && (a = t[n.index1], i.push(a.x, a.y, a.z), a = t[n.index2], i.push(a.x, a.y, a.z));
        this.addAttribute("position", new N(i, 3))
    }

    function Xi(t, e, i, n, r, a, o, s) {
        E.call(this), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: i,
            radialSegments: n,
            heightSegments: r,
            openEnded: a,
            thetaStart: o,
            thetaLength: s
        }, this.fromBufferGeometry(new Yi(t, e, i, n, r, a, o, s)), this.mergeVertices()
    }

    function Yi(t, e, n, r, o, s, l, c) {
        function h(n) {
            var o, s = new i, h = new a, v = 0, _ = !0 === n ? t : e, b = !0 === n ? 1 : -1, w = g;
            for (o = 1; o <= r; o++) d.push(0, y * b, 0), f.push(0, b, 0), m.push(.5, .5), g++;
            var M = g;
            for (o = 0; o <= r; o++) {
                var T = o / r * c + l, S = Math.cos(T);
                T = Math.sin(T), h.x = _ * T, h.y = y * b, h.z = _ * S, d.push(h.x, h.y, h.z), f.push(0, b, 0), s.x = .5 * S + .5, s.y = .5 * T * b + .5, m.push(s.x, s.y), g++
            }
            for (o = 0; o < r; o++) s = w + o, h = M + o, !0 === n ? p.push(h, h + 1, s) : p.push(h + 1, h, s), v += 3;
            u.addGroup(x, v, !0 === n ? 1 : 2), x += v
        }

        F.call(this), this.type = "CylinderBufferGeometry", this.parameters = {
            radiusTop: t,
            radiusBottom: e,
            height: n,
            radialSegments: r,
            heightSegments: o,
            openEnded: s,
            thetaStart: l,
            thetaLength: c
        };
        var u = this;
        t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, r = Math.floor(r) || 8, o = Math.floor(o) || 1, s = void 0 !== s && s, l = void 0 !== l ? l : 0, c = void 0 !== c ? c : 2 * Math.PI;
        var p = [], d = [], f = [], m = [], g = 0, v = [], y = n / 2, x = 0;
        !function () {
            var i, s, h = new a, _ = new a, b = 0, w = (e - t) / n;
            for (s = 0; s <= o; s++) {
                var M = [], T = s / o, S = T * (e - t) + t;
                for (i = 0; i <= r; i++) {
                    var E = i / r, A = E * c + l, P = Math.sin(A);
                    A = Math.cos(A), _.x = S * P, _.y = -T * n + y, _.z = S * A, d.push(_.x, _.y, _.z), h.set(P, w, A).normalize(), f.push(h.x, h.y, h.z), m.push(E, 1 - T), M.push(g++)
                }
                v.push(M)
            }
            for (i = 0; i < r; i++) for (s = 0; s < o; s++) h = v[s + 1][i], _ = v[s + 1][i + 1], w = v[s][i + 1], p.push(v[s][i], h, w), p.push(h, _, w), b += 6;
            u.addGroup(x, b, 0), x += b
        }(), !1 === s && (0 < t && h(!0), 0 < e && h(!1)), this.setIndex(p), this.addAttribute("position", new N(d, 3)), this.addAttribute("normal", new N(f, 3)), this.addAttribute("uv", new N(m, 2))
    }

    function Ji(t, e, i, n, r, a, o) {
        Xi.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }

    function Zi(t, e, i, n, r, a, o) {
        Yi.call(this, 0, t, e, i, n, r, a, o), this.type = "ConeBufferGeometry", this.parameters = {
            radius: t,
            height: e,
            radialSegments: i,
            heightSegments: n,
            openEnded: r,
            thetaStart: a,
            thetaLength: o
        }
    }

    function $i(t, e, i, n) {
        E.call(this), this.type = "CircleGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: i,
            thetaLength: n
        }, this.fromBufferGeometry(new Qi(t, e, i, n)), this.mergeVertices()
    }

    function Qi(t, e, n, r) {
        F.call(this), this.type = "CircleBufferGeometry", this.parameters = {
            radius: t,
            segments: e,
            thetaStart: n,
            thetaLength: r
        }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, r = void 0 !== r ? r : 2 * Math.PI;
        var o = [], s = [], l = [], c = [], h, u = new a, p = new i;
        s.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5);
        var d = 0;
        for (h = 3; d <= e; d++, h += 3) {
            var f = n + d / e * r;
            u.x = t * Math.cos(f), u.y = t * Math.sin(f), s.push(u.x, u.y, u.z), l.push(0, 0, 1), p.x = (s[h] / t + 1) / 2, p.y = (s[h + 1] / t + 1) / 2, c.push(p.x, p.y)
        }
        for (h = 1; h <= e; h++) o.push(h, h + 1, 0);
        this.setIndex(o), this.addAttribute("position", new N(s, 3)), this.addAttribute("normal", new N(l, 3)), this.addAttribute("uv", new N(c, 2))
    }

    function Ki(t) {
        V.call(this), this.type = "ShadowMaterial", this.color = new x(0), this.transparent = !0, this.setValues(t)
    }

    function tn(t) {
        W.call(this, t), this.type = "RawShaderMaterial"
    }

    function en(t) {
        V.call(this), this.defines = {STANDARD: ""}, this.type = "MeshStandardMaterial", this.color = new x(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
    }

    function nn(t) {
        en.call(this), this.defines = {PHYSICAL: ""}, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t)
    }

    function rn(t) {
        V.call(this), this.type = "MeshPhongMaterial", this.color = new x(16777215), this.specular = new x(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
    }

    function an(t) {
        rn.call(this), this.defines = {TOON: ""}, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t)
    }

    function on(t) {
        V.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t)
    }

    function sn(t) {
        V.call(this), this.type = "MeshLambertMaterial", this.color = new x(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
    }

    function ln(t) {
        V.call(this), this.defines = {MATCAP: ""}, this.type = "MeshMatcapMaterial", this.color = new x(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t)
    }

    function cn(t) {
        Fe.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t)
    }

    function hn(t, e, i, n) {
        this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i
    }

    function un(t, e, i, n) {
        hn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0
    }

    function pn(t, e, i, n) {
        hn.call(this, t, e, i, n)
    }

    function dn(t, e, i, n) {
        hn.call(this, t, e, i, n)
    }

    function fn(t, e, i, n) {
        if (void 0 === t) throw Error("THREE.KeyframeTrack: track name is undefined");
        if (void 0 === e || 0 === e.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + t);
        this.name = t, this.times = Ha.convertArray(e, this.TimeBufferType), this.values = Ha.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation)
    }

    function mn(t, e, i) {
        fn.call(this, t, e, i)
    }

    function gn(t, e, i, n) {
        fn.call(this, t, e, i, n)
    }

    function vn(t, e, i, n) {
        fn.call(this, t, e, i, n)
    }

    function yn(t, e, i, n) {
        hn.call(this, t, e, i, n)
    }

    function xn(t, e, i, n) {
        fn.call(this, t, e, i, n)
    }

    function _n(t, e, i, n) {
        fn.call(this, t, e, i, n)
    }

    function bn(t, e, i, n) {
        fn.call(this, t, e, i, n)
    }

    function wn(t, e, i) {
        this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = la.generateUUID(), 0 > this.duration && this.resetDuration()
    }

    function Mn(t) {
        switch (t.toLowerCase()) {
            case"scalar":
            case"double":
            case"float":
            case"number":
            case"integer":
                return vn;
            case"vector":
            case"vector2":
            case"vector3":
            case"vector4":
                return bn;
            case"color":
                return gn;
            case"quaternion":
                return xn;
            case"bool":
            case"boolean":
                return mn;
            case"string":
                return _n
        }
        throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t)
    }

    function Tn(t) {
        if (void 0 === t.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse");
        var e = Mn(t.type);
        if (void 0 === t.times) {
            var i = [], n = [];
            Ha.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n
        }
        return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation)
    }

    function Sn(t, e, i) {
        var n = this, r = !1, a = 0, o = 0, s = void 0;
        this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) {
            o++, !1 === r && void 0 !== n.onStart && n.onStart(t, a, o), r = !0
        }, this.itemEnd = function (t) {
            a++, void 0 !== n.onProgress && n.onProgress(t, a, o), a === o && (r = !1, void 0 !== n.onLoad) && n.onLoad()
        }, this.itemError = function (t) {
            void 0 !== n.onError && n.onError(t)
        }, this.resolveURL = function (t) {
            return s ? s(t) : t
        }, this.setURLModifier = function (t) {
            return s = t, this
        }
    }

    function En(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function An(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function Pn(t) {
        this.manager = void 0 !== t ? t : Ga, this._parser = null
    }

    function Ln(t) {
        this.manager = void 0 !== t ? t : Ga, this._parser = null
    }

    function Cn(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function Rn(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function On(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function Dn() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }

    function In(t, e, i, n, r, a, o, s) {
        Dn.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = a || 2 * Math.PI, this.aClockwise = o || !1, this.aRotation = s || 0
    }

    function Nn(t, e, i, n, r, a) {
        In.call(this, t, e, i, i, n, r, a), this.type = "ArcCurve"
    }

    function zn() {
        var t = 0, e = 0, i = 0, n = 0;
        return {
            initCatmullRom: function (r, a, o, s, l) {
                r = l * (o - r), s = l * (s - a), t = a, e = r, i = -3 * a + 3 * o - 2 * r - s, n = 2 * a - 2 * o + r + s
            }, initNonuniformCatmullRom: function (r, a, o, s, l, c, h) {
                r = ((a - r) / l - (o - r) / (l + c) + (o - a) / c) * c, s = ((o - a) / c - (s - a) / (c + h) + (s - o) / h) * c, t = a, e = r, i = -3 * a + 3 * o - 2 * r - s, n = 2 * a - 2 * o + r + s
            }, calc: function (r) {
                var a = r * r;
                return t + e * r + i * a + n * a * r
            }
        }
    }

    function kn(t, e, i, n) {
        Dn.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5
    }

    function Bn(t, e, i, n, r) {
        e = .5 * (n - e), r = .5 * (r - i);
        var a = t * t;
        return (2 * i - 2 * n + e + r) * t * a + (-3 * i + 3 * n - 2 * e - r) * a + e * t + i
    }

    function Fn(t, e, i, n) {
        var r = 1 - t;
        return r * r * e + 2 * (1 - t) * t * i + t * t * n
    }

    function Hn(t, e, i, n, r) {
        var a = 1 - t, o = 1 - t;
        return a * a * a * e + 3 * o * o * t * i + 3 * (1 - t) * t * t * n + t * t * t * r
    }

    function Un(t, e, n, r) {
        Dn.call(this), this.type = "CubicBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i, this.v3 = r || new i
    }

    function Gn(t, e, i, n) {
        Dn.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new a, this.v1 = e || new a, this.v2 = i || new a, this.v3 = n || new a
    }

    function jn(t, e) {
        Dn.call(this), this.type = "LineCurve", this.v1 = t || new i, this.v2 = e || new i
    }

    function Vn(t, e) {
        Dn.call(this), this.type = "LineCurve3", this.v1 = t || new a, this.v2 = e || new a
    }

    function Wn(t, e, n) {
        Dn.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i
    }

    function qn(t, e, i) {
        Dn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new a, this.v1 = e || new a, this.v2 = i || new a
    }

    function Xn(t) {
        Dn.call(this), this.type = "SplineCurve", this.points = t || []
    }

    function Yn() {
        Dn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }

    function Jn(t) {
        Yn.call(this), this.type = "Path", this.currentPoint = new i, t && this.setFromPoints(t)
    }

    function Zn(t) {
        Jn.call(this, t), this.uuid = la.generateUUID(), this.type = "Shape", this.holes = []
    }

    function $n(t, e) {
        S.call(this), this.type = "Light", this.color = new x(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0
    }

    function Qn(t, e, i) {
        $n.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(S.DefaultUp), this.updateMatrix(), this.groundColor = new x(e)
    }

    function Kn(t) {
        this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new n
    }

    function tr() {
        Kn.call(this, new we(50, 1, .5, 500))
    }

    function er(t, e, i, n, r, a) {
        $n.call(this, t, e), this.type = "SpotLight", this.position.copy(S.DefaultUp), this.updateMatrix(), this.target = new S, Object.defineProperty(this, "power", {
            get: function () {
                return this.intensity * Math.PI
            }, set: function (t) {
                this.intensity = t / Math.PI
            }
        }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== a ? a : 1, this.shadow = new tr
    }

    function ir(t, e, i, n) {
        $n.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", {
            get: function () {
                return 4 * this.intensity * Math.PI
            }, set: function (t) {
                this.intensity = t / (4 * Math.PI)
            }
        }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Kn(new we(90, 1, .5, 500))
    }

    function nr(t, e, i, n, r, a) {
        be.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== a ? a : 2e3, this.updateProjectionMatrix()
    }

    function rr() {
        Kn.call(this, new nr(-5, 5, 5, -5, .5, 500))
    }

    function ar(t, e) {
        $n.call(this, t, e), this.type = "DirectionalLight", this.position.copy(S.DefaultUp), this.updateMatrix(), this.target = new S, this.shadow = new rr
    }

    function or(t, e) {
        $n.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0
    }

    function sr(t, e, i, n) {
        $n.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10
    }

    function lr(t) {
        this.manager = void 0 !== t ? t : Ga, this.textures = {}
    }

    function cr(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function hr(t) {
        this.manager = void 0 !== t ? t : Ga, this.resourcePath = ""
    }

    function ur(t) {
        "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Ga, this.options = void 0
    }

    function pr() {
        this.type = "ShapePath", this.color = new x, this.subPaths = [], this.currentPath = null
    }

    function dr(t) {
        this.type = "Font", this.data = t
    }

    function fr(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function mr() {
    }

    function gr(t) {
        this.manager = void 0 !== t ? t : Ga
    }

    function vr() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new we, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new we, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1
    }

    function yr(t, e, i, n) {
        S.call(this), this.type = "CubeCamera";
        var r = new we(90, 1, t, e);
        r.up.set(0, -1, 0), r.lookAt(new a(1, 0, 0)), this.add(r);
        var o = new we(90, 1, t, e);
        o.up.set(0, -1, 0), o.lookAt(new a(-1, 0, 0)), this.add(o);
        var s = new we(90, 1, t, e);
        s.up.set(0, 0, 1), s.lookAt(new a(0, 1, 0)), this.add(s);
        var l = new we(90, 1, t, e);
        l.up.set(0, 0, -1), l.lookAt(new a(0, -1, 0)), this.add(l);
        var c = new we(90, 1, t, e);
        c.up.set(0, -1, 0), c.lookAt(new a(0, 0, 1)), this.add(c);
        var h = new we(90, 1, t, e);
        h.up.set(0, -1, 0), h.lookAt(new a(0, 0, -1)), this.add(h), n = n || {
            format: 1022,
            magFilter: 1006,
            minFilter: 1006
        }, this.renderTarget = new u(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) {
            null === this.parent && this.updateMatrixWorld();
            var i = t.getRenderTarget(), n = this.renderTarget, a = n.texture.generateMipmaps;
            n.texture.generateMipmaps = !1, n.activeCubeFace = 0, t.render(e, r, n), n.activeCubeFace = 1, t.render(e, o, n), n.activeCubeFace = 2, t.render(e, s, n), n.activeCubeFace = 3, t.render(e, l, n), n.activeCubeFace = 4, t.render(e, c, n), n.texture.generateMipmaps = a, n.activeCubeFace = 5, t.render(e, h, n), t.setRenderTarget(i)
        }, this.clear = function (t, e, i, n) {
            for (var r = t.getRenderTarget(), a = this.renderTarget, o = 0; 6 > o; o++) a.activeCubeFace = o, t.setRenderTarget(a), t.clear(e, i, n);
            t.setRenderTarget(r)
        }
    }

    function xr(t) {
        this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1
    }

    function _r() {
        S.call(this), this.type = "AudioListener", this.context = eo.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0
    }

    function br(t) {
        S.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = []
    }

    function wr(t) {
        br.call(this, t), this.panner = this.context.createPanner(), this.panner.connect(this.gain)
    }

    function Mr(t, e) {
        this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser)
    }

    function Tr(t, e, i) {
        switch (this.binding = t, this.valueSize = i, t = Float64Array, e) {
            case"quaternion":
                e = this._slerp;
                break;
            case"string":
            case"bool":
                t = Array, e = this._select;
                break;
            default:
                e = this._lerp
        }
        this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0
    }

    function Sr(t, e, i) {
        i = i || Er.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i)
    }

    function Er(t, e, i) {
        this.path = e, this.parsedPath = i || Er.parseTrackName(e), this.node = Er.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t
    }

    function Ar() {
        this.uuid = la.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        var t = {};
        this._indicesByUUID = t;
        for (var e = 0, i = arguments.length; e !== i; ++e) t[arguments[e].uuid] = e;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        var n = this;
        this.stats = {
            objects: {
                get total() {
                    return n._objects.length
                }, get inUse() {
                    return this.total - n.nCachedObjects_
                }
            }, get bindingsPerObject() {
                return n._bindings.length
            }
        }
    }

    function Pr(t, e, i) {
        this._mixer = t, this._clip = e, this._localRoot = i || null, t = e.tracks, e = t.length, i = Array(e);
        for (var n = {endingStart: 2400, endingEnd: 2400}, r = 0; r !== e; ++r) {
            var a = t[r].createInterpolant(null);
            i[r] = a, a.settings = n
        }
        this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0
    }

    function Lr(t) {
        this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1
    }

    function Cr(t, e) {
        "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t
    }

    function Rr() {
        F.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0
    }

    function Or(t, e, i) {
        Re.call(this, t, e), this.meshPerAttribute = i || 1
    }

    function Dr(t, e, i, n) {
        "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), A.call(this, t, e, i), this.meshPerAttribute = n || 1
    }

    function Ir(t, e, i, n) {
        this.ray = new q(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = {
            Mesh: {},
            Line: {},
            LOD: {},
            Points: {threshold: 1},
            Sprite: {}
        }, Object.defineProperties(this.params, {
            PointCloud: {
                get: function () {
                    return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points
                }
            }
        })
    }

    function Nr(t, e) {
        return t.distance - e.distance
    }

    function zr(t, e, i, n) {
        if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) {
            t = t.children, n = 0;
            for (var r = t.length; n < r; n++) zr(t[n], e, i, !0)
        }
    }

    function kr(t, e, i) {
        return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this
    }

    function Br(t, e, i) {
        return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this
    }

    function Fr(t, e) {
        this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-(1 / 0), -(1 / 0))
    }

    function Hr(t, e) {
        this.start = void 0 !== t ? t : new a, this.end = void 0 !== e ? e : new a
    }

    function Ur(t) {
        S.call(this), this.material = t, this.render = function () {
        }
    }

    function Gr(t, e, i, n) {
        this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new F, e = new N(6 * e, 3), i.addAttribute("position", e), Ue.call(this, i, new Fe({
            color: t,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function jr(t, e) {
        S.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new F, e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (var i = 0, n = 1; 32 > i; i++, n++) {
            var r = i / 32 * Math.PI * 2, a = n / 32 * Math.PI * 2;
            e.push(Math.cos(r), Math.sin(r), 1, Math.cos(a), Math.sin(a), 1)
        }
        t.addAttribute("position", new N(e, 3)), e = new Fe({fog: !1}), this.cone = new Ue(t, e), this.add(this.cone), this.update()
    }

    function Vr(t) {
        var e = [];
        t && t.isBone && e.push(t);
        for (var i = 0; i < t.children.length; i++) e.push.apply(e, Vr(t.children[i]));
        return e
    }

    function Wr(t) {
        for (var e = Vr(t), i = new F, n = [], r = [], a = new x(0, 0, 1), o = new x(0, 1, 0), s = 0; s < e.length; s++) {
            var l = e[s];
            l.parent && l.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(o.r, o.g, o.b))
        }
        i.addAttribute("position", new N(n, 3)), i.addAttribute("color", new N(r, 3)), n = new Fe({
            vertexColors: 2,
            depthTest: !1,
            depthWrite: !1,
            transparent: !0
        }), Ue.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1
    }

    function qr(t, e, i) {
        this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new Bi(e, 4, 2), e = new Y({
            wireframe: !0,
            fog: !1
        }), J.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }

    function Xr(t, e) {
        this.type = "RectAreaLightHelper", this.light = t, this.color = e, t = new F, t.addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), t.computeBoundingSphere(), e = new Fe({fog: !1}), He.call(this, t, e), t = new F, t.addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), t.computeBoundingSphere(), this.add(new J(t, new Y({
            side: 1,
            fog: !1
        }))), this.update()
    }

    function Yr(t, e, i) {
        S.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, t = new ni(e), t.rotateY(.5 * Math.PI), this.material = new Y({
            wireframe: !0,
            fog: !1
        }), void 0 === this.color && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new A(e, 3)), this.add(new J(t, this.material)), this.update()
    }

    function Jr(t, e, i, n) {
        t = t || 10, e = e || 10, i = new x(void 0 !== i ? i : 4473924), n = new x(void 0 !== n ? n : 8947848);
        var r = e / 2, a = t / e, o = t / 2;
        t = [];
        for (var s = [], l = 0, c = 0, h = -o; l <= e; l++, h += a) {
            t.push(-o, 0, h, o, 0, h), t.push(h, 0, -o, h, 0, o);
            var u = l === r ? i : n;
            u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3, u.toArray(s, c), c += 3
        }
        e = new F, e.addAttribute("position", new N(t, 3)), e.addAttribute("color", new N(s, 3)), i = new Fe({vertexColors: 2}), Ue.call(this, e, i)
    }

    function Zr(t, e, i, n, r, a) {
        t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new x(void 0 !== r ? r : 4473924), a = new x(void 0 !== a ? a : 8947848);
        var o = [], s = [], l;
        for (l = 0; l <= e; l++) {
            var c = l / e * 2 * Math.PI, h = Math.sin(c) * t;
            c = Math.cos(c) * t, o.push(0, 0, 0), o.push(h, 0, c);
            var u = 1 & l ? r : a;
            s.push(u.r, u.g, u.b), s.push(u.r, u.g, u.b)
        }
        for (l = 0; l <= i; l++) {
            u = 1 & l ? r : a;
            var p = t - t / i * l;
            for (e = 0; e < n; e++) c = e / n * 2 * Math.PI, h = Math.sin(c) * p, c = Math.cos(c) * p, o.push(h, 0, c), s.push(u.r, u.g, u.b), c = (e + 1) / n * 2 * Math.PI, h = Math.sin(c) * p, c = Math.cos(c) * p, o.push(h, 0, c), s.push(u.r, u.g, u.b)
        }
        t = new F, t.addAttribute("position", new N(o, 3)), t.addAttribute("color", new N(s, 3)), o = new Fe({vertexColors: 2}), Ue.call(this, t, o)
    }

    function $r(t, e, i, n) {
        this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new F, e = new N(6 * e, 3), i.addAttribute("position", e), Ue.call(this, i, new Fe({
            color: t,
            linewidth: n
        })), this.matrixAutoUpdate = !1, this.update()
    }

    function Qr(t, e, i) {
        S.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1), t = new F, t.addAttribute("position", new N([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)), e = new Fe({fog: !1}), this.lightPlane = new He(t, e),
            this.add(this.lightPlane), t = new F, t.addAttribute("position", new N([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new He(t, e), this.add(this.targetLine), this.update()
    }

    function Kr(t) {
        function e(t, e, n) {
            i(t, n), i(e, n)
        }

        function i(t, e) {
            a.push(0, 0, 0), o.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(a.length / 3 - 1)
        }

        var n = new F, r = new Fe({color: 16777215, vertexColors: 1}), a = [], o = [], s = {}, l = new x(16755200),
            c = new x(16711680), h = new x(43775), u = new x(16777215), p = new x(3355443);
        e("n1", "n2", l), e("n2", "n4", l), e("n4", "n3", l), e("n3", "n1", l), e("f1", "f2", l), e("f2", "f4", l), e("f4", "f3", l), e("f3", "f1", l), e("n1", "f1", l), e("n2", "f2", l), e("n3", "f3", l), e("n4", "f4", l), e("p", "n1", c), e("p", "n2", c), e("p", "n3", c), e("p", "n4", c), e("u1", "u2", h), e("u2", "u3", h), e("u3", "u1", h), e("c", "t", u), e("p", "c", p), e("cn1", "cn2", p), e("cn3", "cn4", p), e("cf1", "cf2", p), e("cf3", "cf4", p), n.addAttribute("position", new N(a, 3)), n.addAttribute("color", new N(o, 3)), Ue.call(this, n, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update()
    }

    function ta(t, e) {
        this.object = t, void 0 === e && (e = 16776960), t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new Float32Array(24), n = new F;
        n.setIndex(new A(t, 1)), n.addAttribute("position", new A(i, 3)), Ue.call(this, n, new Fe({color: e})), this.matrixAutoUpdate = !1, this.update()
    }

    function ea(t, e) {
        this.type = "Box3Helper", this.box = t, t = void 0 !== e ? e : 16776960, e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
        var i = new F;
        i.setIndex(new A(e, 1)), i.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ue.call(this, i, new Fe({color: t})), this.geometry.computeBoundingSphere()
    }

    function ia(t, e, i) {
        this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e, t = void 0 !== i ? i : 16776960, e = new F, e.addAttribute("position", new N([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), e.computeBoundingSphere(), He.call(this, e, new Fe({color: t})), e = new F, e.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), e.computeBoundingSphere(), this.add(new J(e, new Y({
            color: t,
            opacity: .2,
            transparent: !0,
            depthWrite: !1
        })))
    }

    function na(t, e, i, n, r, o) {
        S.call(this), void 0 === t && (t = new a(0, 0, 1)), void 0 === e && (e = new a(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === r && (r = .2 * i), void 0 === o && (o = .2 * r), void 0 === io && (io = new F, io.addAttribute("position", new N([0, 0, 0, 0, 1, 0], 3)), no = new Yi(0, .5, 1, 5, 1), no.translate(0, -.5, 0)), this.position.copy(e), this.line = new He(io, new Fe({color: n})), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new J(no, new Y({color: n})), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, r, o)
    }

    function ra(t) {
        t = t || 1;
        var e = [0, 0, 0, t, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t];
        t = new F, t.addAttribute("position", new N(e, 3)), t.addAttribute("color", new N([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), e = new Fe({vertexColors: 2}), Ue.call(this, t, e)
    }

    function aa(t) {
        console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), kn.call(this, t), this.type = "catmullrom", this.closed = !0
    }

    function oa(t) {
        console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), kn.call(this, t), this.type = "catmullrom"
    }

    function sa(t) {
        console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), kn.call(this, t), this.type = "catmullrom"
    }

    void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) {
        return "number" == typeof t && isFinite(t) && Math.floor(t) === t
    }), void 0 === Math.sign && (Math.sign = function (t) {
        return 0 > t ? -1 : 0 < t ? 1 : +t
    }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", {
        get: function () {
            return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1]
        }
    }), void 0 === Object.assign && function () {
        Object.assign = function (t) {
            if (void 0 === t || null === t) throw new TypeError("Cannot convert undefined or null to object");
            for (var e = Object(t), i = 1; i < arguments.length; i++) {
                var n = arguments[i];
                if (void 0 !== n && null !== n) for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
            }
            return e
        }
    }(), Object.assign(e.prototype, {
        addEventListener: function (t, e) {
            void 0 === this._listeners && (this._listeners = {});
            var i = this._listeners;
            void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e)
        }, hasEventListener: function (t, e) {
            if (void 0 === this._listeners) return !1;
            var i = this._listeners;
            return void 0 !== i[t] && -1 !== i[t].indexOf(e)
        }, removeEventListener: function (t, e) {
            void 0 !== this._listeners && void 0 !== (t = this._listeners[t]) && -1 !== (e = t.indexOf(e)) && t.splice(e, 1)
        }, dispatchEvent: function (t) {
            if (void 0 !== this._listeners) {
                var e = this._listeners[t.type];
                if (void 0 !== e) {
                    t.target = this, e = e.slice(0);
                    for (var i = 0, n = e.length; i < n; i++) e[i].call(this, t)
                }
            }
        }
    });
    var la = {
        DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () {
            for (var t = [], e = 0; 256 > e; e++) t[e] = (16 > e ? "0" : "") + e.toString(16);
            return function () {
                var e = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0,
                    n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0;
                return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase()
            }
        }(), clamp: function (t, e, i) {
            return Math.max(e, Math.min(i, t))
        }, euclideanModulo: function (t, e) {
            return (t % e + e) % e
        }, mapLinear: function (t, e, i, n, r) {
            return n + (t - e) * (r - n) / (i - e)
        }, lerp: function (t, e, i) {
            return (1 - i) * t + i * e
        }, smoothstep: function (t, e, i) {
            return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t)
        }, smootherstep: function (t, e, i) {
            return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10)
        }, randInt: function (t, e) {
            return t + Math.floor(Math.random() * (e - t + 1))
        }, randFloat: function (t, e) {
            return t + Math.random() * (e - t)
        }, randFloatSpread: function (t) {
            return t * (.5 - Math.random())
        }, degToRad: function (t) {
            return t * la.DEG2RAD
        }, radToDeg: function (t) {
            return t * la.RAD2DEG
        }, isPowerOfTwo: function (t) {
            return 0 == (t & t - 1) && 0 !== t
        }, ceilPowerOfTwo: function (t) {
            return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2))
        }, floorPowerOfTwo: function (t) {
            return Math.pow(2, Math.floor(Math.log(t) / Math.LN2))
        }
    };
    Object.defineProperties(i.prototype, {
        width: {
            get: function () {
                return this.x
            }, set: function (t) {
                this.x = t
            }
        }, height: {
            get: function () {
                return this.y
            }, set: function (t) {
                this.y = t
            }
        }
    }), Object.assign(i.prototype, {
        isVector2: !0, set: function (t, e) {
            return this.x = t, this.y = e, this
        }, setScalar: function (t) {
            return this.y = this.x = t, this
        }, setX: function (t) {
            return this.x = t, this
        }, setY: function (t) {
            return this.y = t, this
        }, setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                default:
                    throw Error("index is out of range: " + t)
            }
            return this
        }, getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                default:
                    throw Error("index is out of range: " + t)
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y)
        }, copy: function (t) {
            return this.x = t.x, this.y = t.y, this
        }, add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this)
        }, addScalar: function (t) {
            return this.x += t, this.y += t, this
        }, addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this
        }, addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this
        }, sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this)
        }, subScalar: function (t) {
            return this.x -= t, this.y -= t, this
        }, subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this
        }, multiply: function (t) {
            return this.x *= t.x, this.y *= t.y, this
        }, multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this
        }, divide: function (t) {
            return this.x /= t.x, this.y /= t.y, this
        }, divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        }, applyMatrix3: function (t) {
            var e = this.x, i = this.y;
            return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this
        }, min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this
        }, max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this
        }, clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this
        }, clampScalar: function () {
            var t = new i, e = new i;
            return function (i, n) {
                return t.set(i, i), e.set(n, n), this.clamp(t, e)
            }
        }(), clampLength: function (t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }, floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
        }, ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
        }, round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this
        }, roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this
        }, negate: function () {
            return this.x = -this.x, this.y = -this.y, this
        }, dot: function (t) {
            return this.x * t.x + this.y * t.y
        }, cross: function (t) {
            return this.x * t.y - this.y * t.x
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y)
        }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y)
        }, normalize: function () {
            return this.divideScalar(this.length() || 1)
        }, angle: function () {
            var t = Math.atan2(this.y, this.x);
            return 0 > t && (t += 2 * Math.PI), t
        }, distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t))
        }, distanceToSquared: function (t) {
            var e = this.x - t.x;
            return t = this.y - t.y, e * e + t * t
        }, manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y)
        }, setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        }, lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this
        }, lerpVectors: function (t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        }, equals: function (t) {
            return t.x === this.x && t.y === this.y
        }, fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this
        }, toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t
        }, fromBufferAttribute: function (t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this
        }, rotateAround: function (t, e) {
            var i = Math.cos(e);
            e = Math.sin(e);
            var n = this.x - t.x, r = this.y - t.y;
            return this.x = n * i - r * e + t.x, this.y = n * e + r * i + t.y, this
        }
    }), Object.assign(n.prototype, {
        isMatrix4: !0, set: function (t, e, i, n, r, a, o, s, l, c, h, u, p, d, f, m) {
            var g = this.elements;
            return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = a, g[9] = o, g[13] = s, g[2] = l, g[6] = c, g[10] = h, g[14] = u, g[3] = p, g[7] = d, g[11] = f, g[15] = m, this
        }, identity: function () {
            return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }, clone: function () {
            return (new n).fromArray(this.elements)
        }, copy: function (t) {
            var e = this.elements;
            return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this
        }, copyPosition: function (t) {
            var e = this.elements;
            return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this
        }, extractBasis: function (t, e, i) {
            return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
        }, makeBasis: function (t, e, i) {
            return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this
        }, extractRotation: function () {
            var t = new a;
            return function (e) {
                var i = this.elements, n = e.elements, r = 1 / t.setFromMatrixColumn(e, 0).length(),
                    a = 1 / t.setFromMatrixColumn(e, 1).length();
                return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * a, i[5] = n[5] * a, i[6] = n[6] * a, i[7] = 0, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this
            }
        }(), makeRotationFromEuler: function (t) {
            t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.");
            var e = this.elements, i = t.x, n = t.y, r = t.z, a = Math.cos(i);
            i = Math.sin(i);
            var o = Math.cos(n);
            n = Math.sin(n);
            var s = Math.cos(r);
            if (r = Math.sin(r), "XYZ" === t.order) {
                t = a * s;
                var l = a * r, c = i * s, h = i * r;
                e[0] = o * s, e[4] = -o * r, e[8] = n, e[1] = l + c * n, e[5] = t - h * n, e[9] = -i * o, e[2] = h - t * n, e[6] = c + l * n, e[10] = a * o
            } else "YXZ" === t.order ? (t = o * s, l = o * r, c = n * s, h = n * r, e[0] = t + h * i, e[4] = c * i - l, e[8] = a * n, e[1] = a * r, e[5] = a * s, e[9] = -i, e[2] = l * i - c, e[6] = h + t * i, e[10] = a * o) : "ZXY" === t.order ? (t = o * s, l = o * r, c = n * s, h = n * r, e[0] = t - h * i, e[4] = -a * r, e[8] = c + l * i, e[1] = l + c * i, e[5] = a * s, e[9] = h - t * i, e[2] = -a * n, e[6] = i, e[10] = a * o) : "ZYX" === t.order ? (t = a * s, l = a * r, c = i * s, h = i * r, e[0] = o * s, e[4] = c * n - l, e[8] = t * n + h, e[1] = o * r, e[5] = h * n + t, e[9] = l * n - c, e[2] = -n, e[6] = i * o, e[10] = a * o) : "YZX" === t.order ? (t = a * o, l = a * n, c = i * o, h = i * n, e[0] = o * s, e[4] = h - t * r, e[8] = c * r + l, e[1] = r, e[5] = a * s, e[9] = -i * s, e[2] = -n * s, e[6] = l * r + c, e[10] = t - h * r) : "XZY" === t.order && (t = a * o, l = a * n, c = i * o, h = i * n, e[0] = o * s, e[4] = -r, e[8] = n * s, e[1] = t * r + h, e[5] = a * s, e[9] = l * r - c, e[2] = c * r - l, e[6] = i * s, e[10] = h * r + t);
            return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this
        }, makeRotationFromQuaternion: function () {
            var t = new a(0, 0, 0), e = new a(1, 1, 1);
            return function (i) {
                return this.compose(t, i, e)
            }
        }(), lookAt: function () {
            var t = new a, e = new a, i = new a;
            return function (n, r, a) {
                var o = this.elements;
                return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(a, i), 0 === t.lengthSq() && (1 === Math.abs(a.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(a, i)), t.normalize(), e.crossVectors(i, t), o[0] = t.x, o[4] = e.x, o[8] = i.x, o[1] = t.y, o[5] = e.y, o[9] = i.y, o[2] = t.z, o[6] = e.z, o[10] = i.z, this
            }
        }(), multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t)
        }, premultiply: function (t) {
            return this.multiplyMatrices(t, this)
        }, multiplyMatrices: function (t, e) {
            var i = t.elements, n = e.elements;
            e = this.elements, t = i[0];
            var r = i[4], a = i[8], o = i[12], s = i[1], l = i[5], c = i[9], h = i[13], u = i[2], p = i[6], d = i[10],
                f = i[14], m = i[3], g = i[7], v = i[11];
            i = i[15];
            var y = n[0], x = n[4], _ = n[8], b = n[12], w = n[1], M = n[5], T = n[9], S = n[13], E = n[2], A = n[6],
                P = n[10], L = n[14], C = n[3], R = n[7], O = n[11];
            return n = n[15], e[0] = t * y + r * w + a * E + o * C, e[4] = t * x + r * M + a * A + o * R, e[8] = t * _ + r * T + a * P + o * O, e[12] = t * b + r * S + a * L + o * n, e[1] = s * y + l * w + c * E + h * C, e[5] = s * x + l * M + c * A + h * R, e[9] = s * _ + l * T + c * P + h * O, e[13] = s * b + l * S + c * L + h * n, e[2] = u * y + p * w + d * E + f * C, e[6] = u * x + p * M + d * A + f * R, e[10] = u * _ + p * T + d * P + f * O, e[14] = u * b + p * S + d * L + f * n, e[3] = m * y + g * w + v * E + i * C, e[7] = m * x + g * M + v * A + i * R, e[11] = m * _ + g * T + v * P + i * O, e[15] = m * b + g * S + v * L + i * n, this
        }, multiplyScalar: function (t) {
            var e = this.elements;
            return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this
        }, applyToBufferAttribute: function () {
            var t = new a;
            return function (e) {
                for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(), determinant: function () {
            var t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], a = t[1], o = t[5], s = t[9], l = t[13],
                c = t[2], h = t[6], u = t[10], p = t[14];
            return t[3] * (+r * s * h - n * l * h - r * o * u + i * l * u + n * o * p - i * s * p) + t[7] * (+e * s * p - e * l * u + r * a * u - n * a * p + n * l * c - r * s * c) + t[11] * (+e * l * h - e * o * p - r * a * h + i * a * p + r * o * c - i * l * c) + t[15] * (-n * o * c - e * s * h + e * o * u + n * a * h - i * a * u + i * s * c)
        }, transpose: function () {
            var t = this.elements, e = t[1];
            return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this
        }, setPosition: function (t) {
            var e = this.elements;
            return e[12] = t.x, e[13] = t.y, e[14] = t.z, this
        }, getInverse: function (t, e) {
            var i = this.elements, n = t.elements;
            t = n[0];
            var r = n[1], a = n[2], o = n[3], s = n[4], l = n[5], c = n[6], h = n[7], u = n[8], p = n[9], d = n[10],
                f = n[11], m = n[12], g = n[13], v = n[14];
            n = n[15];
            var y = p * v * h - g * d * h + g * c * f - l * v * f - p * c * n + l * d * n,
                x = m * d * h - u * v * h - m * c * f + s * v * f + u * c * n - s * d * n,
                _ = u * g * h - m * p * h + m * l * f - s * g * f - u * l * n + s * p * n,
                b = m * p * c - u * g * c - m * l * d + s * g * d + u * l * v - s * p * v,
                w = t * y + r * x + a * _ + o * b;
            if (0 === w) {
                if (!0 === e) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return e = 1 / w, i[0] = y * e, i[1] = (g * d * o - p * v * o - g * a * f + r * v * f + p * a * n - r * d * n) * e, i[2] = (l * v * o - g * c * o + g * a * h - r * v * h - l * a * n + r * c * n) * e, i[3] = (p * c * o - l * d * o - p * a * h + r * d * h + l * a * f - r * c * f) * e, i[4] = x * e, i[5] = (u * v * o - m * d * o + m * a * f - t * v * f - u * a * n + t * d * n) * e, i[6] = (m * c * o - s * v * o - m * a * h + t * v * h + s * a * n - t * c * n) * e, i[7] = (s * d * o - u * c * o + u * a * h - t * d * h - s * a * f + t * c * f) * e, i[8] = _ * e, i[9] = (m * p * o - u * g * o - m * r * f + t * g * f + u * r * n - t * p * n) * e, i[10] = (s * g * o - m * l * o + m * r * h - t * g * h - s * r * n + t * l * n) * e, i[11] = (u * l * o - s * p * o - u * r * h + t * p * h + s * r * f - t * l * f) * e, i[12] = b * e, i[13] = (u * g * a - m * p * a + m * r * d - t * g * d - u * r * v + t * p * v) * e, i[14] = (m * l * a - s * g * a - m * r * c + t * g * c + s * r * v - t * l * v) * e, i[15] = (s * p * a - u * l * a + u * r * c - t * p * c - s * r * d + t * l * d) * e, this
        }, scale: function (t) {
            var e = this.elements, i = t.x, n = t.y;
            return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this
        }, getMaxScaleOnAxis: function () {
            var t = this.elements;
            return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10]))
        }, makeTranslation: function (t, e, i) {
            return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this
        }, makeRotationX: function (t) {
            var e = Math.cos(t);
            return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this
        }, makeRotationY: function (t) {
            var e = Math.cos(t);
            return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this
        }, makeRotationZ: function (t) {
            var e = Math.cos(t);
            return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
        }, makeRotationAxis: function (t, e) {
            var i = Math.cos(e);
            e = Math.sin(e);
            var n = 1 - i, r = t.x, a = t.y;
            t = t.z;
            var o = n * r, s = n * a;
            return this.set(o * r + i, o * a - e * t, o * t + e * a, 0, o * a + e * t, s * a + i, s * t - e * r, 0, o * t - e * a, s * t + e * r, n * t * t + i, 0, 0, 0, 0, 1), this
        }, makeScale: function (t, e, i) {
            return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
        }, makeShear: function (t, e, i) {
            return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this
        }, compose: function (t, e, i) {
            var n = this.elements, r = e._x, a = e._y, o = e._z, s = e._w, l = r + r, c = a + a, h = o + o;
            e = r * l;
            var u = r * c;
            r *= h;
            var p = a * c;
            a *= h, o *= h, l *= s, c *= s, s *= h, h = i.x;
            var d = i.y;
            return i = i.z, n[0] = (1 - (p + o)) * h, n[1] = (u + s) * h, n[2] = (r - c) * h, n[3] = 0, n[4] = (u - s) * d, n[5] = (1 - (e + o)) * d, n[6] = (a + l) * d, n[7] = 0, n[8] = (r + c) * i, n[9] = (a - l) * i, n[10] = (1 - (e + p)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this
        }, decompose: function () {
            var t = new a, e = new n;
            return function (i, n, r) {
                var a = this.elements, o = t.set(a[0], a[1], a[2]).length(), s = t.set(a[4], a[5], a[6]).length(),
                    l = t.set(a[8], a[9], a[10]).length();
                0 > this.determinant() && (o = -o), i.x = a[12], i.y = a[13], i.z = a[14], e.copy(this), i = 1 / o, a = 1 / s;
                var c = 1 / l;
                return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= a, e.elements[5] *= a, e.elements[6] *= a, e.elements[8] *= c, e.elements[9] *= c, e.elements[10] *= c, n.setFromRotationMatrix(e), r.x = o, r.y = s, r.z = l, this
            }
        }(), makePerspective: function (t, e, i, n, r, a) {
            void 0 === a && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.");
            var o = this.elements;
            return o[0] = 2 * r / (e - t), o[4] = 0, o[8] = (e + t) / (e - t), o[12] = 0, o[1] = 0, o[5] = 2 * r / (i - n), o[9] = (i + n) / (i - n), o[13] = 0, o[2] = 0, o[6] = 0, o[10] = -(a + r) / (a - r), o[14] = -2 * a * r / (a - r), o[3] = 0, o[7] = 0, o[11] = -1, o[15] = 0, this
        }, makeOrthographic: function (t, e, i, n, r, a) {
            var o = this.elements, s = 1 / (e - t), l = 1 / (i - n), c = 1 / (a - r);
            return o[0] = 2 * s, o[4] = 0, o[8] = 0, o[12] = -((e + t) * s), o[1] = 0, o[5] = 2 * l, o[9] = 0, o[13] = -((i + n) * l), o[2] = 0, o[6] = 0, o[10] = -2 * c, o[14] = -((a + r) * c), o[3] = 0, o[7] = 0, o[11] = 0, o[15] = 1, this
        }, equals: function (t) {
            var e = this.elements;
            t = t.elements;
            for (var i = 0; 16 > i; i++) if (e[i] !== t[i]) return !1;
            return !0
        }, fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; 16 > i; i++) this.elements[i] = t[i + e];
            return this
        }, toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t
        }
    }), Object.assign(r, {
        slerp: function (t, e, i, n) {
            return i.copy(t).slerp(e, n)
        }, slerpFlat: function (t, e, i, n, r, a, o) {
            var s = i[n + 0], l = i[n + 1], c = i[n + 2];
            i = i[n + 3], n = r[a + 0];
            var h = r[a + 1], u = r[a + 2];
            if (r = r[a + 3], i !== r || s !== n || l !== h || c !== u) {
                a = 1 - o;
                var p = s * n + l * h + c * u + i * r, d = 0 <= p ? 1 : -1, f = 1 - p * p;
                f > Number.EPSILON && (f = Math.sqrt(f), p = Math.atan2(f, p * d), a = Math.sin(a * p) / f, o = Math.sin(o * p) / f), d *= o, s = s * a + n * d, l = l * a + h * d, c = c * a + u * d, i = i * a + r * d, a === 1 - o && (o = 1 / Math.sqrt(s * s + l * l + c * c + i * i), s *= o, l *= o, c *= o, i *= o)
            }
            t[e] = s, t[e + 1] = l, t[e + 2] = c, t[e + 3] = i
        }
    }), Object.defineProperties(r.prototype, {
        x: {
            get: function () {
                return this._x
            }, set: function (t) {
                this._x = t, this.onChangeCallback()
            }
        }, y: {
            get: function () {
                return this._y
            }, set: function (t) {
                this._y = t, this.onChangeCallback()
            }
        }, z: {
            get: function () {
                return this._z
            }, set: function (t) {
                this._z = t, this.onChangeCallback()
            }
        }, w: {
            get: function () {
                return this._w
            }, set: function (t) {
                this._w = t, this.onChangeCallback()
            }
        }
    }), Object.assign(r.prototype, {
        isQuaternion: !0, set: function (t, e, i, n) {
            return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this
        }, clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._w)
        }, copy: function (t) {
            return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this
        }, setFromEuler: function (t, e) {
            if (!t || !t.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");
            var i = t._x, n = t._y, r = t._z;
            t = t.order;
            var a = Math.cos, o = Math.sin, s = a(i / 2), l = a(n / 2);
            return a = a(r / 2), i = o(i / 2), n = o(n / 2), r = o(r / 2), "XYZ" === t ? (this._x = i * l * a + s * n * r, this._y = s * n * a - i * l * r, this._z = s * l * r + i * n * a, this._w = s * l * a - i * n * r) : "YXZ" === t ? (this._x = i * l * a + s * n * r, this._y = s * n * a - i * l * r, this._z = s * l * r - i * n * a, this._w = s * l * a + i * n * r) : "ZXY" === t ? (this._x = i * l * a - s * n * r, this._y = s * n * a + i * l * r, this._z = s * l * r + i * n * a, this._w = s * l * a - i * n * r) : "ZYX" === t ? (this._x = i * l * a - s * n * r, this._y = s * n * a + i * l * r, this._z = s * l * r - i * n * a, this._w = s * l * a + i * n * r) : "YZX" === t ? (this._x = i * l * a + s * n * r, this._y = s * n * a + i * l * r, this._z = s * l * r - i * n * a, this._w = s * l * a - i * n * r) : "XZY" === t && (this._x = i * l * a - s * n * r, this._y = s * n * a - i * l * r, this._z = s * l * r + i * n * a, this._w = s * l * a + i * n * r), !1 !== e && this.onChangeCallback(), this
        }, setFromAxisAngle: function (t, e) {
            e /= 2;
            var i = Math.sin(e);
            return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this
        }, setFromRotationMatrix: function (t) {
            var e = t.elements, i = e[0];
            t = e[4];
            var n = e[8], r = e[1], a = e[5], o = e[9], s = e[2], l = e[6];
            e = e[10];
            var c = i + a + e;
            return 0 < c ? (i = .5 / Math.sqrt(c + 1), this._w = .25 / i, this._x = (l - o) * i, this._y = (n - s) * i, this._z = (r - t) * i) : i > a && i > e ? (i = 2 * Math.sqrt(1 + i - a - e), this._w = (l - o) / i, this._x = .25 * i, this._y = (t + r) / i, this._z = (n + s) / i) : a > e ? (i = 2 * Math.sqrt(1 + a - i - e), this._w = (n - s) / i, this._x = (t + r) / i, this._y = .25 * i, this._z = (o + l) / i) : (i = 2 * Math.sqrt(1 + e - i - a), this._w = (r - t) / i, this._x = (n + s) / i, this._y = (o + l) / i, this._z = .25 * i), this.onChangeCallback(), this
        }, setFromUnitVectors: function () {
            var t = new a, e;
            return function (i, n) {
                return void 0 === t && (t = new a), e = i.dot(n) + 1, 1e-6 > e ? (e = 0, Math.abs(i.x) > Math.abs(i.z) ? t.set(-i.y, i.x, 0) : t.set(0, -i.z, i.y)) : t.crossVectors(i, n), this._x = t.x, this._y = t.y, this._z = t.z, this._w = e, this.normalize()
            }
        }(), angleTo: function (t) {
            return 2 * Math.acos(Math.abs(la.clamp(this.dot(t), -1, 1)))
        }, rotateTowards: function (t, e) {
            var i = this.angleTo(t);
            return 0 === i ? this : (this.slerp(t, Math.min(1, e / i)), this)
        }, inverse: function () {
            return this.conjugate()
        }, conjugate: function () {
            return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this
        }, dot: function (t) {
            return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w
        }, lengthSq: function () {
            return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
        }, length: function () {
            return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
        }, normalize: function () {
            var t = this.length();
            return 0 === t ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this
        }, multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t)
        }, premultiply: function (t) {
            return this.multiplyQuaternions(t, this)
        }, multiplyQuaternions: function (t, e) {
            var i = t._x, n = t._y, r = t._z;
            t = t._w;
            var a = e._x, o = e._y, s = e._z;
            return e = e._w, this._x = i * e + t * a + n * s - r * o, this._y = n * e + t * o + r * a - i * s, this._z = r * e + t * s + i * o - n * a, this._w = t * e - i * a - n * o - r * s, this.onChangeCallback(), this
        }, slerp: function (t, e) {
            if (0 === e) return this;
            if (1 === e) return this.copy(t);
            var i = this._x, n = this._y, r = this._z, a = this._w, o = a * t._w + i * t._x + n * t._y + r * t._z;
            if (0 > o ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, o = -o) : this.copy(t), 1 <= o) return this._w = a, this._x = i, this._y = n, this._z = r, this;
            if ((t = 1 - o * o) <= Number.EPSILON) return o = 1 - e, this._w = o * a + e * this._w, this._x = o * i + e * this._x, this._y = o * n + e * this._y, this._z = o * r + e * this._z, this.normalize();
            t = Math.sqrt(t);
            var s = Math.atan2(t, o);
            return o = Math.sin((1 - e) * s) / t, e = Math.sin(e * s) / t, this._w = a * o + this._w * e, this._x = i * o + this._x * e, this._y = n * o + this._y * e, this._z = r * o + this._z * e, this.onChangeCallback(), this
        }, equals: function (t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w
        }, fromArray: function (t, e) {
            return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this
        }, toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t
        }, onChange: function (t) {
            return this.onChangeCallback = t, this
        }, onChangeCallback: function () {
        }
    }), Object.assign(a.prototype, {
        isVector3: !0, set: function (t, e, i) {
            return this.x = t, this.y = e, this.z = i, this
        }, setScalar: function (t) {
            return this.z = this.y = this.x = t, this
        }, setX: function (t) {
            return this.x = t, this
        }, setY: function (t) {
            return this.y = t, this
        }, setZ: function (t) {
            return this.z = t, this
        }, setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                default:
                    throw Error("index is out of range: " + t)
            }
            return this
        }, getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                default:
                    throw Error("index is out of range: " + t)
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y, this.z)
        }, copy: function (t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this
        }, add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this)
        }, addScalar: function (t) {
            return this.x += t, this.y += t, this.z += t, this
        }, addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this
        }, addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this
        }, sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this)
        }, subScalar: function (t) {
            return this.x -= t, this.y -= t, this.z -= t, this
        }, subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this
        }, multiply: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this)
        }, multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this.z *= t, this
        }, multiplyVectors: function (t, e) {
            return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this
        }, applyEuler: function () {
            var t = new r;
            return function (e) {
                return e && e.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(t.setFromEuler(e))
            }
        }(), applyAxisAngle: function () {
            var t = new r;
            return function (e, i) {
                return this.applyQuaternion(t.setFromAxisAngle(e, i))
            }
        }(), applyMatrix3: function (t) {
            var e = this.x, i = this.y, n = this.z;
            return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this
        }, applyMatrix4: function (t) {
            var e = this.x, i = this.y, n = this.z;
            t = t.elements;
            var r = 1 / (t[3] * e + t[7] * i + t[11] * n + t[15]);
            return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * r, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * r, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * r, this
        }, applyQuaternion: function (t) {
            var e = this.x, i = this.y, n = this.z, r = t.x, a = t.y, o = t.z;
            t = t.w;
            var s = t * e + a * n - o * i, l = t * i + o * e - r * n, c = t * n + r * i - a * e;
            return e = -r * e - a * i - o * n, this.x = s * t + e * -r + l * -o - c * -a, this.y = l * t + e * -a + c * -r - s * -o, this.z = c * t + e * -o + s * -a - l * -r, this
        }, project: function (t) {
            return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)
        }, unproject: function () {
            var t = new n;
            return function (e) {
                return this.applyMatrix4(t.getInverse(e.projectionMatrix)).applyMatrix4(e.matrixWorld)
            }
        }(), transformDirection: function (t) {
            var e = this.x, i = this.y, n = this.z;
            return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize()
        }, divide: function (t) {
            return this.x /= t.x, this.y /= t.y, this.z /= t.z, this
        }, divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        }, min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this
        }, max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this
        }, clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this
        }, clampScalar: function () {
            var t = new a, e = new a;
            return function (i, n) {
                return t.set(i, i, i), e.set(n, n, n), this.clamp(t, e)
            }
        }(), clampLength: function (t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }, floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
        }, ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
        }, round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
        }, roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this
        }, negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
        }, dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
        }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
        }, normalize: function () {
            return this.divideScalar(this.length() || 1)
        }, setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        }, lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this
        }, lerpVectors: function (t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        }, cross: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t)
        }, crossVectors: function (t, e) {
            var i = t.x, n = t.y;
            t = t.z;
            var r = e.x, a = e.y;
            return e = e.z, this.x = n * e - t * a, this.y = t * r - i * e, this.z = i * a - n * r, this
        }, projectOnVector: function (t) {
            var e = t.dot(this) / t.lengthSq();
            return this.copy(t).multiplyScalar(e)
        }, projectOnPlane: function () {
            var t = new a;
            return function (e) {
                return t.copy(this).projectOnVector(e), this.sub(t)
            }
        }(), reflect: function () {
            var t = new a;
            return function (e) {
                return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e)))
            }
        }(), angleTo: function (t) {
            return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(la.clamp(t, -1, 1))
        }, distanceTo: function (t) {
            return Math.sqrt(this.distanceToSquared(t))
        }, distanceToSquared: function (t) {
            var e = this.x - t.x, i = this.y - t.y;
            return t = this.z - t.z, e * e + i * i + t * t
        }, manhattanDistanceTo: function (t) {
            return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z)
        }, setFromSpherical: function (t) {
            return this.setFromSphericalCoords(t.radius, t.phi, t.theta)
        }, setFromSphericalCoords: function (t, e, i) {
            var n = Math.sin(e) * t;
            return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this
        }, setFromCylindrical: function (t) {
            return this.setFromCylindricalCoords(t.radius, t.theta, t.y)
        }, setFromCylindricalCoords: function (t, e, i) {
            return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this
        }, setFromMatrixPosition: function (t) {
            return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this
        }, setFromMatrixScale: function (t) {
            var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length();
            return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this
        },
        setFromMatrixColumn: function (t, e) {
            return this.fromArray(t.elements, 4 * e)
        }, equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z
        }, fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this
        }, toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t
        }, fromBufferAttribute: function (t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this
        }
    }), Object.assign(o.prototype, {
        isMatrix3: !0, set: function (t, e, i, n, r, a, o, s, l) {
            var c = this.elements;
            return c[0] = t, c[1] = n, c[2] = o, c[3] = e, c[4] = r, c[5] = s, c[6] = i, c[7] = a, c[8] = l, this
        }, identity: function () {
            return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
        }, clone: function () {
            return (new this.constructor).fromArray(this.elements)
        }, copy: function (t) {
            var e = this.elements;
            return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this
        }, setFromMatrix4: function (t) {
            return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
        }, applyToBufferAttribute: function () {
            var t = new a;
            return function (e) {
                for (var i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z);
                return e
            }
        }(), multiply: function (t) {
            return this.multiplyMatrices(this, t)
        }, premultiply: function (t) {
            return this.multiplyMatrices(t, this)
        }, multiplyMatrices: function (t, e) {
            var i = t.elements, n = e.elements;
            e = this.elements, t = i[0];
            var r = i[3], a = i[6], o = i[1], s = i[4], l = i[7], c = i[2], h = i[5];
            i = i[8];
            var u = n[0], p = n[3], d = n[6], f = n[1], m = n[4], g = n[7], v = n[2], y = n[5];
            return n = n[8], e[0] = t * u + r * f + a * v, e[3] = t * p + r * m + a * y, e[6] = t * d + r * g + a * n, e[1] = o * u + s * f + l * v, e[4] = o * p + s * m + l * y, e[7] = o * d + s * g + l * n, e[2] = c * u + h * f + i * v, e[5] = c * p + h * m + i * y, e[8] = c * d + h * g + i * n, this
        }, multiplyScalar: function (t) {
            var e = this.elements;
            return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this
        }, determinant: function () {
            var t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], a = t[4], o = t[5], s = t[6], l = t[7];
            return t = t[8], e * a * t - e * o * l - i * r * t + i * o * s + n * r * l - n * a * s
        }, getInverse: function (t, e) {
            t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument.");
            var i = t.elements;
            t = this.elements;
            var n = i[0], r = i[1], a = i[2], o = i[3], s = i[4], l = i[5], c = i[6], h = i[7];
            i = i[8];
            var u = i * s - l * h, p = l * c - i * o, d = h * o - s * c, f = n * u + r * p + a * d;
            if (0 === f) {
                if (!0 === e) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0");
                return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity()
            }
            return e = 1 / f, t[0] = u * e, t[1] = (a * h - i * r) * e, t[2] = (l * r - a * s) * e, t[3] = p * e, t[4] = (i * n - a * c) * e, t[5] = (a * o - l * n) * e, t[6] = d * e, t[7] = (r * c - h * n) * e, t[8] = (s * n - r * o) * e, this
        }, transpose: function () {
            var t = this.elements, e = t[1];
            return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
        }, getNormalMatrix: function (t) {
            return this.setFromMatrix4(t).getInverse(this).transpose()
        }, transposeIntoArray: function (t) {
            var e = this.elements;
            return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this
        }, setUvTransform: function (t, e, i, n, r, a, o) {
            var s = Math.cos(r);
            r = Math.sin(r), this.set(i * s, i * r, -i * (s * a + r * o) + a + t, -n * r, n * s, -n * (-r * a + s * o) + o + e, 0, 0, 1)
        }, scale: function (t, e) {
            var i = this.elements;
            return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this
        }, rotate: function (t) {
            var e = Math.cos(t);
            t = Math.sin(t);
            var i = this.elements, n = i[0], r = i[3], a = i[6], o = i[1], s = i[4], l = i[7];
            return i[0] = e * n + t * o, i[3] = e * r + t * s, i[6] = e * a + t * l, i[1] = -t * n + e * o, i[4] = -t * r + e * s, i[7] = -t * a + e * l, this
        }, translate: function (t, e) {
            var i = this.elements;
            return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this
        }, equals: function (t) {
            var e = this.elements;
            t = t.elements;
            for (var i = 0; 9 > i; i++) if (e[i] !== t[i]) return !1;
            return !0
        }, fromArray: function (t, e) {
            void 0 === e && (e = 0);
            for (var i = 0; 9 > i; i++) this.elements[i] = t[i + e];
            return this
        }, toArray: function (t, e) {
            void 0 === t && (t = []), void 0 === e && (e = 0);
            var i = this.elements;
            return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t
        }
    });
    var ca, ha = {
        getDataURL: function (t) {
            if ("undefined" == typeof HTMLCanvasElement) return t.src;
            if (!(t instanceof HTMLCanvasElement)) {
                void 0 === ca && (ca = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), ca.width = t.width, ca.height = t.height;
                var e = ca.getContext("2d");
                t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), t = ca
            }
            return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png")
        }
    }, ua = 0;
    s.DEFAULT_IMAGE = void 0, s.DEFAULT_MAPPING = 300, s.prototype = Object.assign(Object.create(e.prototype), {
        constructor: s, isTexture: !0, updateMatrix: function () {
            this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this
        }, toJSON: function (t) {
            var e = void 0 === t || "string" == typeof t;
            if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid];
            var i = {
                metadata: {version: 4.5, type: "Texture", generator: "Texture.toJSON"},
                uuid: this.uuid,
                name: this.name,
                mapping: this.mapping,
                repeat: [this.repeat.x, this.repeat.y],
                offset: [this.offset.x, this.offset.y],
                center: [this.center.x, this.center.y],
                rotation: this.rotation,
                wrap: [this.wrapS, this.wrapT],
                format: this.format,
                type: this.type,
                encoding: this.encoding,
                minFilter: this.minFilter,
                magFilter: this.magFilter,
                anisotropy: this.anisotropy,
                flipY: this.flipY,
                premultiplyAlpha: this.premultiplyAlpha,
                unpackAlignment: this.unpackAlignment
            };
            if (void 0 !== this.image) {
                var n = this.image;
                if (void 0 === n.uuid && (n.uuid = la.generateUUID()), !e && void 0 === t.images[n.uuid]) {
                    if (Array.isArray(n)) for (var r = [], a = 0, o = n.length; a < o; a++) r.push(ha.getDataURL(n[a])); else r = ha.getDataURL(n);
                    t.images[n.uuid] = {uuid: n.uuid, url: r}
                }
                i.image = n.uuid
            }
            return e || (t.textures[this.uuid] = i), i
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }, transformUv: function (t) {
            if (300 !== this.mapping) return t;
            if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x) switch (this.wrapS) {
                case 1e3:
                    t.x -= Math.floor(t.x);
                    break;
                case 1001:
                    t.x = 0 > t.x ? 0 : 1;
                    break;
                case 1002:
                    t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x)
            }
            if (0 > t.y || 1 < t.y) switch (this.wrapT) {
                case 1e3:
                    t.y -= Math.floor(t.y);
                    break;
                case 1001:
                    t.y = 0 > t.y ? 0 : 1;
                    break;
                case 1002:
                    t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y)
            }
            return this.flipY && (t.y = 1 - t.y), t
        }
    }), Object.defineProperty(s.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.assign(l.prototype, {
        isVector4: !0, set: function (t, e, i, n) {
            return this.x = t, this.y = e, this.z = i, this.w = n, this
        }, setScalar: function (t) {
            return this.w = this.z = this.y = this.x = t, this
        }, setX: function (t) {
            return this.x = t, this
        }, setY: function (t) {
            return this.y = t, this
        }, setZ: function (t) {
            return this.z = t, this
        }, setW: function (t) {
            return this.w = t, this
        }, setComponent: function (t, e) {
            switch (t) {
                case 0:
                    this.x = e;
                    break;
                case 1:
                    this.y = e;
                    break;
                case 2:
                    this.z = e;
                    break;
                case 3:
                    this.w = e;
                    break;
                default:
                    throw Error("index is out of range: " + t)
            }
            return this
        }, getComponent: function (t) {
            switch (t) {
                case 0:
                    return this.x;
                case 1:
                    return this.y;
                case 2:
                    return this.z;
                case 3:
                    return this.w;
                default:
                    throw Error("index is out of range: " + t)
            }
        }, clone: function () {
            return new this.constructor(this.x, this.y, this.z, this.w)
        }, copy: function (t) {
            return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this
        }, add: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this)
        }, addScalar: function (t) {
            return this.x += t, this.y += t, this.z += t, this.w += t, this
        }, addVectors: function (t, e) {
            return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this
        }, addScaledVector: function (t, e) {
            return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this
        }, sub: function (t, e) {
            return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this)
        }, subScalar: function (t) {
            return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this
        }, subVectors: function (t, e) {
            return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this
        }, multiplyScalar: function (t) {
            return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this
        }, applyMatrix4: function (t) {
            var e = this.x, i = this.y, n = this.z, r = this.w;
            return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * r, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * r, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * r, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * r, this
        }, divideScalar: function (t) {
            return this.multiplyScalar(1 / t)
        }, setAxisAngleFromQuaternion: function (t) {
            this.w = 2 * Math.acos(t.w);
            var e = Math.sqrt(1 - t.w * t.w);
            return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this
        }, setAxisAngleFromRotationMatrix: function (t) {
            t = t.elements;
            var e = t[0], i = t[4], n = t[8], r = t[1], a = t[5], o = t[9], s = t[2], l = t[6], c = t[10];
            return .01 > Math.abs(i - r) && .01 > Math.abs(n - s) && .01 > Math.abs(o - l) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + s) && .1 > Math.abs(o + l) && .1 > Math.abs(e + a + c - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, e = (e + 1) / 2, a = (a + 1) / 2, c = (c + 1) / 2, i = (i + r) / 4, n = (n + s) / 4, o = (o + l) / 4, e > a && e > c ? .01 > e ? (l = 0, i = s = .707106781) : (l = Math.sqrt(e), s = i / l, i = n / l) : a > c ? .01 > a ? (l = .707106781, s = 0, i = .707106781) : (s = Math.sqrt(a), l = i / s, i = o / s) : .01 > c ? (s = l = .707106781, i = 0) : (i = Math.sqrt(c), l = n / i, s = o / i), this.set(l, s, i, t), this) : (t = Math.sqrt((l - o) * (l - o) + (n - s) * (n - s) + (r - i) * (r - i)), .001 > Math.abs(t) && (t = 1), this.x = (l - o) / t, this.y = (n - s) / t, this.z = (r - i) / t, this.w = Math.acos((e + a + c - 1) / 2), this)
        }, min: function (t) {
            return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this
        }, max: function (t) {
            return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this
        }, clamp: function (t, e) {
            return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this
        }, clampScalar: function () {
            var t, e;
            return function (i, n) {
                return void 0 === t && (t = new l, e = new l), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e)
            }
        }(), clampLength: function (t, e) {
            var i = this.length();
            return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i)))
        }, floor: function () {
            return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
        }, ceil: function () {
            return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
        }, round: function () {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
        }, roundToZero: function () {
            return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this
        }, negate: function () {
            return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
        }, dot: function (t) {
            return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w
        }, lengthSq: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
        }, length: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
        }, manhattanLength: function () {
            return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
        }, normalize: function () {
            return this.divideScalar(this.length() || 1)
        }, setLength: function (t) {
            return this.normalize().multiplyScalar(t)
        }, lerp: function (t, e) {
            return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this
        }, lerpVectors: function (t, e, i) {
            return this.subVectors(e, t).multiplyScalar(i).add(t)
        }, equals: function (t) {
            return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w
        }, fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this
        }, toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t
        }, fromBufferAttribute: function (t, e, i) {
            return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this
        }
    }), c.prototype = Object.assign(Object.create(e.prototype), {
        constructor: c,
        isWebGLRenderTarget: !0,
        setSize: function (t, e) {
            this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e)
        },
        clone: function () {
            return (new this.constructor).copy(this)
        },
        copy: function (t) {
            return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this
        },
        dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), h.prototype = Object.assign(Object.create(c.prototype), {
        constructor: h,
        isWebGLMultisampleRenderTarget: !0,
        copy: function (t) {
            return c.prototype.copy.call(this, t), this.samples = t.samples, this
        }
    }), u.prototype = Object.create(c.prototype), u.prototype.constructor = u, u.prototype.isWebGLRenderTargetCube = !0, p.prototype = Object.create(s.prototype), p.prototype.constructor = p, p.prototype.isDataTexture = !0, Object.assign(d.prototype, {
        isBox3: !0, set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this
        }, setFromArray: function (t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = t.length; s < l; s += 3) {
                var c = t[s], h = t[s + 1], u = t[s + 2];
                c < e && (e = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > a && (a = h), u > o && (o = u)
            }
            return this.min.set(e, i, n), this.max.set(r, a, o), this
        }, setFromBufferAttribute: function (t) {
            for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -(1 / 0), a = -(1 / 0), o = -(1 / 0), s = 0, l = t.count; s < l; s++) {
                var c = t.getX(s), h = t.getY(s), u = t.getZ(s);
                c < e && (e = c), h < i && (i = h), u < n && (n = u), c > r && (r = c), h > a && (a = h), u > o && (o = u)
            }
            return this.min.set(e, i, n), this.max.set(r, a, o), this
        }, setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
            return this
        }, setFromCenterAndSize: function () {
            var t = new a;
            return function (e, i) {
                return i = t.copy(i).multiplyScalar(.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this
            }
        }(), setFromObject: function (t) {
            return this.makeEmpty(), this.expandByObject(t)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        }, makeEmpty: function () {
            return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -(1 / 0), this
        }, isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
        }, getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new a), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }, getSize: function (t) {
            return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new a), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min)
        }, expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this
        }, expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this
        }, expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        }, expandByObject: function () {
            function t(t) {
                var a = t.geometry;
                if (void 0 !== a) if (a.isGeometry) for (a = a.vertices, i = 0, n = a.length; i < n; i++) r.copy(a[i]), r.applyMatrix4(t.matrixWorld), e.expandByPoint(r); else if (a.isBufferGeometry && void 0 !== (a = a.attributes.position)) for (i = 0, n = a.count; i < n; i++) r.fromBufferAttribute(a, i).applyMatrix4(t.matrixWorld), e.expandByPoint(r)
            }

            var e, i, n, r = new a;
            return function (i) {
                return e = this, i.updateMatrixWorld(!0), i.traverse(t), this
            }
        }(), containsPoint: function (t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z)
        }, containsBox: function (t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z
        }, getParameter: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new a), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z))
        }, intersectsBox: function (t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z)
        }, intersectsSphere: function () {
            var t = new a;
            return function (e) {
                return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius
            }
        }(), intersectsPlane: function (t) {
            if (0 < t.normal.x) var e = t.normal.x * this.min.x,
                i = t.normal.x * this.max.x; else e = t.normal.x * this.max.x, i = t.normal.x * this.min.x;
            return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant
        }, intersectsTriangle: function () {
            function t(t) {
                var r, a = 0;
                for (r = t.length - 3; a <= r; a += 3) {
                    l.fromArray(t, a);
                    var o = h.x * Math.abs(l.x) + h.y * Math.abs(l.y) + h.z * Math.abs(l.z), s = e.dot(l), c = i.dot(l),
                        u = n.dot(l);
                    if (Math.max(-Math.max(s, c, u), Math.min(s, c, u)) > o) return !1
                }
                return !0
            }

            var e = new a, i = new a, n = new a, r = new a, o = new a, s = new a, l = new a, c = new a, h = new a,
                u = new a;
            return function (a) {
                return !this.isEmpty() && (this.getCenter(c), h.subVectors(this.max, c), e.subVectors(a.a, c), i.subVectors(a.b, c), n.subVectors(a.c, c), r.subVectors(i, e), o.subVectors(n, i), s.subVectors(e, n), a = [0, -r.z, r.y, 0, -o.z, o.y, 0, -s.z, s.y, r.z, 0, -r.x, o.z, 0, -o.x, s.z, 0, -s.x, -r.y, r.x, 0, -o.y, o.x, 0, -s.y, s.x, 0], !!t(a) && (a = [1, 0, 0, 0, 1, 0, 0, 0, 1], !!t(a) && (u.crossVectors(r, o), a = [u.x, u.y, u.z], t(a))))
            }
        }(), clampPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new a), e.copy(t).clamp(this.min, this.max)
        }, distanceToPoint: function () {
            var t = new a;
            return function (e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(), getBoundingSphere: function () {
            var t = new a;
            return function (e) {
                return void 0 === e && (console.warn("THREE.Box3: .getBoundingSphere() target is now required"), e = new f), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e
            }
        }(), intersect: function (t) {
            return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this
        }, union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this
        }, applyMatrix4: function () {
            var t = [new a, new a, new a, new a, new a, new a, new a, new a];
            return function (e) {
                return this.isEmpty() ? this : (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t), this)
            }
        }(), translate: function (t) {
            return this.min.add(t), this.max.add(t), this
        }, equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), Object.assign(f.prototype, {
        set: function (t, e) {
            return this.center.copy(t), this.radius = e, this
        }, setFromPoints: function () {
            var t = new d;
            return function (e, i) {
                var n = this.center;
                void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n);
                for (var r = i = 0, a = e.length; r < a; r++) i = Math.max(i, n.distanceToSquared(e[r]));
                return this.radius = Math.sqrt(i), this
            }
        }(), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.center.copy(t.center), this.radius = t.radius, this
        }, empty: function () {
            return 0 >= this.radius
        }, containsPoint: function (t) {
            return t.distanceToSquared(this.center) <= this.radius * this.radius
        }, distanceToPoint: function (t) {
            return t.distanceTo(this.center) - this.radius
        }, intersectsSphere: function (t) {
            var e = this.radius + t.radius;
            return t.center.distanceToSquared(this.center) <= e * e
        }, intersectsBox: function (t) {
            return t.intersectsSphere(this)
        }, intersectsPlane: function (t) {
            return Math.abs(t.distanceToPoint(this.center)) <= this.radius
        }, clampPoint: function (t, e) {
            var i = this.center.distanceToSquared(t);
            return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new a), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e
        }, getBoundingBox: function (t) {
            return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new d), t.set(this.center, this.center), t.expandByScalar(this.radius), t
        }, applyMatrix4: function (t) {
            return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this
        }, translate: function (t) {
            return this.center.add(t), this
        }, equals: function (t) {
            return t.center.equals(this.center) && t.radius === this.radius
        }
    }), Object.assign(m.prototype, {
        set: function (t, e) {
            return this.normal.copy(t), this.constant = e, this
        }, setComponents: function (t, e, i, n) {
            return this.normal.set(t, e, i), this.constant = n, this
        }, setFromNormalAndCoplanarPoint: function (t, e) {
            return this.normal.copy(t), this.constant = -e.dot(this.normal), this
        }, setFromCoplanarPoints: function () {
            var t = new a, e = new a;
            return function (i, n, r) {
                return n = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this
            }
        }(), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.normal.copy(t.normal), this.constant = t.constant, this
        }, normalize: function () {
            var t = 1 / this.normal.length();
            return this.normal.multiplyScalar(t), this.constant *= t, this
        }, negate: function () {
            return this.constant *= -1, this.normal.negate(), this
        }, distanceToPoint: function (t) {
            return this.normal.dot(t) + this.constant
        }, distanceToSphere: function (t) {
            return this.distanceToPoint(t.center) - t.radius
        }, projectPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new a), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t)
        }, intersectLine: function () {
            var t = new a;
            return function (e, i) {
                void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new a);
                var n = e.delta(t), r = this.normal.dot(n);
                if (0 === r) {
                    if (0 === this.distanceToPoint(e.start)) return i.copy(e.start)
                } else if (!(0 > (r = -(e.start.dot(this.normal) + this.constant) / r) || 1 < r)) return i.copy(n).multiplyScalar(r).add(e.start)
            }
        }(), intersectsLine: function (t) {
            var e = this.distanceToPoint(t.start);
            return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e
        }, intersectsBox: function (t) {
            return t.intersectsPlane(this)
        }, intersectsSphere: function (t) {
            return t.intersectsPlane(this)
        }, coplanarPoint: function (t) {
            return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new a), t.copy(this.normal).multiplyScalar(-this.constant)
        }, applyMatrix4: function () {
            var t = new a, e = new o;
            return function (i, n) {
                return n = n || e.getNormalMatrix(i), i = this.coplanarPoint(t).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this
            }
        }(), translate: function (t) {
            return this.constant -= t.dot(this.normal), this
        }, equals: function (t) {
            return t.normal.equals(this.normal) && t.constant === this.constant
        }
    }), Object.assign(g.prototype, {
        set: function (t, e, i, n, r, a) {
            var o = this.planes;
            return o[0].copy(t), o[1].copy(e), o[2].copy(i), o[3].copy(n), o[4].copy(r), o[5].copy(a), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            for (var e = this.planes, i = 0; 6 > i; i++) e[i].copy(t.planes[i]);
            return this
        }, setFromMatrix: function (t) {
            var e = this.planes, i = t.elements;
            t = i[0];
            var n = i[1], r = i[2], a = i[3], o = i[4], s = i[5], l = i[6], c = i[7], h = i[8], u = i[9], p = i[10],
                d = i[11], f = i[12], m = i[13], g = i[14];
            return i = i[15], e[0].setComponents(a - t, c - o, d - h, i - f).normalize(), e[1].setComponents(a + t, c + o, d + h, i + f).normalize(), e[2].setComponents(a + n, c + s, d + u, i + m).normalize(), e[3].setComponents(a - n, c - s, d - u, i - m).normalize(), e[4].setComponents(a - r, c - l, d - p, i - g).normalize(), e[5].setComponents(a + r, c + l, d + p, i + g).normalize(), this
        }, intersectsObject: function () {
            var t = new f;
            return function (e) {
                var i = e.geometry;
                return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(), intersectsSprite: function () {
            var t = new f;
            return function (e) {
                return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t)
            }
        }(), intersectsSphere: function (t) {
            var e = this.planes, i = t.center;
            t = -t.radius;
            for (var n = 0; 6 > n; n++) if (e[n].distanceToPoint(i) < t) return !1;
            return !0
        }, intersectsBox: function () {
            var t = new a;
            return function (e) {
                for (var i = this.planes, n = 0; 6 > n; n++) {
                    var r = i[n];
                    if (t.x = 0 < r.normal.x ? e.max.x : e.min.x, t.y = 0 < r.normal.y ? e.max.y : e.min.y, t.z = 0 < r.normal.z ? e.max.z : e.min.z, 0 > r.distanceToPoint(t)) return !1
                }
                return !0
            }
        }(), containsPoint: function (t) {
            for (var e = this.planes, i = 0; 6 > i; i++) if (0 > e[i].distanceToPoint(t)) return !1;
            return !0
        }
    });
    var pa = {
        alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif",
        alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
        alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif",
        aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif",
        aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
        begin_vertex: "vec3 transformed = vec3( position );",
        beginnormal_vertex: "vec3 objectNormal = vec3( normal );",
        bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}",
        bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
        clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
        clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
        clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif",
        clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif",
        color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif",
        color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif",
        color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif",
        common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}",
        cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif",
        defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif",
        displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
        displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif",
        emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
        emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
        encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
        encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}",
        envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
        envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
        envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
        envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif",
        envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
        fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif",
        fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif",
        fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
        fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
        gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif",
        lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif",
        lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
        lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif",
        lights_pars_begin: "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif",
        lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
        lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
        lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif",
        lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
        lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif",
        lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif",
        lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif",
        logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
        logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif",
        logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
        logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif",
        map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif",
        map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
        map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif",
        map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif",
        metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
        metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
        morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif",
        morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif",
        morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif",
        normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif",
        normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif",
        normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif",
        packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
        premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
        project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;",
        dithering_fragment: "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
        dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
        roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
        roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
        shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
        shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif",
        shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif",
        shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}",
        skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
        skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif",
        skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
        skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif",
        specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
        specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
        tonemapping_fragment: "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
        tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}",
        uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif",
        uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif",
        uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",
        uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",
        uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif",
        uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif",
        worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif",
        background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
        cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
        depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}",
        depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}",
        distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
        distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
        equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}",
        equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
        linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
        meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
        meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
        meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
        meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}",
        normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
        points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
        shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}",
        shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
        sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}",
        sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}"
    }, da = {clone: v, merge: y}, fa = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Object.assign(x.prototype, {
        isColor: !0, r: 1, g: 1, b: 1, set: function (t) {
            return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this
        }, setScalar: function (t) {
            return this.b = this.g = this.r = t, this
        }, setHex: function (t) {
            return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this
        }, setRGB: function (t, e, i) {
            return this.r = t, this.g = e, this.b = i, this
        }, setHSL: function () {
            function t(t, e, i) {
                return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : .5 > i ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t
            }

            return function (e, i, n) {
                return e = la.euclideanModulo(e, 1), i = la.clamp(i, 0, 1), n = la.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (i = .5 >= n ? n * (1 + i) : n + i - n * i, n = 2 * n - i, this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this
            }
        }(), setStyle: function (t) {
            function e(e) {
                void 0 !== e && 1 > parseFloat(e) && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.")
            }

            var i;
            if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) {
                var n = i[2];
                switch (i[1]) {
                    case"rgb":
                    case"rgba":
                        if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this;
                        if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this;
                        break;
                    case"hsl":
                    case"hsla":
                        if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) {
                            n = parseFloat(i[1]) / 360;
                            var r = parseInt(i[2], 10) / 100, a = parseInt(i[3], 10) / 100;
                            return e(i[5]), this.setHSL(n, r, a)
                        }
                }
            } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) {
                if (i = i[1], 3 === (n = i.length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this;
                if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this
            }
            return t && 0 < t.length && (i = fa[t], void 0 !== i ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this
        }, clone: function () {
            return new this.constructor(this.r, this.g, this.b)
        }, copy: function (t) {
            return this.r = t.r, this.g = t.g, this.b = t.b, this
        }, copyGammaToLinear: function (t, e) {
            return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        }, copyLinearToGamma: function (t, e) {
            return void 0 === e && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this
        }, convertGammaToLinear: function (t) {
            return this.copyGammaToLinear(this, t), this
        }, convertLinearToGamma: function (t) {
            return this.copyLinearToGamma(this, t), this
        }, copySRGBToLinear: function () {
            function t(t) {
                return .04045 > t ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4)
            }

            return function (e) {
                return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
            }
        }(), copyLinearToSRGB: function () {
            function t(t) {
                return .0031308 > t ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055
            }

            return function (e) {
                return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this
            }
        }(), convertSRGBToLinear: function () {
            return this.copySRGBToLinear(this), this
        }, convertLinearToSRGB: function () {
            return this.copyLinearToSRGB(this), this
        }, getHex: function () {
            return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0
        }, getHexString: function () {
            return ("000000" + this.getHex().toString(16)).slice(-6)
        }, getHSL: function (t) {
            void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = {h: 0, s: 0, l: 0});
            var e = this.r, i = this.g, n = this.b, r = Math.max(e, i, n), a = Math.min(e, i, n), o, s = (a + r) / 2;
            if (a === r) a = o = 0; else {
                var l = r - a;
                switch (a = .5 >= s ? l / (r + a) : l / (2 - r - a), r) {
                    case e:
                        o = (i - n) / l + (i < n ? 6 : 0);
                        break;
                    case i:
                        o = (n - e) / l + 2;
                        break;
                    case n:
                        o = (e - i) / l + 4
                }
                o /= 6
            }
            return t.h = o, t.s = a, t.l = s, t
        }, getStyle: function () {
            return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")"
        }, offsetHSL: function () {
            var t = {};
            return function (e, i, n) {
                return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this
            }
        }(), add: function (t) {
            return this.r += t.r, this.g += t.g, this.b += t.b, this
        }, addColors: function (t, e) {
            return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this
        }, addScalar: function (t) {
            return this.r += t, this.g += t, this.b += t, this
        }, sub: function (t) {
            return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this
        }, multiply: function (t) {
            return this.r *= t.r, this.g *= t.g, this.b *= t.b, this
        }, multiplyScalar: function (t) {
            return this.r *= t, this.g *= t, this.b *= t, this
        }, lerp: function (t, e) {
            return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this
        }, lerpHSL: function () {
            var t = {h: 0, s: 0, l: 0}, e = {h: 0, s: 0, l: 0};
            return function (i, n) {
                this.getHSL(t), i.getHSL(e), i = la.lerp(t.h, e.h, n);
                var r = la.lerp(t.s, e.s, n);
                return n = la.lerp(t.l, e.l, n), this.setHSL(i, r, n), this
            }
        }(), equals: function (t) {
            return t.r === this.r && t.g === this.g && t.b === this.b
        }, fromArray: function (t, e) {
            return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this
        }, toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t
        }, toJSON: function () {
            return this.getHex()
        }
    });
    var ma = {
        common: {
            diffuse: {value: new x(15658734)},
            opacity: {value: 1},
            map: {value: null},
            uvTransform: {value: new o},
            alphaMap: {value: null}
        },
        specularmap: {specularMap: {value: null}},
        envmap: {
            envMap: {value: null},
            flipEnvMap: {value: -1},
            reflectivity: {value: 1},
            refractionRatio: {value: .98},
            maxMipLevel: {value: 0}
        },
        aomap: {aoMap: {value: null}, aoMapIntensity: {value: 1}},
        lightmap: {lightMap: {value: null}, lightMapIntensity: {value: 1}},
        emissivemap: {emissiveMap: {value: null}},
        bumpmap: {bumpMap: {value: null}, bumpScale: {value: 1}},
        normalmap: {normalMap: {value: null}, normalScale: {value: new i(1, 1)}},
        displacementmap: {displacementMap: {value: null}, displacementScale: {value: 1}, displacementBias: {value: 0}},
        roughnessmap: {roughnessMap: {value: null}},
        metalnessmap: {metalnessMap: {value: null}},
        gradientmap: {gradientMap: {value: null}},
        fog: {
            fogDensity: {value: 25e-5},
            fogNear: {value: 1},
            fogFar: {value: 2e3},
            fogColor: {value: new x(16777215)}
        },
        lights: {
            ambientLightColor: {value: []},
            directionalLights: {
                value: [],
                properties: {direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}}
            },
            directionalShadowMap: {value: []},
            directionalShadowMatrix: {value: []},
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotShadowMap: {value: []},
            spotShadowMatrix: {value: []},
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {},
                    shadow: {},
                    shadowBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {value: []},
            pointShadowMatrix: {value: []},
            hemisphereLights: {value: [], properties: {direction: {}, skyColor: {}, groundColor: {}}},
            rectAreaLights: {value: [], properties: {color: {}, position: {}, width: {}, height: {}}}
        },
        points: {
            diffuse: {value: new x(15658734)},
            opacity: {value: 1},
            size: {value: 1},
            scale: {value: 1},
            map: {value: null},
            uvTransform: {value: new o}
        },
        sprite: {
            diffuse: {value: new x(15658734)},
            opacity: {value: 1},
            center: {value: new i(.5, .5)},
            rotation: {value: 0},
            map: {value: null},
            uvTransform: {value: new o}
        }
    }, ga = {
        basic: {
            uniforms: y([ma.common, ma.specularmap, ma.envmap, ma.aomap, ma.lightmap, ma.fog]),
            vertexShader: pa.meshbasic_vert,
            fragmentShader: pa.meshbasic_frag
        },
        lambert: {
            uniforms: y([ma.common, ma.specularmap, ma.envmap, ma.aomap, ma.lightmap, ma.emissivemap, ma.fog, ma.lights, {emissive: {value: new x(0)}}]),
            vertexShader: pa.meshlambert_vert,
            fragmentShader: pa.meshlambert_frag
        },
        phong: {
            uniforms: y([ma.common, ma.specularmap, ma.envmap, ma.aomap, ma.lightmap, ma.emissivemap, ma.bumpmap, ma.normalmap, ma.displacementmap, ma.gradientmap, ma.fog, ma.lights, {
                emissive: {value: new x(0)},
                specular: {value: new x(1118481)},
                shininess: {value: 30}
            }]), vertexShader: pa.meshphong_vert, fragmentShader: pa.meshphong_frag
        },
        standard: {
            uniforms: y([ma.common, ma.envmap, ma.aomap, ma.lightmap, ma.emissivemap, ma.bumpmap, ma.normalmap, ma.displacementmap, ma.roughnessmap, ma.metalnessmap, ma.fog, ma.lights, {
                emissive: {value: new x(0)},
                roughness: {value: .5},
                metalness: {value: .5},
                envMapIntensity: {value: 1}
            }]), vertexShader: pa.meshphysical_vert, fragmentShader: pa.meshphysical_frag
        },
        matcap: {
            uniforms: y([ma.common, ma.bumpmap, ma.normalmap, ma.displacementmap, ma.fog, {matcap: {value: null}}]),
            vertexShader: pa.meshmatcap_vert,
            fragmentShader: pa.meshmatcap_frag
        },
        points: {uniforms: y([ma.points, ma.fog]), vertexShader: pa.points_vert, fragmentShader: pa.points_frag},
        dashed: {
            uniforms: y([ma.common, ma.fog, {scale: {value: 1}, dashSize: {value: 1}, totalSize: {value: 2}}]),
            vertexShader: pa.linedashed_vert,
            fragmentShader: pa.linedashed_frag
        },
        depth: {
            uniforms: y([ma.common, ma.displacementmap]),
            vertexShader: pa.depth_vert,
            fragmentShader: pa.depth_frag
        },
        normal: {
            uniforms: y([ma.common, ma.bumpmap, ma.normalmap, ma.displacementmap, {opacity: {value: 1}}]),
            vertexShader: pa.normal_vert,
            fragmentShader: pa.normal_frag
        },
        sprite: {uniforms: y([ma.sprite, ma.fog]), vertexShader: pa.sprite_vert, fragmentShader: pa.sprite_frag},
        background: {
            uniforms: {uvTransform: {value: new o}, t2D: {value: null}},
            vertexShader: pa.background_vert,
            fragmentShader: pa.background_frag
        },
        cube: {
            uniforms: {tCube: {value: null}, tFlip: {value: -1}, opacity: {value: 1}},
            vertexShader: pa.cube_vert,
            fragmentShader: pa.cube_frag
        },
        equirect: {
            uniforms: {tEquirect: {value: null}},
            vertexShader: pa.equirect_vert,
            fragmentShader: pa.equirect_frag
        },
        distanceRGBA: {
            uniforms: y([ma.common, ma.displacementmap, {
                referencePosition: {value: new a},
                nearDistance: {value: 1},
                farDistance: {value: 1e3}
            }]), vertexShader: pa.distanceRGBA_vert, fragmentShader: pa.distanceRGBA_frag
        },
        shadow: {
            uniforms: y([ma.lights, ma.fog, {color: {value: new x(0)}, opacity: {value: 1}}]),
            vertexShader: pa.shadow_vert,
            fragmentShader: pa.shadow_frag
        }
    };
    ga.physical = {
        uniforms: y([ga.standard.uniforms, {clearCoat: {value: 0}, clearCoatRoughness: {value: 0}}]),
        vertexShader: pa.meshphysical_vert,
        fragmentShader: pa.meshphysical_frag
    }, Object.assign(w.prototype, {
        clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex;
            for (var e = 0, i = t.vertexNormals.length; e < i; e++) this.vertexNormals[e] = t.vertexNormals[e].clone();
            for (e = 0, i = t.vertexColors.length; e < i; e++) this.vertexColors[e] = t.vertexColors[e].clone();
            return this
        }
    }), M.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), M.DefaultOrder = "XYZ", Object.defineProperties(M.prototype, {
        x: {
            get: function () {
                return this._x
            }, set: function (t) {
                this._x = t, this.onChangeCallback()
            }
        }, y: {
            get: function () {
                return this._y
            }, set: function (t) {
                this._y = t, this.onChangeCallback()
            }
        }, z: {
            get: function () {
                return this._z
            }, set: function (t) {
                this._z = t, this.onChangeCallback()
            }
        }, order: {
            get: function () {
                return this._order
            }, set: function (t) {
                this._order = t, this.onChangeCallback()
            }
        }
    }), Object.assign(M.prototype, {
        isEuler: !0, set: function (t, e, i, n) {
            return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this
        }, clone: function () {
            return new this.constructor(this._x, this._y, this._z, this._order)
        }, copy: function (t) {
            return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this
        }, setFromRotationMatrix: function (t, e, i) {
            var n = la.clamp, r = t.elements;
            t = r[0];
            var a = r[4], o = r[8], s = r[1], l = r[5], c = r[9], h = r[2], u = r[6];
            return r = r[10], e = e || this._order, "XYZ" === e ? (this._y = Math.asin(n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(-c, r), this._z = Math.atan2(-a, t)) : (this._x = Math.atan2(u, l), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(c, -1, 1)), .99999 > Math.abs(c) ? (this._y = Math.atan2(o, r), this._z = Math.atan2(s, l)) : (this._y = Math.atan2(-h, t), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-h, r), this._z = Math.atan2(-a, l)) : (this._y = 0, this._z = Math.atan2(s, t))) : "ZYX" === e ? (this._y = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, t)) : (this._x = 0, this._z = Math.atan2(-a, l))) : "YZX" === e ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-c, l), this._y = Math.atan2(-h, t)) : (this._x = 0, this._y = Math.atan2(o, r))) : "XZY" === e ? (this._z = Math.asin(-n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(u, l), this._y = Math.atan2(o, t)) : (this._x = Math.atan2(-c, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this
        }, setFromQuaternion: function () {
            var t = new n;
            return function (e, i, n) {
                return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n)
            }
        }(), setFromVector3: function (t, e) {
            return this.set(t.x, t.y, t.z, e || this._order)
        }, reorder: function () {
            var t = new r;
            return function (e) {
                return t.setFromEuler(this), this.setFromQuaternion(t, e)
            }
        }(), equals: function (t) {
            return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order
        }, fromArray: function (t) {
            return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this
        }, toArray: function (t, e) {
            return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t
        }, toVector3: function (t) {
            return t ? t.set(this._x, this._y, this._z) : new a(this._x, this._y, this._z)
        }, onChange: function (t) {
            return this.onChangeCallback = t, this
        }, onChangeCallback: function () {
        }
    }), Object.assign(T.prototype, {
        set: function (t) {
            this.mask = 1 << t | 0
        }, enable: function (t) {
            this.mask = this.mask | 1 << t | 0
        }, toggle: function (t) {
            this.mask ^= 1 << t | 0
        }, disable: function (t) {
            this.mask &= ~(1 << t | 0)
        }, test: function (t) {
            return 0 != (this.mask & t.mask)
        }
    });
    var va = 0;
    S.DefaultUp = new a(0, 1, 0), S.DefaultMatrixAutoUpdate = !0, S.prototype = Object.assign(Object.create(e.prototype), {
        constructor: S, isObject3D: !0, onBeforeRender: function () {
        }, onAfterRender: function () {
        }, applyMatrix: function (t) {
            this.matrix.multiplyMatrices(t, this.matrix), this.matrix.decompose(this.position, this.quaternion, this.scale)
        }, applyQuaternion: function (t) {
            return this.quaternion.premultiply(t), this
        }, setRotationFromAxisAngle: function (t, e) {
            this.quaternion.setFromAxisAngle(t, e)
        }, setRotationFromEuler: function (t) {
            this.quaternion.setFromEuler(t, !0)
        }, setRotationFromMatrix: function (t) {
            this.quaternion.setFromRotationMatrix(t)
        }, setRotationFromQuaternion: function (t) {
            this.quaternion.copy(t)
        }, rotateOnAxis: function () {
            var t = new r;
            return function (e, i) {
                return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this
            }
        }(), rotateOnWorldAxis: function () {
            var t = new r;
            return function (e, i) {
                return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this
            }
        }(), rotateX: function () {
            var t = new a(1, 0, 0);
            return function (e) {
                return this.rotateOnAxis(t, e)
            }
        }(), rotateY: function () {
            var t = new a(0, 1, 0);
            return function (e) {
                return this.rotateOnAxis(t, e)
            }
        }(), rotateZ: function () {
            var t = new a(0, 0, 1);
            return function (e) {
                return this.rotateOnAxis(t, e)
            }
        }(), translateOnAxis: function () {
            var t = new a;
            return function (e, i) {
                return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this
            }
        }(), translateX: function () {
            var t = new a(1, 0, 0);
            return function (e) {
                return this.translateOnAxis(t, e)
            }
        }(), translateY: function () {
            var t = new a(0, 1, 0);
            return function (e) {
                return this.translateOnAxis(t, e)
            }
        }(), translateZ: function () {
            var t = new a(0, 0, 1);
            return function (e) {
                return this.translateOnAxis(t, e)
            }
        }(), localToWorld: function (t) {
            return t.applyMatrix4(this.matrixWorld)
        }, worldToLocal: function () {
            var t = new n;
            return function (e) {
                return e.applyMatrix4(t.getInverse(this.matrixWorld))
            }
        }(), lookAt: function () {
            var t = new r, e = new n, i = new a, o = new a;
            return function (n, r, a) {
                n.isVector3 ? i.copy(n) : i.set(n, r, a), n = this.parent, this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? e.lookAt(o, i, this.up) : e.lookAt(i, o, this.up), this.quaternion.setFromRotationMatrix(e), n && (e.extractRotation(n.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse()))
            }
        }(), add: function (t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++) this.add(arguments[e]);
                return this
            }
            return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({type: "added"}), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this)
        }, remove: function (t) {
            if (1 < arguments.length) {
                for (var e = 0; e < arguments.length; e++) this.remove(arguments[e]);
                return this
            }
            return e = this.children.indexOf(t), -1 !== e && (t.parent = null, t.dispatchEvent({type: "removed"}), this.children.splice(e, 1)), this
        }, getObjectById: function (t) {
            return this.getObjectByProperty("id", t)
        }, getObjectByName: function (t) {
            return this.getObjectByProperty("name", t)
        }, getObjectByProperty: function (t, e) {
            if (this[t] === e) return this;
            for (var i = 0, n = this.children.length; i < n; i++) {
                var r = this.children[i].getObjectByProperty(t, e);
                if (void 0 !== r) return r
            }
        }, getWorldPosition: function (t) {
            return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new a), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld)
        }, getWorldQuaternion: function () {
            var t = new a, e = new a;
            return function (i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i
            }
        }(), getWorldScale: function () {
            var t = new a, e = new r;
            return function (i) {
                return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new a), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i
            }
        }(), getWorldDirection: function (t) {
            void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new a), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(e[8], e[9], e[10]).normalize()
        }, raycast: function () {
        }, traverse: function (t) {
            t(this);
            for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverse(t)
        }, traverseVisible: function (t) {
            if (!1 !== this.visible) {
                t(this);
                for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].traverseVisible(t)
            }
        }, traverseAncestors: function (t) {
            var e = this.parent;
            null !== e && (t(e), e.traverseAncestors(t))
        }, updateMatrix: function () {
            this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
        }, updateMatrixWorld: function (t) {
            this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0);
            for (var e = this.children, i = 0, n = e.length; i < n; i++) e[i].updateMatrixWorld(t)
        }, updateWorldMatrix: function (t, e) {
            var i = this.parent;
            if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (t = this.children, e = 0, i = t.length; e < i; e++) t[e].updateWorldMatrix(!1, !0)
        }, toJSON: function (t) {
            function e(e, i) {
                return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid
            }

            function i(t) {
                var e = [], i;
                for (i in t) {
                    var n = t[i];
                    delete n.metadata, e.push(n)
                }
                return e
            }

            var n = void 0 === t || "string" == typeof t, r = {};
            n && (t = {geometries: {}, materials: {}, textures: {}, images: {}, shapes: {}}, r.metadata = {
                version: 4.5,
                type: "Object",
                generator: "Object3D.toJSON"
            });
            var a = {};
            if (a.uuid = this.uuid, a.type = this.type, "" !== this.name && (a.name = this.name), !0 === this.castShadow && (a.castShadow = !0), !0 === this.receiveShadow && (a.receiveShadow = !0), !1 === this.visible && (a.visible = !1), !1 === this.frustumCulled && (a.frustumCulled = !1), 0 !== this.renderOrder && (a.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (a.userData = this.userData), a.layers = this.layers.mask, a.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (a.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (a.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) {
                a.geometry = e(t.geometries, this.geometry);
                var o = this.geometry.parameters;
                if (void 0 !== o && void 0 !== o.shapes) if (o = o.shapes, Array.isArray(o)) for (var s = 0, l = o.length; s < l; s++) e(t.shapes, o[s]); else e(t.shapes, o)
            }
            if (void 0 !== this.material) if (Array.isArray(this.material)) {
                for (o = [], s = 0, l = this.material.length; s < l; s++) o.push(e(t.materials, this.material[s]));
                a.material = o
            } else a.material = e(t.materials, this.material);
            if (0 < this.children.length) for (a.children = [], s = 0; s < this.children.length; s++) a.children.push(this.children[s].toJSON(t).object);
            if (n) {
                n = i(t.geometries), s = i(t.materials), l = i(t.textures);
                var c = i(t.images);
                o = i(t.shapes), 0 < n.length && (r.geometries = n), 0 < s.length && (r.materials = s), 0 < l.length && (r.textures = l), 0 < c.length && (r.images = c), 0 < o.length && (r.shapes = o)
            }
            return r.object = a, r
        }, clone: function (t) {
            return (new this.constructor).copy(this, t)
        }, copy: function (t, e) {
            if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (e = 0; e < t.children.length; e++) this.add(t.children[e].clone());
            return this
        }
    });
    var ya = 0;
    E.prototype = Object.assign(Object.create(e.prototype), {
        constructor: E, isGeometry: !0, applyMatrix: function (t) {
            for (var e = (new o).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++) this.vertices[i].applyMatrix4(t);
            for (i = 0, n = this.faces.length; i < n; i++) {
                t = this.faces[i], t.normal.applyMatrix3(e).normalize();
                for (var r = 0, a = t.vertexNormals.length; r < a; r++) t.vertexNormals[r].applyMatrix3(e).normalize()
            }
            return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this
        }, rotateX: function () {
            var t = new n;
            return function (e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(), rotateY: function () {
            var t = new n;
            return function (e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(), rotateZ: function () {
            var t = new n;
            return function (e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(), translate: function () {
            var t = new n;
            return function (e, i, n) {
                return t.makeTranslation(e, i, n), this.applyMatrix(t), this
            }
        }(), scale: function () {
            var t = new n;
            return function (e, i, n) {
                return t.makeScale(e, i, n), this.applyMatrix(t), this
            }
        }(), lookAt: function () {
            var t = new S;
            return function (e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(), fromBufferGeometry: function (t) {
            function e(t, e, r, o) {
                var s = void 0 === c ? [] : [n.colors[t].clone(), n.colors[e].clone(), n.colors[r].clone()];
                o = new w(t, e, r, void 0 === l ? [] : [(new a).fromArray(l, 3 * t), (new a).fromArray(l, 3 * e), (new a).fromArray(l, 3 * r)], s, o), n.faces.push(o), void 0 !== h && n.faceVertexUvs[0].push([(new i).fromArray(h, 2 * t), (new i).fromArray(h, 2 * e), (new i).fromArray(h, 2 * r)]), void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * r)])
            }

            var n = this, r = null !== t.index ? t.index.array : void 0, o = t.attributes, s = o.position.array,
                l = void 0 !== o.normal ? o.normal.array : void 0, c = void 0 !== o.color ? o.color.array : void 0,
                h = void 0 !== o.uv ? o.uv.array : void 0, u = void 0 !== o.uv2 ? o.uv2.array : void 0;
            void 0 !== u && (this.faceVertexUvs[1] = []);
            for (var p = o = 0; o < s.length; o += 3, p += 2) n.vertices.push((new a).fromArray(s, o)), void 0 !== c && n.colors.push((new x).fromArray(c, o));
            var d = t.groups;
            if (0 < d.length) for (o = 0; o < d.length; o++) {
                s = d[o];
                var f = s.start, m = s.count;
                for (p = f, f += m; p < f; p += 3) void 0 !== r ? e(r[p], r[p + 1], r[p + 2], s.materialIndex) : e(p, p + 1, p + 2, s.materialIndex)
            } else if (void 0 !== r) for (o = 0; o < r.length; o += 3) e(r[o], r[o + 1], r[o + 2]); else for (o = 0; o < s.length / 3; o += 3) e(o, o + 1, o + 2);
            return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this
        }, center: function () {
            var t = new a;
            return function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
            }
        }(), normalize: function () {
            this.computeBoundingSphere();
            var t = this.boundingSphere.center, e = this.boundingSphere.radius;
            e = 0 === e ? 1 : 1 / e;
            var i = new n;
            return i.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(i), this
        }, computeFaceNormals: function () {
            for (var t = new a, e = new a, i = 0, n = this.faces.length; i < n; i++) {
                var r = this.faces[i], o = this.vertices[r.a], s = this.vertices[r.b];
                t.subVectors(this.vertices[r.c], s), e.subVectors(o, s), t.cross(e), t.normalize(), r.normal.copy(t)
            }
        }, computeVertexNormals: function (t) {
            void 0 === t && (t = !0);
            var e, i = Array(this.vertices.length), n = 0;
            for (e = this.vertices.length; n < e; n++) i[n] = new a;
            if (t) {
                var r = new a, o = new a;
                for (t = 0, n = this.faces.length; t < n; t++) {
                    e = this.faces[t];
                    var s = this.vertices[e.a], l = this.vertices[e.b], c = this.vertices[e.c];
                    r.subVectors(c, l), o.subVectors(s, l), r.cross(o), i[e.a].add(r), i[e.b].add(r), i[e.c].add(r)
                }
            } else for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++) e = this.faces[t], i[e.a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal);
            for (n = 0, e = this.vertices.length; n < e; n++) i[n].normalize();
            for (t = 0, n = this.faces.length; t < n; t++) e = this.faces[t], s = e.vertexNormals, 3 === s.length ? (s[0].copy(i[e.a]), s[1].copy(i[e.b]), s[2].copy(i[e.c])) : (s[0] = i[e.a].clone(), s[1] = i[e.b].clone(), s[2] = i[e.c].clone());
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        }, computeFlatVertexNormals: function () {
            var t;
            this.computeFaceNormals();
            var e = 0;
            for (t = this.faces.length; e < t; e++) {
                var i = this.faces[e], n = i.vertexNormals;
                3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone())
            }
            0 < this.faces.length && (this.normalsNeedUpdate = !0)
        }, computeMorphNormals: function () {
            var t, e, i = 0;
            for (e = this.faces.length; i < e; i++) {
                var n = this.faces[i];
                n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []);
                var r = 0;
                for (t = n.vertexNormals.length; r < t; r++) n.__originalVertexNormals[r] ? n.__originalVertexNormals[r].copy(n.vertexNormals[r]) : n.__originalVertexNormals[r] = n.vertexNormals[r].clone()
            }
            var o = new E;
            for (o.faces = this.faces, r = 0, t = this.morphTargets.length; r < t; r++) {
                if (!this.morphNormals[r]) {
                    this.morphNormals[r] = {}, this.morphNormals[r].faceNormals = [], this.morphNormals[r].vertexNormals = [], n = this.morphNormals[r].faceNormals;
                    var s = this.morphNormals[r].vertexNormals;
                    for (i = 0, e = this.faces.length; i < e; i++) {
                        var l = new a, c = {a: new a, b: new a, c: new a};
                        n.push(l), s.push(c)
                    }
                }
                for (s = this.morphNormals[r], o.vertices = this.morphTargets[r].vertices, o.computeFaceNormals(), o.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++) n = this.faces[i], l = s.faceNormals[i], c = s.vertexNormals[i], l.copy(n.normal), c.a.copy(n.vertexNormals[0]), c.b.copy(n.vertexNormals[1]), c.c.copy(n.vertexNormals[2])
            }
            for (i = 0, e = this.faces.length; i < e; i++) n = this.faces[i], n.normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices)
        }, computeBoundingSphere: function () {
            null === this.boundingSphere && (this.boundingSphere = new f), this.boundingSphere.setFromPoints(this.vertices)
        }, merge: function (t, e, i) {
            if (t && t.isGeometry) {
                var n, r = this.vertices.length, a = this.vertices, s = t.vertices, l = this.faces, c = t.faces,
                    h = this.faceVertexUvs[0], u = t.faceVertexUvs[0], p = this.colors, d = t.colors;
                void 0 === i && (i = 0), void 0 !== e && (n = (new o).getNormalMatrix(e)), t = 0;
                for (var f = s.length; t < f; t++) {
                    var m = s[t].clone();
                    void 0 !== e && m.applyMatrix4(e), a.push(m)
                }
                for (t = 0, f = d.length; t < f; t++) p.push(d[t].clone());
                for (t = 0, f = c.length; t < f; t++) {
                    s = c[t];
                    var g = s.vertexNormals;
                    for (d = s.vertexColors, p = new w(s.a + r, s.b + r, s.c + r), p.normal.copy(s.normal), void 0 !== n && p.normal.applyMatrix3(n).normalize(), e = 0, a = g.length; e < a; e++) m = g[e].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), p.vertexNormals.push(m);
                    for (p.color.copy(s.color), e = 0, a = d.length; e < a; e++) m = d[e], p.vertexColors.push(m.clone());
                    p.materialIndex = s.materialIndex + i, l.push(p)
                }
                for (t = 0, f = u.length; t < f; t++) if (i = u[t], n = [], void 0 !== i) {
                    for (e = 0, a = i.length; e < a; e++) n.push(i[e].clone());
                    h.push(n)
                }
            } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t)
        }, mergeMesh: function (t) {
            t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t)
        }, mergeVertices: function () {
            var t = {}, e = [], i = [], n = Math.pow(10, 4), r, a = 0;
            for (r = this.vertices.length; a < r; a++) {
                var o = this.vertices[a];
                o = Math.round(o.x * n) + "_" + Math.round(o.y * n) + "_" + Math.round(o.z * n), void 0 === t[o] ? (t[o] = a, e.push(this.vertices[a]), i[a] = e.length - 1) : i[a] = i[t[o]]
            }
            for (t = [], a = 0, r = this.faces.length; a < r; a++) for (n = this.faces[a], n.a = i[n.a], n.b = i[n.b], n.c = i[n.c], n = [n.a, n.b, n.c], o = 0; 3 > o; o++) if (n[o] === n[(o + 1) % 3]) {
                t.push(a);
                break
            }
            for (a = t.length - 1; 0 <= a; a--) for (n = t[a], this.faces.splice(n, 1), i = 0, r = this.faceVertexUvs.length; i < r; i++) this.faceVertexUvs[i].splice(n, 1);
            return a = this.vertices.length - e.length, this.vertices = e, a
        }, setFromPoints: function (t) {
            this.vertices = [];
            for (var e = 0, i = t.length; e < i; e++) {
                var n = t[e];
                this.vertices.push(new a(n.x, n.y, n.z || 0))
            }
            return this
        }, sortFacesByMaterialIndex: function () {
            for (var t = this.faces, e = t.length, i = 0; i < e; i++) t[i]._id = i;
            t.sort(function (t, e) {
                return t.materialIndex - e.materialIndex
            });
            var n = this.faceVertexUvs[0], r = this.faceVertexUvs[1], a, o;
            for (n && n.length === e && (a = []), r && r.length === e && (o = []), i = 0; i < e; i++) {
                var s = t[i]._id;
                a && a.push(n[s]), o && o.push(r[s])
            }
            a && (this.faceVertexUvs[0] = a), o && (this.faceVertexUvs[1] = o)
        }, toJSON: function () {
            function t(t, e, i) {
                return i ? t | 1 << e : t & ~(1 << e)
            }

            function e(t) {
                var e = t.x.toString() + t.y.toString() + t.z.toString();
                return void 0 !== c[e] ? c[e] : (c[e] = l.length / 3, l.push(t.x, t.y, t.z), c[e])
            }

            function i(t) {
                var e = t.r.toString() + t.g.toString() + t.b.toString();
                return void 0 !== u[e] ? u[e] : (u[e] = h.length, h.push(t.getHex()), u[e])
            }

            function n(t) {
                var e = t.x.toString() + t.y.toString()
                ;
                return void 0 !== d[e] ? d[e] : (d[e] = p.length / 2, p.push(t.x, t.y), d[e])
            }

            var r = {metadata: {version: 4.5, type: "Geometry", generator: "Geometry.toJSON"}};
            if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) {
                var a = this.parameters, o;
                for (o in a) void 0 !== a[o] && (r[o] = a[o]);
                return r
            }
            for (a = [], o = 0; o < this.vertices.length; o++) {
                var s = this.vertices[o];
                a.push(s.x, s.y, s.z)
            }
            s = [];
            var l = [], c = {}, h = [], u = {}, p = [], d = {};
            for (o = 0; o < this.faces.length; o++) {
                var f = this.faces[o], m = void 0 !== this.faceVertexUvs[0][o], g = 0 < f.normal.length(),
                    v = 0 < f.vertexNormals.length, y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b,
                    x = 0 < f.vertexColors.length, _ = 0;
                _ = t(_, 0, 0), _ = t(_, 1, !0), _ = t(_, 2, !1), _ = t(_, 3, m), _ = t(_, 4, g), _ = t(_, 5, v), _ = t(_, 6, y), _ = t(_, 7, x), s.push(_), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], s.push(n(m[0]), n(m[1]), n(m[2]))), g && s.push(e(f.normal)), v && (g = f.vertexNormals, s.push(e(g[0]), e(g[1]), e(g[2]))), y && s.push(i(f.color)), x && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2])))
            }
            return r.data = {}, r.data.vertices = a, r.data.normals = l, 0 < h.length && (r.data.colors = h), 0 < p.length && (r.data.uvs = [p]), r.data.faces = s, r
        }, clone: function () {
            return (new E).copy(this)
        }, copy: function (t) {
            var e, i, n;
            this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
            var r = t.vertices, a = 0;
            for (e = r.length; a < e; a++) this.vertices.push(r[a].clone());
            for (r = t.colors, a = 0, e = r.length; a < e; a++) this.colors.push(r[a].clone());
            for (r = t.faces, a = 0, e = r.length; a < e; a++) this.faces.push(r[a].clone());
            for (a = 0, e = t.faceVertexUvs.length; a < e; a++) {
                var o = t.faceVertexUvs[a];
                for (void 0 === this.faceVertexUvs[a] && (this.faceVertexUvs[a] = []), r = 0, i = o.length; r < i; r++) {
                    var s = o[r], l = [], c = 0;
                    for (n = s.length; c < n; c++) l.push(s[c].clone());
                    this.faceVertexUvs[a].push(l)
                }
            }
            for (c = t.morphTargets, a = 0, e = c.length; a < e; a++) {
                if (n = {}, n.name = c[a].name, void 0 !== c[a].vertices) for (n.vertices = [], r = 0, i = c[a].vertices.length; r < i; r++) n.vertices.push(c[a].vertices[r].clone());
                if (void 0 !== c[a].normals) for (n.normals = [], r = 0, i = c[a].normals.length; r < i; r++) n.normals.push(c[a].normals[r].clone());
                this.morphTargets.push(n)
            }
            for (c = t.morphNormals, a = 0, e = c.length; a < e; a++) {
                if (n = {}, void 0 !== c[a].vertexNormals) for (n.vertexNormals = [], r = 0, i = c[a].vertexNormals.length; r < i; r++) o = c[a].vertexNormals[r], s = {}, s.a = o.a.clone(), s.b = o.b.clone(), s.c = o.c.clone(), n.vertexNormals.push(s);
                if (void 0 !== c[a].faceNormals) for (n.faceNormals = [], r = 0, i = c[a].faceNormals.length; r < i; r++) n.faceNormals.push(c[a].faceNormals[r].clone());
                this.morphNormals.push(n)
            }
            for (r = t.skinWeights, a = 0, e = r.length; a < e; a++) this.skinWeights.push(r[a].clone());
            for (r = t.skinIndices, a = 0, e = r.length; a < e; a++) this.skinIndices.push(r[a].clone());
            for (r = t.lineDistances, a = 0, e = r.length; a < e; a++) this.lineDistances.push(r[a]);
            return a = t.boundingBox, null !== a && (this.boundingBox = a.clone()), a = t.boundingSphere, null !== a && (this.boundingSphere = a.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), Object.defineProperty(A.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.assign(A.prototype, {
        isBufferAttribute: !0, onUploadCallback: function () {
        }, setArray: function (t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this
        }, setDynamic: function (t) {
            return this.dynamic = t, this
        }, copy: function (t) {
            return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this
        }, copyAt: function (t, e, i) {
            t *= this.itemSize, i *= e.itemSize;
            for (var n = 0, r = this.itemSize; n < r; n++) this.array[t + n] = e.array[i + n];
            return this
        }, copyArray: function (t) {
            return this.array.set(t), this
        }, copyColorsArray: function (t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var a = t[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), a = new x), e[i++] = a.r, e[i++] = a.g, e[i++] = a.b
            }
            return this
        }, copyVector2sArray: function (t) {
            for (var e = this.array, n = 0, r = 0, a = t.length; r < a; r++) {
                var o = t[r];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), o = new i), e[n++] = o.x, e[n++] = o.y
            }
            return this
        }, copyVector3sArray: function (t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var o = t[n];
                void 0 === o && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), o = new a), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z
            }
            return this
        }, copyVector4sArray: function (t) {
            for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) {
                var a = t[n];
                void 0 === a && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), a = new l), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z, e[i++] = a.w
            }
            return this
        }, set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        }, getX: function (t) {
            return this.array[t * this.itemSize]
        }, setX: function (t, e) {
            return this.array[t * this.itemSize] = e, this
        }, getY: function (t) {
            return this.array[t * this.itemSize + 1]
        }, setY: function (t, e) {
            return this.array[t * this.itemSize + 1] = e, this
        }, getZ: function (t) {
            return this.array[t * this.itemSize + 2]
        }, setZ: function (t, e) {
            return this.array[t * this.itemSize + 2] = e, this
        }, getW: function (t) {
            return this.array[t * this.itemSize + 3]
        }, setW: function (t, e) {
            return this.array[t * this.itemSize + 3] = e, this
        }, setXY: function (t, e, i) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this
        }, setXYZ: function (t, e, i, n) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this
        }, setXYZW: function (t, e, i, n, r) {
            return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this
        }, onUpload: function (t) {
            return this.onUploadCallback = t, this
        }, clone: function () {
            return new this.constructor(this.array, this.itemSize).copy(this)
        }
    }), P.prototype = Object.create(A.prototype), P.prototype.constructor = P, L.prototype = Object.create(A.prototype), L.prototype.constructor = L, C.prototype = Object.create(A.prototype), C.prototype.constructor = C, R.prototype = Object.create(A.prototype), R.prototype.constructor = R, O.prototype = Object.create(A.prototype), O.prototype.constructor = O, D.prototype = Object.create(A.prototype), D.prototype.constructor = D, I.prototype = Object.create(A.prototype), I.prototype.constructor = I, N.prototype = Object.create(A.prototype), N.prototype.constructor = N, z.prototype = Object.create(A.prototype), z.prototype.constructor = z, Object.assign(k.prototype, {
        computeGroups: function (t) {
            var e = [], i = void 0;
            t = t.faces;
            for (var n = 0; n < t.length; n++) {
                var r = t[n];
                if (r.materialIndex !== i) {
                    i = r.materialIndex, void 0 !== a && (a.count = 3 * n - a.start, e.push(a));
                    var a = {start: 3 * n, materialIndex: i}
                }
            }
            void 0 !== a && (a.count = 3 * n - a.start, e.push(a)), this.groups = e
        }, fromGeometry: function (t) {
            var e = t.faces, n = t.vertices, r = t.faceVertexUvs, a = r[0] && 0 < r[0].length,
                o = r[1] && 0 < r[1].length, s = t.morphTargets, l = s.length;
            if (0 < l) {
                for (var c = [], h = 0; h < l; h++) c[h] = {name: s[h].name, data: []};
                this.morphTargets.position = c
            }
            var u = t.morphNormals, p = u.length;
            if (0 < p) {
                var d = [];
                for (h = 0; h < p; h++) d[h] = {name: u[h].name, data: []};
                this.morphTargets.normal = d
            }
            var f = t.skinIndices, m = t.skinWeights, g = f.length === n.length, v = m.length === n.length;
            for (0 < n.length && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), h = 0; h < e.length; h++) {
                var y = e[h];
                this.vertices.push(n[y.a], n[y.b], n[y.c]);
                var x = y.vertexNormals;
                for (3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = y.normal, this.normals.push(x, x, x)), x = y.vertexColors, 3 === x.length ? this.colors.push(x[0], x[1], x[2]) : (x = y.color, this.colors.push(x, x, x)), !0 === a && (x = r[0][h], void 0 !== x ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", h), this.uvs.push(new i, new i, new i))), !0 === o && (x = r[1][h], void 0 !== x ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", h), this.uvs2.push(new i, new i, new i))), x = 0; x < l; x++) {
                    var _ = s[x].vertices;
                    c[x].data.push(_[y.a], _[y.b], _[y.c])
                }
                for (x = 0; x < p; x++) _ = u[x].vertexNormals[h], d[x].data.push(_.a, _.b, _.c);
                g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c])
            }
            return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this
        }
    });
    var xa = 1;
    F.prototype = Object.assign(Object.create(e.prototype), {
        constructor: F, isBufferGeometry: !0, getIndex: function () {
            return this.index
        }, setIndex: function (t) {
            Array.isArray(t) ? this.index = new (65535 < B(t) ? I : O)(t, 1) : this.index = t
        }, addAttribute: function (t, e, i) {
            return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new A(e, i)))
        }, getAttribute: function (t) {
            return this.attributes[t]
        }, removeAttribute: function (t) {
            return delete this.attributes[t], this
        }, addGroup: function (t, e, i) {
            this.groups.push({start: t, count: e, materialIndex: void 0 !== i ? i : 0})
        }, clearGroups: function () {
            this.groups = []
        }, setDrawRange: function (t, e) {
            this.drawRange.start = t, this.drawRange.count = e
        }, applyMatrix: function (t) {
            var e = this.attributes.position;
            return void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0), e = this.attributes.normal, void 0 !== e && ((new o).getNormalMatrix(t).applyToBufferAttribute(e), e.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this
        }, rotateX: function () {
            var t = new n;
            return function (e) {
                return t.makeRotationX(e), this.applyMatrix(t), this
            }
        }(), rotateY: function () {
            var t = new n;
            return function (e) {
                return t.makeRotationY(e), this.applyMatrix(t), this
            }
        }(), rotateZ: function () {
            var t = new n;
            return function (e) {
                return t.makeRotationZ(e), this.applyMatrix(t), this
            }
        }(), translate: function () {
            var t = new n;
            return function (e, i, n) {
                return t.makeTranslation(e, i, n), this.applyMatrix(t), this
            }
        }(), scale: function () {
            var t = new n;
            return function (e, i, n) {
                return t.makeScale(e, i, n), this.applyMatrix(t), this
            }
        }(), lookAt: function () {
            var t = new S;
            return function (e) {
                t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix)
            }
        }(), center: function () {
            var t = new a;
            return function () {
                return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this
            }
        }(), setFromObject: function (t) {
            var e = t.geometry;
            if (t.isPoints || t.isLine) {
                t = new N(3 * e.vertices.length, 3);
                var i = new N(3 * e.colors.length, 3);
                this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new N(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone())
            } else t.isMesh && e && e.isGeometry && this.fromGeometry(e);
            return this
        }, setFromPoints: function (t) {
            for (var e = [], i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.push(r.x, r.y, r.z || 0)
            }
            return this.addAttribute("position", new N(e, 3)), this
        }, updateFromObject: function (t) {
            var e = t.geometry;
            if (t.isMesh) {
                var i = e.__directGeometry;
                if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e);
                i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i
            }
            return !0 === e.verticesNeedUpdate && (i = this.attributes.position, void 0 !== i && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (i = this.attributes.normal, void 0 !== i && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (i = this.attributes.color, void 0 !== i && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (i = this.attributes.uv, void 0 !== i && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (i = this.attributes.lineDistance, void 0 !== i && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this
        }, fromGeometry: function (t) {
            return t.__directGeometry = (new k).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry)
        }, fromDirectGeometry: function (t) {
            var e = new Float32Array(3 * t.vertices.length);
            this.addAttribute("position", new A(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new A(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new A(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new A(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new A(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups;
            for (var i in t.morphTargets) {
                e = [];
                for (var n = t.morphTargets[i], r = 0, a = n.length; r < a; r++) {
                    var o = n[r], s = new N(3 * o.data.length, 3);
                    s.name = o.name, e.push(s.copyVector3sArray(o.data))
                }
                this.morphAttributes[i] = e
            }
            return 0 < t.skinIndices.length && (i = new N(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new N(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this
        }, computeBoundingBox: function () {
            null === this.boundingBox && (this.boundingBox = new d);
            var t = this.attributes.position;
            void 0 !== t ? this.boundingBox.setFromBufferAttribute(t) : this.boundingBox.makeEmpty(), (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
        }, computeBoundingSphere: function () {
            var t = new d, e = new a;
            return function () {
                null === this.boundingSphere && (this.boundingSphere = new f);
                var i = this.attributes.position;
                if (i) {
                    var n = this.boundingSphere.center;
                    t.setFromBufferAttribute(i), t.getCenter(n);
                    for (var r = 0, a = 0, o = i.count; a < o; a++) e.x = i.getX(a), e.y = i.getY(a), e.z = i.getZ(a), r = Math.max(r, n.distanceToSquared(e));
                    this.boundingSphere.radius = Math.sqrt(r), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
                }
            }
        }(), computeFaceNormals: function () {
        }, computeVertexNormals: function () {
            var t = this.index, e = this.attributes;
            if (e.position) {
                var i = e.position.array;
                if (void 0 === e.normal) this.addAttribute("normal", new A(new Float32Array(i.length), 3)); else for (var n = e.normal.array, r = 0, o = n.length; r < o; r++) n[r] = 0;
                n = e.normal.array;
                var s = new a, l = new a, c = new a, h = new a, u = new a;
                if (t) {
                    var p = t.array;
                    for (r = 0, o = t.count; r < o; r += 3) {
                        t = 3 * p[r + 0];
                        var d = 3 * p[r + 1], f = 3 * p[r + 2];
                        s.fromArray(i, t), l.fromArray(i, d), c.fromArray(i, f), h.subVectors(c, l), u.subVectors(s, l), h.cross(u), n[t] += h.x, n[t + 1] += h.y, n[t + 2] += h.z, n[d] += h.x, n[d + 1] += h.y, n[d + 2] += h.z, n[f] += h.x, n[f + 1] += h.y, n[f + 2] += h.z
                    }
                } else for (r = 0, o = i.length; r < o; r += 9) s.fromArray(i, r), l.fromArray(i, r + 3), c.fromArray(i, r + 6), h.subVectors(c, l), u.subVectors(s, l), h.cross(u), n[r] = h.x, n[r + 1] = h.y, n[r + 2] = h.z, n[r + 3] = h.x, n[r + 4] = h.y, n[r + 5] = h.z, n[r + 6] = h.x, n[r + 7] = h.y, n[r + 8] = h.z;
                this.normalizeNormals(), e.normal.needsUpdate = !0
            }
        }, merge: function (t, e) {
            if (t && t.isBufferGeometry) {
                void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
                var i = this.attributes, n;
                for (n in i) if (void 0 !== t.attributes[n]) {
                    var r = i[n].array, a = t.attributes[n], o = a.array, s = 0;
                    for (a = a.itemSize * e; s < o.length; s++, a++) r[a] = o[s]
                }
                return this
            }
            console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t)
        }, normalizeNormals: function () {
            var t = new a;
            return function () {
                for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++) t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z)
            }
        }(), toNonIndexed: function () {
            function t(t, e) {
                var i = t.array;
                t = t.itemSize;
                for (var n = new i.constructor(e.length * t), r, a = 0, o = 0, s = e.length; o < s; o++) {
                    r = e[o] * t;
                    for (var l = 0; l < t; l++) n[a++] = i[r++]
                }
                return new A(n, t)
            }

            if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this;
            var e = new F, i = this.index.array, n = this.attributes, r;
            for (r in n) {
                var a = n[r];
                a = t(a, i), e.addAttribute(r, a)
            }
            var o = this.morphAttributes;
            for (r in o) {
                var s = [], l = o[r];
                n = 0;
                for (var c = l.length; n < c; n++) a = l[n], a = t(a, i), s.push(a);
                e.morphAttributes[r] = s
            }
            for (i = this.groups, n = 0, r = i.length; n < r; n++) a = i[n], e.addGroup(a.start, a.count, a.materialIndex);
            return e
        }, toJSON: function () {
            var t = {metadata: {version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON"}};
            if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) {
                var e = this.parameters;
                for (r in e) void 0 !== e[r] && (t[r] = e[r]);
                return t
            }
            t.data = {attributes: {}};
            var i = this.index;
            null !== i && (e = Array.prototype.slice.call(i.array), t.data.index = {
                type: i.array.constructor.name,
                array: e
            }), i = this.attributes;
            for (r in i) {
                var n = i[r];
                e = Array.prototype.slice.call(n.array), t.data.attributes[r] = {
                    itemSize: n.itemSize,
                    type: n.array.constructor.name,
                    array: e,
                    normalized: n.normalized
                }
            }
            var r = this.groups;
            return 0 < r.length && (t.data.groups = JSON.parse(JSON.stringify(r))), r = this.boundingSphere, null !== r && (t.data.boundingSphere = {
                center: r.center.toArray(),
                radius: r.radius
            }), t
        }, clone: function () {
            return (new F).copy(this)
        }, copy: function (t) {
            var e;
            this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name;
            var i = t.index;
            null !== i && this.setIndex(i.clone()), i = t.attributes;
            for (o in i) this.addAttribute(o, i[o].clone());
            var n = t.morphAttributes;
            for (o in n) {
                var r = [], a = n[o];
                for (i = 0, e = a.length; i < e; i++) r.push(a[i].clone());
                this.morphAttributes[o] = r
            }
            var o = t.groups;
            for (i = 0, e = o.length; i < e; i++) n = o[i], this.addGroup(n.start, n.count, n.materialIndex);
            return o = t.boundingBox, null !== o && (this.boundingBox = o.clone()), o = t.boundingSphere, null !== o && (this.boundingSphere = o.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), H.prototype = Object.create(E.prototype), H.prototype.constructor = H, U.prototype = Object.create(F.prototype), U.prototype.constructor = U, G.prototype = Object.create(E.prototype), G.prototype.constructor = G, j.prototype = Object.create(F.prototype), j.prototype.constructor = j;
    var _a = 0;
    V.prototype = Object.assign(Object.create(e.prototype), {
        constructor: V, isMaterial: !0, onBeforeCompile: function () {
        }, setValues: function (t) {
            if (void 0 !== t) for (var e in t) {
                var i = t[e];
                if (void 0 === i) console.warn("THREE.Material: '" + e + "' parameter is undefined."); else if ("shading" === e) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i; else {
                    var n = this[e];
                    void 0 === n ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i
                }
            }
        }, toJSON: function (t) {
            function e(t) {
                var e = [], i;
                for (i in t) {
                    var n = t[i];
                    delete n.metadata, e.push(n)
                }
                return e
            }

            var i = void 0 === t || "string" == typeof t;
            i && (t = {textures: {}, images: {}});
            var n = {metadata: {version: 4.5, type: "Material", generator: "Material.toJSON"}};
            return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection;
            var e = t.clippingPlanes, i = null;
            if (null !== e) {
                var n = e.length;
                i = Array(n);
                for (var r = 0; r !== n; ++r) i[r] = e[r].clone()
            }
            return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), W.prototype = Object.create(V.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = v(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this
    }, W.prototype.toJSON = function (t) {
        var e = V.prototype.toJSON.call(this, t);
        e.uniforms = {};
        for (var i in this.uniforms) {
            var n = this.uniforms[i].value;
            e.uniforms[i] = n && n.isTexture ? {type: "t", value: n.toJSON(t).uuid} : n && n.isColor ? {
                type: "c",
                value: n.getHex()
            } : n && n.isVector2 ? {type: "v2", value: n.toArray()} : n && n.isVector3 ? {
                type: "v3",
                value: n.toArray()
            } : n && n.isVector4 ? {type: "v4", value: n.toArray()} : n && n.isMatrix3 ? {
                type: "m3",
                value: n.toArray()
            } : n && n.isMatrix4 ? {type: "m4", value: n.toArray()} : {value: n}
        }
        0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, t = {};
        for (var r in this.extensions) !0 === this.extensions[r] && (t[r] = !0);
        return 0 < Object.keys(t).length && (e.extensions = t), e
    }, Object.assign(q.prototype, {
        set: function (t, e) {
            return this.origin.copy(t), this.direction.copy(e), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.origin.copy(t.origin), this.direction.copy(t.direction), this
        }, at: function (t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new a), e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }, lookAt: function (t) {
            return this.direction.copy(t).sub(this.origin).normalize(), this
        }, recast: function () {
            var t = new a;
            return function (e) {
                return this.origin.copy(this.at(e, t)), this
            }
        }(), closestPointToPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new a), e.subVectors(t, this.origin), t = e.dot(this.direction), 0 > t ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin)
        }, distanceToPoint: function (t) {
            return Math.sqrt(this.distanceSqToPoint(t))
        }, distanceSqToPoint: function () {
            var t = new a;
            return function (e) {
                var i = t.subVectors(e, this.origin).dot(this.direction);
                return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e))
            }
        }(), distanceSqToSegment: function () {
            var t = new a, e = new a, i = new a;
            return function (n, r, a, o) {
                t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t);
                var s = .5 * n.distanceTo(r), l = -this.direction.dot(e), c = i.dot(this.direction), h = -i.dot(e),
                    u = i.lengthSq(), p = Math.abs(1 - l * l);
                if (0 < p) {
                    n = l * h - c, r = l * c - h;
                    var d = s * p;
                    0 <= n ? r >= -d ? r <= d ? (s = 1 / p, n *= s, r *= s, l = n * (n + l * r + 2 * c) + r * (l * n + r + 2 * h) + u) : (r = s, n = Math.max(0, -(l * r + c)), l = -n * n + r * (r + 2 * h) + u) : (r = -s, n = Math.max(0, -(l * r + c)), l = -n * n + r * (r + 2 * h) + u) : r <= -d ? (n = Math.max(0, -(-l * s + c)), r = 0 < n ? -s : Math.min(Math.max(-s, -h), s), l = -n * n + r * (r + 2 * h) + u) : r <= d ? (n = 0, r = Math.min(Math.max(-s, -h), s), l = r * (r + 2 * h) + u) : (n = Math.max(0, -(l * s + c)), r = 0 < n ? s : Math.min(Math.max(-s, -h), s), l = -n * n + r * (r + 2 * h) + u)
                } else r = 0 < l ? -s : s, n = Math.max(0, -(l * r + c)), l = -n * n + r * (r + 2 * h) + u;
                return a && a.copy(this.direction).multiplyScalar(n).add(this.origin), o && o.copy(e).multiplyScalar(r).add(t), l
            }
        }(), intersectSphere: function () {
            var t = new a;
            return function (e, i) {
                t.subVectors(e.center, this.origin);
                var n = t.dot(this.direction), r = t.dot(t) - n * n;
                return e = e.radius * e.radius, r > e ? null : (e = Math.sqrt(e - r), r = n - e, n += e, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i))
            }
        }(), intersectsSphere: function (t) {
            return this.distanceSqToPoint(t.center) <= t.radius * t.radius
        }, distanceToPlane: function (t) {
            var e = t.normal.dot(this.direction);
            return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : (t = -(this.origin.dot(t.normal) + t.constant) / e, 0 <= t ? t : null)
        }, intersectPlane: function (t, e) {
            return t = this.distanceToPlane(t), null === t ? null : this.at(t, e)
        }, intersectsPlane: function (t) {
            var e = t.distanceToPoint(this.origin);
            return 0 === e || 0 > t.normal.dot(this.direction) * e
        }, intersectBox: function (t, e) {
            var i = 1 / this.direction.x, n = 1 / this.direction.y, r = 1 / this.direction.z, a = this.origin;
            if (0 <= i) {
                var o = (t.min.x - a.x) * i;
                i *= t.max.x - a.x
            } else o = (t.max.x - a.x) * i, i *= t.min.x - a.x;
            if (0 <= n) {
                var s = (t.min.y - a.y) * n;
                n *= t.max.y - a.y
            } else s = (t.max.y - a.y) * n, n *= t.min.y - a.y;
            return o > n || s > i ? null : ((s > o || o !== o) && (o = s), (n < i || i !== i) && (i = n), 0 <= r ? (s = (t.min.z - a.z) * r, t = (t.max.z - a.z) * r) : (s = (t.max.z - a.z) * r, t = (t.min.z - a.z) * r), o > t || s > i ? null : ((s > o || o !== o) && (o = s), (t < i || i !== i) && (i = t), 0 > i ? null : this.at(0 <= o ? o : i, e)))
        }, intersectsBox: function () {
            var t = new a;
            return function (e) {
                return null !== this.intersectBox(e, t)
            }
        }(), intersectTriangle: function () {
            var t = new a, e = new a, i = new a, n = new a;
            return function (r, a, o, s, l) {
                if (e.subVectors(a, r), i.subVectors(o, r), n.crossVectors(e, i), 0 < (a = this.direction.dot(n))) {
                    if (s) return null;
                    s = 1
                } else {
                    if (!(0 > a)) return null;
                    s = -1, a = -a
                }
                return t.subVectors(this.origin, r), 0 > (r = s * this.direction.dot(i.crossVectors(t, i))) ? null : 0 > (o = s * this.direction.dot(e.cross(t))) || r + o > a ? null : (r = -s * t.dot(n), 0 > r ? null : this.at(r / a, l))
            }
        }(), applyMatrix4: function (t) {
            return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this
        }, equals: function (t) {
            return t.origin.equals(this.origin) && t.direction.equals(this.direction)
        }
    }), Object.assign(X, {
        getNormal: function () {
            var t = new a;
            return function (e, i, n, r) {
                return void 0 === r && (console.warn("THREE.Triangle: .getNormal() target is now required"), r = new a), r.subVectors(n, i), t.subVectors(e, i), r.cross(t), e = r.lengthSq(), 0 < e ? r.multiplyScalar(1 / Math.sqrt(e)) : r.set(0, 0, 0)
            }
        }(), getBarycoord: function () {
            var t = new a, e = new a, i = new a;
            return function (n, r, o, s, l) {
                t.subVectors(s, r), e.subVectors(o, r), i.subVectors(n, r), n = t.dot(t), r = t.dot(e), o = t.dot(i);
                var c = e.dot(e);
                s = e.dot(i);
                var h = n * c - r * r;
                return void 0 === l && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), l = new a), 0 === h ? l.set(-2, -1, -1) : (h = 1 / h, c = (c * o - r * s) * h, n = (n * s - r * o) * h, l.set(1 - c - n, n, c))
            }
        }(), containsPoint: function () {
            var t = new a;
            return function (e, i, n, r) {
                return X.getBarycoord(e, i, n, r, t), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y
            }
        }(), getUV: function () {
            var t = new a;
            return function (e, i, n, r, a, o, s, l) {
                return this.getBarycoord(e, i, n, r, t), l.set(0, 0), l.addScaledVector(a, t.x), l.addScaledVector(o, t.y), l.addScaledVector(s, t.z), l
            }
        }()
    }), Object.assign(X.prototype, {
        set: function (t, e, i) {
            return this.a.copy(t), this.b.copy(e), this.c.copy(i), this
        }, setFromPointsAndIndices: function (t, e, i, n) {
            return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this
        }, getArea: function () {
            var t = new a, e = new a;
            return function () {
                return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length()
            }
        }(), getMidpoint: function (t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new a), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
        }, getNormal: function (t) {
            return X.getNormal(this.a, this.b, this.c, t)
        }, getPlane: function (t) {
            return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new a), t.setFromCoplanarPoints(this.a, this.b, this.c)
        }, getBarycoord: function (t, e) {
            return X.getBarycoord(t, this.a, this.b, this.c, e)
        }, containsPoint: function (t) {
            return X.containsPoint(t, this.a, this.b, this.c)
        }, getUV: function (t, e, i, n, r) {
            return X.getUV(t, this.a, this.b, this.c, e, i, n, r)
        }, intersectsBox: function (t) {
            return t.intersectsTriangle(this)
        }, closestPointToPoint: function () {
            var t = new a, e = new a, i = new a, n = new a, r = new a, o = new a;
            return function (s, l) {
                void 0 === l && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), l = new a);
                var c = this.a, h = this.b, u = this.c;
                t.subVectors(h, c), e.subVectors(u, c), n.subVectors(s, c);
                var p = t.dot(n), d = e.dot(n);
                if (0 >= p && 0 >= d) return l.copy(c);
                r.subVectors(s, h);
                var f = t.dot(r), m = e.dot(r);
                if (0 <= f && m <= f) return l.copy(h);
                var g = p * m - f * d;
                if (0 >= g && 0 <= p && 0 >= f) return h = p / (p - f), l.copy(c).addScaledVector(t, h);
                o.subVectors(s, u), s = t.dot(o);
                var v = e.dot(o);
                return 0 <= v && s <= v ? l.copy(u) : 0 >= (p = s * d - p * v) && 0 <= d && 0 >= v ? (g = d / (d - v), l.copy(c).addScaledVector(e, g)) : 0 >= (d = f * v - s * m) && 0 <= m - f && 0 <= s - v ? (i.subVectors(u, h), g = (m - f) / (m - f + (s - v)), l.copy(h).addScaledVector(i, g)) : (u = 1 / (d + p + g), h = p * u, g *= u, l.copy(c).addScaledVector(t, h).addScaledVector(e, g))
            }
        }(), equals: function (t) {
            return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c)
        }
    }), Y.prototype = Object.create(V.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this
    }, J.prototype = Object.assign(Object.create(S.prototype), {
        constructor: J, isMesh: !0, setDrawMode: function (t) {
            this.drawMode = t
        }, copy: function (t) {
            return S.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this
        }, updateMorphTargets: function () {
            var t = this.geometry;
            if (t.isBufferGeometry) {
                t = t.morphAttributes;
                var e = Object.keys(t);
                if (0 < e.length) {
                    var i = t[e[0]];
                    if (void 0 !== i) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) {
                        var n = i[t].name || String(t);
                        this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t
                    }
                }
            } else void 0 !== (t = t.morphTargets) && 0 < t.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")
        }, raycast: function () {
            function t(t, e, i, n, r, a, o, s) {
                return null === (1 === e.side ? n.intersectTriangle(o, a, r, !0, s) : n.intersectTriangle(r, a, o, 2 !== e.side, s)) ? null : (x.copy(s), x.applyMatrix4(t.matrixWorld), e = i.ray.origin.distanceTo(x), e < i.near || e > i.far ? null : {
                    distance: e,
                    point: x.clone(),
                    object: t
                })
            }

            function e(e, n, r, a, o, s, u, p, d) {
                return l.fromBufferAttribute(o, u), c.fromBufferAttribute(o, p), h.fromBufferAttribute(o, d), (e = t(e, n, r, a, l, c, h, y)) && (s && (m.fromBufferAttribute(s, u), g.fromBufferAttribute(s, p), v.fromBufferAttribute(s, d), e.uv = X.getUV(y, l, c, h, m, g, v, new i)), s = new w(u, p, d), X.getNormal(l, c, h, s.normal), e.face = s), e
            }

            var r = new n, o = new q, s = new f, l = new a, c = new a, h = new a, u = new a, p = new a, d = new a,
                m = new i, g = new i, v = new i, y = new a, x = new a;
            return function (n, a) {
                var f = this.geometry, x = this.material, _ = this.matrixWorld;
                if (void 0 !== x && (null === f.boundingSphere && f.computeBoundingSphere(), s.copy(f.boundingSphere), s.applyMatrix4(_), !1 !== n.ray.intersectsSphere(s) && (r.getInverse(_), o.copy(n.ray).applyMatrix4(r), null === f.boundingBox || !1 !== o.intersectsBox(f.boundingBox)))) if (f.isBufferGeometry) {
                    var b = f.index, w = f.attributes.position, M = f.attributes.uv, T = f.groups;
                    f = f.drawRange;
                    var S, E;
                    if (null !== b) if (Array.isArray(x)) {
                        var A = 0;
                        for (S = T.length; A < S; A++) {
                            var P = T[A], L = x[P.materialIndex], C = Math.max(P.start, f.start);
                            for (E = _ = Math.min(P.start + P.count, f.start + f.count); C < E; C += 3) {
                                _ = b.getX(C);
                                var R = b.getX(C + 1), O = b.getX(C + 2);
                                (_ = e(this, L, n, o, w, M, _, R, O)) && (_.faceIndex = Math.floor(C / 3), _.face.materialIndex = P.materialIndex, a.push(_))
                            }
                        }
                    } else for (C = Math.max(0, f.start), _ = Math.min(b.count, f.start + f.count), A = C, S = _; A < S; A += 3) _ = b.getX(A), R = b.getX(A + 1), O = b.getX(A + 2), (_ = e(this, x, n, o, w, M, _, R, O)) && (_.faceIndex = Math.floor(A / 3), a.push(_)); else if (void 0 !== w) if (Array.isArray(x)) for (A = 0, S = T.length; A < S; A++) for (P = T[A], L = x[P.materialIndex], C = Math.max(P.start, f.start), E = _ = Math.min(P.start + P.count, f.start + f.count); C < E; C += 3) _ = C, R = C + 1, O = C + 2, (_ = e(this, L, n, o, w, M, _, R, O)) && (_.faceIndex = Math.floor(C / 3), _.face.materialIndex = P.materialIndex, a.push(_)); else for (C = Math.max(0, f.start), _ = Math.min(w.count, f.start + f.count), A = C, S = _; A < S; A += 3) _ = A, R = A + 1, O = A + 2, (_ = e(this, x, n, o, w, M, _, R, O)) && (_.faceIndex = Math.floor(A / 3), a.push(_))
                } else if (f.isGeometry) for (w = Array.isArray(x), M = f.vertices, T = f.faces, _ = f.faceVertexUvs[0], 0 < _.length && (b = _), L = 0, C = T.length; L < C; L++) if (E = T[L], void 0 !== (_ = w ? x[E.materialIndex] : x)) {
                    if (A = M[E.a], S = M[E.b], P = M[E.c], !0 === _.morphTargets) {
                        R = f.morphTargets, O = this.morphTargetInfluences, l.set(0, 0, 0), c.set(0, 0, 0), h.set(0, 0, 0);
                        for (var D = 0, I = R.length; D < I; D++) {
                            var N = O[D];
                            if (0 !== N) {
                                var z = R[D].vertices;
                                l.addScaledVector(u.subVectors(z[E.a], A), N), c.addScaledVector(p.subVectors(z[E.b], S), N), h.addScaledVector(d.subVectors(z[E.c], P), N)
                            }
                        }
                        l.add(A), c.add(S), h.add(P), A = l, S = c, P = h
                    }
                    (_ = t(this, _, n, o, A, S, P, y)) && (b && b[L] && (R = b[L], m.copy(R[0]), g.copy(R[1]), v.copy(R[2]), _.uv = X.getUV(y, A, S, P, m, g, v, new i)), _.face = E, _.faceIndex = L, a.push(_))
                }
            }
        }(), clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), lt.prototype = Object.create(s.prototype), lt.prototype.constructor = lt, lt.prototype.isCubeTexture = !0, Object.defineProperty(lt.prototype, "images", {
        get: function () {
            return this.image
        }, set: function (t) {
            this.image = t
        }
    }), ct.prototype = Object.create(s.prototype), ct.prototype.constructor = ct, ct.prototype.isDataTexture3D = !0;
    var ba = new s, wa = new ct, Ma = new lt, Ta = [], Sa = [], Ea = new Float32Array(16), Aa = new Float32Array(9),
        Pa = new Float32Array(4);
    Ut.prototype.updateCache = function (t) {
        var e = this.cache;
        t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), pt(e, t)
    }, Gt.prototype.setValue = function (t, e, i) {
        for (var n = this.seq, r = 0, a = n.length; r !== a; ++r) {
            var o = n[r];
            o.setValue(t, e[o.id], i)
        }
    };
    var La = /([\w\d_]+)(\])?(\[|\.)?/g;
    jt.prototype.setValue = function (t, e, i) {
        void 0 !== (e = this.map[e]) && e.setValue(t, i, this.renderer)
    }, jt.prototype.setOptional = function (t, e, i) {
        void 0 !== (e = e[i]) && this.setValue(t, i, e)
    }, jt.upload = function (t, e, i, n) {
        for (var r = 0, a = e.length; r !== a; ++r) {
            var o = e[r], s = i[o.id];
            !1 !== s.needsUpdate && o.setValue(t, s.value, n)
        }
    }, jt.seqWithValue = function (t, e) {
        for (var i = [], n = 0, r = t.length; n !== r; ++n) {
            var a = t[n];
            a.id in e && i.push(a)
        }
        return i
    };
    var Ca = 0, Ra = 0;
    fe.prototype = Object.create(V.prototype), fe.prototype.constructor = fe, fe.prototype.isMeshDepthMaterial = !0, fe.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this
    }, me.prototype = Object.create(V.prototype), me.prototype.constructor = me, me.prototype.isMeshDistanceMaterial = !0, me.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this
    }, _e.prototype = Object.assign(Object.create(S.prototype), {
        constructor: _e,
        isGroup: !0
    }), be.prototype = Object.assign(Object.create(S.prototype), {
        constructor: be, isCamera: !0, copy: function (t, e) {
            return S.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this
        }, getWorldDirection: function (t) {
            void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new a), this.updateMatrixWorld(!0);
            var e = this.matrixWorld.elements;
            return t.set(-e[8], -e[9], -e[10]).normalize()
        }, updateMatrixWorld: function (t) {
            S.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld)
        }, clone: function () {
            return (new this.constructor).copy(this)
        }
    }), we.prototype = Object.assign(Object.create(be.prototype), {
        constructor: we, isPerspectiveCamera: !0, copy: function (t, e) {
            return be.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this
        }, setFocalLength: function (t) {
            t = .5 * this.getFilmHeight() / t, this.fov = 2 * la.RAD2DEG * Math.atan(t), this.updateProjectionMatrix()
        }, getFocalLength: function () {
            var t = Math.tan(.5 * la.DEG2RAD * this.fov);
            return .5 * this.getFilmHeight() / t
        }, getEffectiveFOV: function () {
            return 2 * la.RAD2DEG * Math.atan(Math.tan(.5 * la.DEG2RAD * this.fov) / this.zoom)
        }, getFilmWidth: function () {
            return this.filmGauge * Math.min(this.aspect, 1)
        }, getFilmHeight: function () {
            return this.filmGauge / Math.max(this.aspect, 1)
        }, setViewOffset: function (t, e, i, n, r, a) {
            this.aspect = t / e, null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }, clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }, updateProjectionMatrix: function () {
            var t = this.near, e = t * Math.tan(.5 * la.DEG2RAD * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i,
                r = -.5 * n, a = this.view;
            if (null !== this.view && this.view.enabled) {
                var o = a.fullWidth, s = a.fullHeight;
                r += a.offsetX * n / o, e -= a.offsetY * i / s, n *= a.width / o, i *= a.height / s
            }
            a = this.filmOffset, 0 !== a && (r += t * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        }, toJSON: function (t) {
            return t = S.prototype.toJSON.call(this, t), t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
        }
    }), Me.prototype = Object.assign(Object.create(we.prototype), {constructor: Me, isArrayCamera: !0});
    var Oa = new a, Da = new a;
    Pe.prototype.isFogExp2 = !0, Pe.prototype.clone = function () {
        return new Pe(this.color, this.density)
    }, Pe.prototype.toJSON = function () {
        return {type: "FogExp2", color: this.color.getHex(), density: this.density}
    }, Le.prototype.isFog = !0, Le.prototype.clone = function () {
        return new Le(this.color, this.near, this.far)
    }, Le.prototype.toJSON = function () {
        return {type: "Fog", color: this.color.getHex(), near: this.near, far: this.far}
    }, Ce.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Ce, isScene: !0, copy: function (t, e) {
            return S.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this
        }, toJSON: function (t) {
            var e = S.prototype.toJSON.call(this, t);
            return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e
        }, dispose: function () {
            this.dispatchEvent({type: "dispose"})
        }
    }), Object.defineProperty(Re.prototype, "needsUpdate", {
        set: function (t) {
            !0 === t && this.version++
        }
    }), Object.assign(Re.prototype, {
        isInterleavedBuffer: !0, onUploadCallback: function () {
        }, setArray: function (t) {
            if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
            return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this
        }, setDynamic: function (t) {
            return this.dynamic = t, this
        }, copy: function (t) {
            return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this
        }, copyAt: function (t, e, i) {
            t *= this.stride, i *= e.stride;
            for (var n = 0, r = this.stride; n < r; n++) this.array[t + n] = e.array[i + n];
            return this
        }, set: function (t, e) {
            return void 0 === e && (e = 0), this.array.set(t, e), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, onUpload: function (t) {
            return this.onUploadCallback = t, this
        }
    }), Object.defineProperties(Oe.prototype, {
        count: {
            get: function () {
                return this.data.count
            }
        }, array: {
            get: function () {
                return this.data.array
            }
        }
    }), Object.assign(Oe.prototype, {
        isInterleavedBufferAttribute: !0, setX: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset] = e, this
        }, setY: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset + 1] = e, this
        }, setZ: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset + 2] = e, this
        }, setW: function (t, e) {
            return this.data.array[t * this.data.stride + this.offset + 3] = e, this
        }, getX: function (t) {
            return this.data.array[t * this.data.stride + this.offset]
        }, getY: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 1]
        }, getZ: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 2]
        }, getW: function (t) {
            return this.data.array[t * this.data.stride + this.offset + 3]
        }, setXY: function (t, e, i) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this
        }, setXYZ: function (t, e, i, n) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this
        }, setXYZW: function (t, e, i, n, r) {
            return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this
        }
    }), De.prototype = Object.create(V.prototype), De.prototype.constructor = De, De.prototype.isSpriteMaterial = !0, De.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this
    };
    var Ia;
    Ie.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Ie, isSprite: !0, raycast: function () {
            function t(t, e, i, n, r, a) {
                s.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (l.x = a * s.x - r * s.y, l.y = r * s.x + a * s.y) : l.copy(s), t.copy(e), t.x += l.x, t.y += l.y, t.applyMatrix4(c)
            }

            var e = new a, r = new a, o = new a, s = new i, l = new i, c = new n, h = new a, u = new a, p = new a,
                d = new i, f = new i, m = new i;
            return function (n, a) {
                r.setFromMatrixScale(this.matrixWorld), c.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix);
                var s = this.material.rotation;
                if (0 !== s) var l = Math.cos(s), g = Math.sin(s);
                s = this.center, t(h.set(-.5, -.5, 0), o, s, r, g, l), t(u.set(.5, -.5, 0), o, s, r, g, l), t(p.set(.5, .5, 0), o, s, r, g, l), d.set(0, 0), f.set(1, 0), m.set(1, 1);
                var v = n.ray.intersectTriangle(h, u, p, !1, e);
                null === v && (t(u.set(-.5, .5, 0), o, s, r, g, l), f.set(0, 1), null === (v = n.ray.intersectTriangle(h, p, u, !1, e))) || (g = n.ray.origin.distanceTo(e)) < n.near || g > n.far || a.push({
                    distance: g,
                    point: e.clone(),
                    uv: X.getUV(e, h, u, p, d, f, m, new i),
                    face: null,
                    object: this
                })
            }
        }(), clone: function () {
            return new this.constructor(this.material).copy(this)
        }, copy: function (t) {
            return S.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this
        }
    }), Ne.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Ne, copy: function (t) {
            S.prototype.copy.call(this, t, !1), t = t.levels;
            for (var e = 0, i = t.length; e < i; e++) {
                var n = t[e];
                this.addLevel(n.object.clone(), n.distance)
            }
            return this
        }, addLevel: function (t, e) {
            void 0 === e && (e = 0), e = Math.abs(e);
            for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++) ;
            i.splice(n, 0, {distance: e, object: t}), this.add(t)
        }, getObjectForDistance: function (t) {
            for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++) ;
            return e[i - 1].object
        }, raycast: function () {
            var t = new a;
            return function (e, i) {
                t.setFromMatrixPosition(this.matrixWorld);
                var n = e.ray.origin.distanceTo(t);
                this.getObjectForDistance(n).raycast(e, i)
            }
        }(), update: function () {
            var t = new a, e = new a;
            return function (i) {
                var n = this.levels;
                if (1 < n.length) {
                    t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0;
                    for (var r = 1, a = n.length; r < a && i >= n[r].distance; r++) n[r - 1].object.visible = !1, n[r].object.visible = !0;
                    for (; r < a; r++) n[r].object.visible = !1
                }
            }
        }(), toJSON: function (t) {
            t = S.prototype.toJSON.call(this, t), t.object.levels = [];
            for (var e = this.levels, i = 0, n = e.length; i < n; i++) {
                var r = e[i];
                t.object.levels.push({object: r.object.uuid, distance: r.distance})
            }
            return t
        }
    }), ze.prototype = Object.assign(Object.create(J.prototype), {
        constructor: ze,
        isSkinnedMesh: !0,
        bind: function (t, e) {
            this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e)
        },
        pose: function () {
            this.skeleton.pose()
        },
        normalizeSkinWeights: function () {
            for (var t = new l, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) {
                t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i);
                var r = 1 / t.manhattanLength();
                1 / 0 !== r ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w)
            }
        },
        updateMatrixWorld: function (t) {
            J.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
        },
        clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), Object.assign(ke.prototype, {
        calculateInverses: function () {
            this.boneInverses = [];
            for (var t = 0, e = this.bones.length; t < e; t++) {
                var i = new n;
                this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i)
            }
        }, pose: function () {
            var t, e, i = 0;
            for (e = this.bones.length; i < e; i++) (t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]);
            for (i = 0, e = this.bones.length; i < e; i++) (t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale))
        }, update: function () {
            var t = new n, e = new n;
            return function () {
                for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, a = this.boneTexture, o = 0, s = i.length; o < s; o++) t.multiplyMatrices(i[o] ? i[o].matrixWorld : e, n[o]), t.toArray(r, 16 * o);
                void 0 !== a && (a.needsUpdate = !0)
            }
        }(), clone: function () {
            return new ke(this.bones, this.boneInverses)
        }, getBoneByName: function (t) {
            for (var e = 0, i = this.bones.length; e < i; e++) {
                var n = this.bones[e];
                if (n.name === t) return n
            }
        }
    }), Be.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Be,
        isBone: !0
    }), Fe.prototype = Object.create(V.prototype), Fe.prototype.constructor = Fe, Fe.prototype.isLineBasicMaterial = !0, Fe.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this
    }, He.prototype = Object.assign(Object.create(S.prototype), {
        constructor: He, isLine: !0, computeLineDistances: function () {
            var t = new a, e = new a;
            return function () {
                var i = this.geometry;
                if (i.isBufferGeometry) if (null === i.index) {
                    for (var n = i.attributes.position, r = [0], a = 1, o = n.count; a < o; a++) t.fromBufferAttribute(n, a - 1), e.fromBufferAttribute(n, a), r[a] = r[a - 1], r[a] += t.distanceTo(e);
                    i.addAttribute("lineDistance", new N(r, 1))
                } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (i.isGeometry) for (n = i.vertices, r = i.lineDistances, r[0] = 0, a = 1, o = n.length; a < o; a++) r[a] = r[a - 1], r[a] += n[a - 1].distanceTo(n[a]);
                return this
            }
        }(), raycast: function () {
            var t = new n, e = new q, i = new f;
            return function (n, r) {
                var o = n.linePrecision, s = this.geometry, l = this.matrixWorld;
                if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(l), i.radius += o, !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(l), e.copy(n.ray).applyMatrix4(t), o /= (this.scale.x + this.scale.y + this.scale.z) / 3, o *= o;
                    var c = new a, h = new a;
                    l = new a;
                    var u = new a, p = this && this.isLineSegments ? 2 : 1;
                    if (s.isBufferGeometry) {
                        var d = s.index, f = s.attributes.position.array;
                        if (null !== d) {
                            d = d.array, s = 0;
                            for (var m = d.length - 1; s < m; s += p) {
                                var g = d[s + 1];
                                c.fromArray(f, 3 * d[s]), h.fromArray(f, 3 * g), g = e.distanceSqToSegment(c, h, u, l), g > o || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || r.push({
                                    distance: g,
                                    point: l.clone().applyMatrix4(this.matrixWorld),
                                    index: s,
                                    face: null,
                                    faceIndex: null,
                                    object: this
                                }))
                            }
                        } else for (s = 0, m = f.length / 3 - 1; s < m; s += p) c.fromArray(f, 3 * s), h.fromArray(f, 3 * s + 3), (g = e.distanceSqToSegment(c, h, u, l)) > o || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || r.push({
                            distance: g,
                            point: l.clone().applyMatrix4(this.matrixWorld),
                            index: s,
                            face: null,
                            faceIndex: null,
                            object: this
                        }))
                    } else if (s.isGeometry) for (c = s.vertices, h = c.length, s = 0; s < h - 1; s += p) (g = e.distanceSqToSegment(c[s], c[s + 1], u, l)) > o || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || r.push({
                        distance: g,
                        point: l.clone().applyMatrix4(this.matrixWorld),
                        index: s,
                        face: null,
                        faceIndex: null,
                        object: this
                    }))
                }
            }
        }(), copy: function (t) {
            return S.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }
    }), Ue.prototype = Object.assign(Object.create(He.prototype), {
        constructor: Ue,
        isLineSegments: !0,
        computeLineDistances: function () {
            var t = new a, e = new a;
            return function () {
                var i = this.geometry;
                if (i.isBufferGeometry) if (null === i.index) {
                    for (var n = i.attributes.position, r = [], a = 0, o = n.count; a < o; a += 2) t.fromBufferAttribute(n, a), e.fromBufferAttribute(n, a + 1), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + t.distanceTo(e);
                    i.addAttribute("lineDistance", new N(r, 1))
                } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (i.isGeometry) for (n = i.vertices, r = i.lineDistances, a = 0, o = n.length; a < o; a += 2) t.copy(n[a]), e.copy(n[a + 1]), r[a] = 0 === a ? 0 : r[a - 1], r[a + 1] = r[a] + t.distanceTo(e);
                return this
            }
        }()
    }), Ge.prototype = Object.assign(Object.create(He.prototype), {
        constructor: Ge,
        isLineLoop: !0
    }), je.prototype = Object.create(V.prototype), je.prototype.constructor = je, je.prototype.isPointsMaterial = !0, je.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this
    }, Ve.prototype = Object.assign(Object.create(S.prototype), {
        constructor: Ve, isPoints: !0, raycast: function () {
            var t = new n, e = new q, i = new f;
            return function (n, r) {
                function o(t, i) {
                    var a = e.distanceSqToPoint(t);
                    a < u && (e.closestPointToPoint(t, p), p.applyMatrix4(c), (t = n.ray.origin.distanceTo(p)) < n.near || t > n.far || r.push({
                        distance: t,
                        distanceToRay: Math.sqrt(a),
                        point: p.clone(),
                        index: i,
                        face: null,
                        object: s
                    }))
                }

                var s = this, l = this.geometry, c = this.matrixWorld, h = n.params.Points.threshold;
                if (null === l.boundingSphere && l.computeBoundingSphere(), i.copy(l.boundingSphere), i.applyMatrix4(c), i.radius += h, !1 !== n.ray.intersectsSphere(i)) {
                    t.getInverse(c), e.copy(n.ray).applyMatrix4(t), h /= (this.scale.x + this.scale.y + this.scale.z) / 3;
                    var u = h * h;
                    h = new a;
                    var p = new a;
                    if (l.isBufferGeometry) {
                        var d = l.index;
                        if (l = l.attributes.position.array, null !== d) {
                            var f = d.array;
                            d = 0;
                            for (var m = f.length; d < m; d++) {
                                var g = f[d];
                                h.fromArray(l, 3 * g), o(h, g)
                            }
                        } else for (d = 0, f = l.length / 3; d < f; d++) h.fromArray(l, 3 * d), o(h, d)
                    } else for (h = l.vertices, d = 0, f = h.length; d < f; d++) o(h[d], d)
                }
            }
        }(), clone: function () {
            return new this.constructor(this.geometry, this.material).copy(this)
        }
    }), We.prototype = Object.assign(Object.create(s.prototype), {
        constructor: We,
        isVideoTexture: !0,
        update: function () {
            var t = this.image;
            t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
        }
    }), qe.prototype = Object.create(s.prototype), qe.prototype.constructor = qe, qe.prototype.isCompressedTexture = !0, Xe.prototype = Object.create(s.prototype), Xe.prototype.constructor = Xe, Xe.prototype.isCanvasTexture = !0, Ye.prototype = Object.create(s.prototype), Ye.prototype.constructor = Ye, Ye.prototype.isDepthTexture = !0, Je.prototype = Object.create(F.prototype), Je.prototype.constructor = Je, Ze.prototype = Object.create(E.prototype), Ze.prototype.constructor = Ze, $e.prototype = Object.create(F.prototype), $e.prototype.constructor = $e, Qe.prototype = Object.create(E.prototype), Qe.prototype.constructor = Qe, Ke.prototype = Object.create(F.prototype), Ke.prototype.constructor = Ke, ti.prototype = Object.create(E.prototype), ti.prototype.constructor = ti, ei.prototype = Object.create(Ke.prototype), ei.prototype.constructor = ei, ii.prototype = Object.create(E.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(Ke.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(E.prototype), ri.prototype.constructor = ri, ai.prototype = Object.create(Ke.prototype), ai.prototype.constructor = ai, oi.prototype = Object.create(E.prototype), oi.prototype.constructor = oi, si.prototype = Object.create(Ke.prototype), si.prototype.constructor = si, li.prototype = Object.create(E.prototype), li.prototype.constructor = li, ci.prototype = Object.create(F.prototype), ci.prototype.constructor = ci, hi.prototype = Object.create(E.prototype), hi.prototype.constructor = hi, ui.prototype = Object.create(F.prototype), ui.prototype.constructor = ui, pi.prototype = Object.create(E.prototype), pi.prototype.constructor = pi, di.prototype = Object.create(F.prototype), di.prototype.constructor = di;
    var Na = {
        triangulate: function (t, e, i) {
            i = i || 2;
            var n = e && e.length, r = n ? e[0] * i : t.length, a = fi(t, 0, r, i, !0), o = [];
            if (!a) return o;
            var s;
            if (n) {
                var l = i;
                n = [];
                var c, h = 0;
                for (c = e.length; h < c; h++) {
                    var u = e[h] * l;
                    u = fi(t, u, h < c - 1 ? e[h + 1] * l : t.length, l, !1), u === u.next && (u.steiner = !0), n.push(_i(u))
                }
                for (n.sort(vi), h = 0; h < n.length; h++) e = n[h], l = a, (l = yi(e, l)) && (e = Ei(l, e), mi(e, e.next)), a = mi(a, a.next)
            }
            if (t.length > 80 * i) {
                var p = s = t[0], d = n = t[1];
                for (l = i; l < r; l += i) h = t[l], e = t[l + 1], h < p && (p = h), e < d && (d = e), h > s && (s = h), e > n && (n = e);
                s = Math.max(s - p, n - d), s = 0 !== s ? 1 / s : 0
            }
            return gi(a, o, i, p, d, s), o
        }
    }, za = {
        area: function (t) {
            for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++) i += t[n].x * t[r].y - t[r].x * t[n].y;
            return .5 * i
        }, isClockWise: function (t) {
            return 0 > za.area(t)
        }, triangulateShape: function (t, e) {
            var i = [], n = [], r = [];
            Ci(t), Ri(i, t);
            var a = t.length;
            for (e.forEach(Ci), t = 0; t < e.length; t++) n.push(a), a += e[t].length, Ri(i, e[t]);
            for (e = Na.triangulate(i, n), t = 0; t < e.length; t += 3) r.push(e.slice(t, t + 3));
            return r
        }
    };
    Oi.prototype = Object.create(E.prototype), Oi.prototype.constructor = Oi, Oi.prototype.toJSON = function () {
        var t = E.prototype.toJSON.call(this);
        return Ii(this.parameters.shapes, this.parameters.options, t)
    }, Di.prototype = Object.create(F.prototype), Di.prototype.constructor = Di, Di.prototype.toJSON = function () {
        var t = F.prototype.toJSON.call(this);
        return Ii(this.parameters.shapes, this.parameters.options, t)
    };
    var ka = {
        generateTopUV: function (t, e, n, r, a) {
            t = e[3 * r], r = e[3 * r + 1];
            var o = e[3 * a];
            return a = e[3 * a + 1], [new i(e[3 * n], e[3 * n + 1]), new i(t, r), new i(o, a)]
        }, generateSideWallUV: function (t, e, n, r, a, o) {
            t = e[3 * n];
            var s = e[3 * n + 1];
            n = e[3 * n + 2];
            var l = e[3 * r], c = e[3 * r + 1];
            r = e[3 * r + 2];
            var h = e[3 * a], u = e[3 * a + 1];
            a = e[3 * a + 2];
            var p = e[3 * o], d = e[3 * o + 1];
            return e = e[3 * o + 2], .01 > Math.abs(s - c) ? [new i(t, 1 - n), new i(l, 1 - r), new i(h, 1 - a), new i(p, 1 - e)] : [new i(s, 1 - n), new i(c, 1 - r), new i(u, 1 - a), new i(d, 1 - e)]
        }
    };
    Ni.prototype = Object.create(E.prototype), Ni.prototype.constructor = Ni, zi.prototype = Object.create(Di.prototype), zi.prototype.constructor = zi, ki.prototype = Object.create(E.prototype), ki.prototype.constructor = ki, Bi.prototype = Object.create(F.prototype), Bi.prototype.constructor = Bi, Fi.prototype = Object.create(E.prototype), Fi.prototype.constructor = Fi, Hi.prototype = Object.create(F.prototype), Hi.prototype.constructor = Hi, Ui.prototype = Object.create(E.prototype), Ui.prototype.constructor = Ui, Gi.prototype = Object.create(F.prototype), Gi.prototype.constructor = Gi, ji.prototype = Object.create(E.prototype), ji.prototype.constructor = ji, ji.prototype.toJSON = function () {
        var t = E.prototype.toJSON.call(this);
        return Wi(this.parameters.shapes, t)
    }, Vi.prototype = Object.create(F.prototype), Vi.prototype.constructor = Vi, Vi.prototype.toJSON = function () {
        var t = F.prototype.toJSON.call(this);
        return Wi(this.parameters.shapes, t)
    }, qi.prototype = Object.create(F.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(E.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(F.prototype), Yi.prototype.constructor = Yi, Ji.prototype = Object.create(Xi.prototype), Ji.prototype.constructor = Ji, Zi.prototype = Object.create(Yi.prototype), Zi.prototype.constructor = Zi, $i.prototype = Object.create(E.prototype), $i.prototype.constructor = $i, Qi.prototype = Object.create(F.prototype), Qi.prototype.constructor = Qi;
    var Ba = Object.freeze({
        WireframeGeometry: Je,
        ParametricGeometry: Ze,
        ParametricBufferGeometry: $e,
        TetrahedronGeometry: ti,
        TetrahedronBufferGeometry: ei,
        OctahedronGeometry: ii,
        OctahedronBufferGeometry: ni,
        IcosahedronGeometry: ri,
        IcosahedronBufferGeometry: ai,
        DodecahedronGeometry: oi,
        DodecahedronBufferGeometry: si,
        PolyhedronGeometry: Qe,
        PolyhedronBufferGeometry: Ke,
        TubeGeometry: li,
        TubeBufferGeometry: ci,
        TorusKnotGeometry: hi,
        TorusKnotBufferGeometry: ui,
        TorusGeometry: pi,
        TorusBufferGeometry: di,
        TextGeometry: Ni,
        TextBufferGeometry: zi,
        SphereGeometry: ki,
        SphereBufferGeometry: Bi,
        RingGeometry: Fi,
        RingBufferGeometry: Hi,
        PlaneGeometry: G,
        PlaneBufferGeometry: j,
        LatheGeometry: Ui,
        LatheBufferGeometry: Gi,
        ShapeGeometry: ji,
        ShapeBufferGeometry: Vi,
        ExtrudeGeometry: Oi,
        ExtrudeBufferGeometry: Di,
        EdgesGeometry: qi,
        ConeGeometry: Ji,
        ConeBufferGeometry: Zi,
        CylinderGeometry: Xi,
        CylinderBufferGeometry: Yi,
        CircleGeometry: $i,
        CircleBufferGeometry: Qi,
        BoxGeometry: H,
        BoxBufferGeometry: U
    });
    Ki.prototype = Object.create(V.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isShadowMaterial = !0, Ki.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.color.copy(t.color), this
    }, tn.prototype = Object.create(W.prototype), tn.prototype.constructor = tn, tn.prototype.isRawShaderMaterial = !0, en.prototype = Object.create(V.prototype), en.prototype.constructor = en, en.prototype.isMeshStandardMaterial = !0, en.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.defines = {STANDARD: ""}, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, nn.prototype = Object.create(en.prototype), nn.prototype.constructor = nn, nn.prototype.isMeshPhysicalMaterial = !0, nn.prototype.copy = function (t) {
        return en.prototype.copy.call(this, t), this.defines = {PHYSICAL: ""}, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this
    }, rn.prototype = Object.create(V.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshPhongMaterial = !0, rn.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t),
            this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, an.prototype = Object.create(rn.prototype), an.prototype.constructor = an, an.prototype.isMeshToonMaterial = !0, an.prototype.copy = function (t) {
        return rn.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this
    }, on.prototype = Object.create(V.prototype), on.prototype.constructor = on, on.prototype.isMeshNormalMaterial = !0, on.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, sn.prototype = Object.create(V.prototype), sn.prototype.constructor = sn, sn.prototype.isMeshLambertMaterial = !0, sn.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, ln.prototype = Object.create(V.prototype), ln.prototype.constructor = ln, ln.prototype.isMeshMatcapMaterial = !0, ln.prototype.copy = function (t) {
        return V.prototype.copy.call(this, t), this.defines = {MATCAP: ""}, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this
    }, cn.prototype = Object.create(Fe.prototype), cn.prototype.constructor = cn, cn.prototype.isLineDashedMaterial = !0, cn.prototype.copy = function (t) {
        return Fe.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this
    };
    var Fa = Object.freeze({
        ShadowMaterial: Ki,
        SpriteMaterial: De,
        RawShaderMaterial: tn,
        ShaderMaterial: W,
        PointsMaterial: je,
        MeshPhysicalMaterial: nn,
        MeshStandardMaterial: en,
        MeshPhongMaterial: rn,
        MeshToonMaterial: an,
        MeshNormalMaterial: on,
        MeshLambertMaterial: sn,
        MeshDepthMaterial: fe,
        MeshDistanceMaterial: me,
        MeshBasicMaterial: Y,
        MeshMatcapMaterial: ln,
        LineDashedMaterial: cn,
        LineBasicMaterial: Fe,
        Material: V
    }), Ha = {
        arraySlice: function (t, e, i) {
            return Ha.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i)
        }, convertArray: function (t, e, i) {
            return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t)
        }, isTypedArray: function (t) {
            return ArrayBuffer.isView(t) && !(t instanceof DataView)
        }, getKeyframeOrder: function (t) {
            for (var e = t.length, i = Array(e), n = 0; n !== e; ++n) i[n] = n;
            return i.sort(function (e, i) {
                return t[e] - t[i]
            }), i
        }, sortedArray: function (t, e, i) {
            for (var n = t.length, r = new t.constructor(n), a = 0, o = 0; o !== n; ++a) for (var s = i[a] * e, l = 0; l !== e; ++l) r[o++] = t[s + l];
            return r
        }, flattenJSON: function (t, e, i, n) {
            for (var r = 1, a = t[0]; void 0 !== a && void 0 === a[n];) a = t[r++];
            if (void 0 !== a) {
                var o = a[n];
                if (void 0 !== o) if (Array.isArray(o)) do {
                    o = a[n], void 0 !== o && (e.push(a.time), i.push.apply(i, o)), a = t[r++]
                } while (void 0 !== a); else if (void 0 !== o.toArray) do {
                    o = a[n], void 0 !== o && (e.push(a.time), o.toArray(i, i.length)), a = t[r++]
                } while (void 0 !== a); else do {
                    o = a[n], void 0 !== o && (e.push(a.time), i.push(o)), a = t[r++]
                } while (void 0 !== a)
            }
        }
    };
    Object.assign(hn.prototype, {
        evaluate: function (t) {
            var e = this.parameterPositions, i = this._cachedIndex, n = e[i], r = e[i - 1];
            t:{
                e:{
                    i:{
                        n:if (!(t < n)) {
                            for (var a = i + 2; ;) {
                                if (void 0 === n) {
                                    if (t < r) break n;
                                    return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, r)
                                }
                                if (i === a) break;
                                if (r = n, n = e[++i], t < n) break e
                            }
                            n = e.length;
                            break i
                        }
                        if (t >= r) break t;
                        for (a = e[1], t < a && (i = 2, r = a), a = i - 2; ;) {
                            if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                            if (i === a) break;
                            if (n = r, r = e[--i - 1], t >= r) break e
                        }
                        n = i, i = 0
                    }
                    for (; i < n;) r = i + n >>> 1, t < e[r] ? n = r : i = r + 1;
                    if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n);
                    if (void 0 === n) return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, r, t)
                }
                this._cachedIndex = i, this.intervalChanged_(i, r, n)
            }
            return this.interpolate_(i, r, t, n)
        }, settings: null, DefaultSettings_: {}, getSettings_: function () {
            return this.settings || this.DefaultSettings_
        }, copySampleValue_: function (t) {
            var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize;
            t *= n;
            for (var r = 0; r !== n; ++r) e[r] = i[t + r];
            return e
        }, interpolate_: function () {
            throw Error("call to abstract method")
        }, intervalChanged_: function () {
        }
    }), Object.assign(hn.prototype, {
        beforeStart_: hn.prototype.copySampleValue_,
        afterEnd_: hn.prototype.copySampleValue_
    }), un.prototype = Object.assign(Object.create(hn.prototype), {
        constructor: un,
        DefaultSettings_: {endingStart: 2400, endingEnd: 2400},
        intervalChanged_: function (t, e, i) {
            var n = this.parameterPositions, r = t - 2, a = t + 1, o = n[r], s = n[a];
            if (void 0 === o) switch (this.getSettings_().endingStart) {
                case 2401:
                    r = t, o = 2 * e - i;
                    break;
                case 2402:
                    r = n.length - 2, o = e + n[r] - n[r + 1];
                    break;
                default:
                    r = t, o = i
            }
            if (void 0 === s) switch (this.getSettings_().endingEnd) {
                case 2401:
                    a = t, s = 2 * i - e;
                    break;
                case 2402:
                    a = 1, s = i + n[1] - n[0];
                    break;
                default:
                    a = t - 1, s = e
            }
            t = .5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - o), this._weightNext = t / (s - i), this._offsetPrev = r * n, this._offsetNext = a * n
        },
        interpolate_: function (t, e, i, n) {
            var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize;
            t *= o;
            var s = t - o, l = this._offsetPrev, c = this._offsetNext, h = this._weightPrev, u = this._weightNext,
                p = (i - e) / (n - e);
            for (i = p * p, n = i * p, e = -h * n + 2 * h * i - h * p, h = (1 + h) * n + (-1.5 - 2 * h) * i + (-.5 + h) * p + 1, p = (-1 - u) * n + (1.5 + u) * i + .5 * p, u = u * n - u * i, i = 0; i !== o; ++i) r[i] = e * a[l + i] + h * a[s + i] + p * a[t + i] + u * a[c + i];
            return r
        }
    }), pn.prototype = Object.assign(Object.create(hn.prototype), {
        constructor: pn,
        interpolate_: function (t, e, i, n) {
            var r = this.resultBuffer, a = this.sampleValues, o = this.valueSize;
            t *= o;
            var s = t - o;
            for (e = (i - e) / (n - e), i = 1 - e, n = 0; n !== o; ++n) r[n] = a[s + n] * i + a[t + n] * e;
            return r
        }
    }), dn.prototype = Object.assign(Object.create(hn.prototype), {
        constructor: dn, interpolate_: function (t) {
            return this.copySampleValue_(t - 1)
        }
    }), Object.assign(fn, {
        toJSON: function (t) {
            var e = t.constructor;
            if (void 0 !== e.toJSON) e = e.toJSON(t); else {
                e = {name: t.name, times: Ha.convertArray(t.times, Array), values: Ha.convertArray(t.values, Array)};
                var i = t.getInterpolation();
                i !== t.DefaultInterpolation && (e.interpolation = i)
            }
            return e.type = t.ValueTypeName, e
        }
    }), Object.assign(fn.prototype, {
        constructor: fn,
        TimeBufferType: Float32Array,
        ValueBufferType: Float32Array,
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodDiscrete: function (t) {
            return new dn(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodLinear: function (t) {
            return new pn(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: function (t) {
            return new un(this.times, this.values, this.getValueSize(), t)
        },
        setInterpolation: function (t) {
            switch (t) {
                case 2300:
                    var e = this.InterpolantFactoryMethodDiscrete;
                    break;
                case 2301:
                    e = this.InterpolantFactoryMethodLinear;
                    break;
                case 2302:
                    e = this.InterpolantFactoryMethodSmooth
            }
            if (void 0 === e) {
                if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) {
                    if (t === this.DefaultInterpolation) throw Error(e);
                    this.setInterpolation(this.DefaultInterpolation)
                }
                return console.warn("THREE.KeyframeTrack:", e), this
            }
            return this.createInterpolant = e, this
        },
        getInterpolation: function () {
            switch (this.createInterpolant) {
                case this.InterpolantFactoryMethodDiscrete:
                    return 2300;
                case this.InterpolantFactoryMethodLinear:
                    return 2301;
                case this.InterpolantFactoryMethodSmooth:
                    return 2302
            }
        },
        getValueSize: function () {
            return this.values.length / this.times.length
        },
        shift: function (t) {
            if (0 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] += t;
            return this
        },
        scale: function (t) {
            if (1 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i) e[i] *= t;
            return this
        },
        trim: function (t, e) {
            for (var i = this.times, n = i.length, r = 0, a = n - 1; r !== n && i[r] < t;) ++r;
            for (; -1 !== a && i[a] > e;) --a;
            return ++a, 0 === r && a === n || (r >= a && (a = Math.max(a, 1), r = a - 1), t = this.getValueSize(), this.times = Ha.arraySlice(i, r, a), this.values = Ha.arraySlice(this.values, r * t, a * t)), this
        },
        validate: function () {
            var t = !0, e = this.getValueSize();
            0 != e - Math.floor(e) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1);
            var i = this.times;
            e = this.values;
            var n = i.length;
            0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1);
            for (var r = null, a = 0; a !== n; a++) {
                var o = i[a];
                if ("number" == typeof o && isNaN(o)) {
                    console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, o), t = !1;
                    break
                }
                if (null !== r && r > o) {
                    console.error("THREE.KeyframeTrack: Out of order keys.", this, a, o, r), t = !1;
                    break
                }
                r = o
            }
            if (void 0 !== e && Ha.isTypedArray(e)) for (a = 0, i = e.length; a !== i; ++a) if (n = e[a], isNaN(n)) {
                console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, n), t = !1;
                break
            }
            return t
        },
        optimize: function () {
            for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, a = t.length - 1, o = 1; o < a; ++o) {
                var s = !1, l = t[o];
                if (l !== t[o + 1] && (1 !== o || l !== l[0])) if (n) s = !0; else {
                    var c = o * i, h = c - i, u = c + i;
                    for (l = 0; l !== i; ++l) {
                        var p = e[c + l];
                        if (p !== e[h + l] || p !== e[u + l]) {
                            s = !0;
                            break
                        }
                    }
                }
                if (s) {
                    if (o !== r) for (t[r] = t[o], s = o * i, c = r * i, l = 0; l !== i; ++l) e[c + l] = e[s + l];
                    ++r
                }
            }
            if (0 < a) {
                for (t[r] = t[a], s = a * i, c = r * i, l = 0; l !== i; ++l) e[c + l] = e[s + l];
                ++r
            }
            return r !== t.length && (this.times = Ha.arraySlice(t, 0, r), this.values = Ha.arraySlice(e, 0, r * i)), this
        },
        clone: function () {
            var t = Ha.arraySlice(this.times, 0), e = Ha.arraySlice(this.values, 0);
            return t = new this.constructor(this.name, t, e), t.createInterpolant = this.createInterpolant, t
        }
    }), mn.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: mn,
        ValueTypeName: "bool",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), gn.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: gn,
        ValueTypeName: "color"
    }), vn.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: vn,
        ValueTypeName: "number"
    }), yn.prototype = Object.assign(Object.create(hn.prototype), {
        constructor: yn,
        interpolate_: function (t, e, i, n) {
            var a = this.resultBuffer, o = this.sampleValues, s = this.valueSize;
            for (t *= s, e = (i - e) / (n - e), i = t + s; t !== i; t += 4) r.slerpFlat(a, 0, o, t - s, o, t, e);
            return a
        }
    }), xn.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: xn,
        ValueTypeName: "quaternion",
        DefaultInterpolation: 2301,
        InterpolantFactoryMethodLinear: function (t) {
            return new yn(this.times, this.values, this.getValueSize(), t)
        },
        InterpolantFactoryMethodSmooth: void 0
    }), _n.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: _n,
        ValueTypeName: "string",
        ValueBufferType: Array,
        DefaultInterpolation: 2300,
        InterpolantFactoryMethodLinear: void 0,
        InterpolantFactoryMethodSmooth: void 0
    }), bn.prototype = Object.assign(Object.create(fn.prototype), {
        constructor: bn,
        ValueTypeName: "vector"
    }), Object.assign(wn, {
        parse: function (t) {
            for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, a = i.length; r !== a; ++r) e.push(Tn(i[r]).scale(n));
            return new wn(t.name, t.duration, e)
        }, toJSON: function (t) {
            var e = [], i = t.tracks;
            t = {name: t.name, duration: t.duration, tracks: e, uuid: t.uuid};
            for (var n = 0, r = i.length; n !== r; ++n) e.push(fn.toJSON(i[n]));
            return t
        }, CreateFromMorphTargetSequence: function (t, e, i, n) {
            for (var r = e.length, a = [], o = 0; o < r; o++) {
                var s = [], l = [];
                s.push((o + r - 1) % r, o, (o + 1) % r), l.push(0, 1, 0);
                var c = Ha.getKeyframeOrder(s);
                s = Ha.sortedArray(s, 1, c), l = Ha.sortedArray(l, 1, c), n || 0 !== s[0] || (s.push(r), l.push(l[0])), a.push(new vn(".morphTargetInfluences[" + e[o].name + "]", s, l).scale(1 / i))
            }
            return new wn(t, -1, a)
        }, findByName: function (t, e) {
            var i = t;
            for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++) if (i[t].name === e) return i[t];
            return null
        }, CreateClipsFromMorphTargetSequences: function (t, e, i) {
            for (var n = {}, r = /^([\w-]*?)([\d]+)$/, a = 0, o = t.length; a < o; a++) {
                var s = t[a], l = s.name.match(/^([\w-]*?)([\d]+)$/);
                if (l && 1 < l.length) {
                    var c = l[1];
                    (l = n[c]) || (n[c] = l = []), l.push(s)
                }
            }
            t = [];
            for (c in n) t.push(wn.CreateFromMorphTargetSequence(c, n[c], e, i));
            return t
        }, parseAnimation: function (t, e) {
            if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
            var i = function (t, e, i, n, r) {
                if (0 !== i.length) {
                    var a = [], o = [];
                    Ha.flattenJSON(i, a, o, n), 0 !== a.length && r.push(new t(e, a, o))
                }
            }, n = [], r = t.name || "default", a = t.length || -1, o = t.fps || 30;
            t = t.hierarchy || [];
            for (var s = 0; s < t.length; s++) {
                var l = t[s].keys;
                if (l && 0 !== l.length) if (l[0].morphTargets) {
                    a = {};
                    for (var c = 0; c < l.length; c++) if (l[c].morphTargets) for (var h = 0; h < l[c].morphTargets.length; h++) a[l[c].morphTargets[h]] = -1;
                    for (var u in a) {
                        var p = [], d = [];
                        for (h = 0; h !== l[c].morphTargets.length; ++h) {
                            var f = l[c];
                            p.push(f.time), d.push(f.morphTarget === u ? 1 : 0)
                        }
                        n.push(new vn(".morphTargetInfluence[" + u + "]", p, d))
                    }
                    a = a.length * (o || 1)
                } else c = ".bones[" + e[s].name + "]", i(bn, c + ".position", l, "pos", n), i(xn, c + ".quaternion", l, "rot", n), i(bn, c + ".scale", l, "scl", n)
            }
            return 0 === n.length ? null : new wn(r, a, n)
        }
    }), Object.assign(wn.prototype, {
        resetDuration: function () {
            for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) {
                var n = this.tracks[e];
                t = Math.max(t, n.times[n.times.length - 1])
            }
            return this.duration = t, this
        }, trim: function () {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].trim(0, this.duration);
            return this
        }, validate: function () {
            for (var t = !0, e = 0; e < this.tracks.length; e++) t = t && this.tracks[e].validate();
            return t
        }, optimize: function () {
            for (var t = 0; t < this.tracks.length; t++) this.tracks[t].optimize();
            return this
        }, clone: function () {
            for (var t = [], e = 0; e < this.tracks.length; e++) t.push(this.tracks[e].clone());
            return new wn(this.name, this.duration, t)
        }
    });
    var Ua = {
        enabled: !1, files: {}, add: function (t, e) {
            !1 !== this.enabled && (this.files[t] = e)
        }, get: function (t) {
            if (!1 !== this.enabled) return this.files[t]
        }, remove: function (t) {
            delete this.files[t]
        }, clear: function () {
            this.files = {}
        }
    }, Ga = new Sn, ja = {};
    Object.assign(En.prototype, {
        load: function (t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this, a = Ua.get(t);
            if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () {
                e && e(a), r.manager.itemEnd(t)
            }, 0), a;
            if (void 0 === ja[t]) {
                var o = t.match(/^data:(.*?)(;base64)?,(.*)$/);
                if (o) {
                    i = o[1];
                    var s = !!o[2];
                    o = o[3], o = decodeURIComponent(o), s && (o = atob(o));
                    try {
                        var l = (this.responseType || "").toLowerCase();
                        switch (l) {
                            case"arraybuffer":
                            case"blob":
                                var c = new Uint8Array(o.length);
                                for (s = 0; s < o.length; s++) c[s] = o.charCodeAt(s);
                                var h = "blob" === l ? new Blob([c.buffer], {type: i}) : c.buffer;
                                break;
                            case"document":
                                h = (new DOMParser).parseFromString(o, i);
                                break;
                            case"json":
                                h = JSON.parse(o);
                                break;
                            default:
                                h = o
                        }
                        setTimeout(function () {
                            e && e(h), r.manager.itemEnd(t)
                        }, 0)
                    } catch (e) {
                        setTimeout(function () {
                            n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
                        }, 0)
                    }
                } else {
                    ja[t] = [], ja[t].push({onLoad: e, onProgress: i, onError: n});
                    var u = new XMLHttpRequest;
                    u.open("GET", t, !0), u.addEventListener("load", function (e) {
                        var i = this.response;
                        Ua.add(t, i);
                        var n = ja[t];
                        if (delete ja[t], 200 === this.status || 0 === this.status) {
                            0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received.");
                            for (var a = 0, o = n.length; a < o; a++) {
                                var s = n[a];
                                s.onLoad && s.onLoad(i)
                            }
                        } else {
                            for (a = 0, o = n.length; a < o; a++) s = n[a], s.onError && s.onError(e);
                            r.manager.itemError(t)
                        }
                        r.manager.itemEnd(t)
                    }, !1), u.addEventListener("progress", function (e) {
                        for (var i = ja[t], n = 0, r = i.length; n < r; n++) {
                            var a = i[n];
                            a.onProgress && a.onProgress(e)
                        }
                    }, !1), u.addEventListener("error", function (e) {
                        var i = ja[t];
                        delete ja[t];
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n];
                            o.onError && o.onError(e)
                        }
                        r.manager.itemError(t), r.manager.itemEnd(t)
                    }, !1), u.addEventListener("abort", function (e) {
                        var i = ja[t];
                        delete ja[t];
                        for (var n = 0, a = i.length; n < a; n++) {
                            var o = i[n];
                            o.onError && o.onError(e)
                        }
                        r.manager.itemError(t), r.manager.itemEnd(t)
                    }, !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain");
                    for (s in this.requestHeader) u.setRequestHeader(s, this.requestHeader[s]);
                    u.send(null)
                }
                return r.manager.itemStart(t), u
            }
            ja[t].push({onLoad: e, onProgress: i, onError: n})
        }, setPath: function (t) {
            return this.path = t, this
        }, setResponseType: function (t) {
            return this.responseType = t, this
        }, setWithCredentials: function (t) {
            return this.withCredentials = t, this
        }, setMimeType: function (t) {
            return this.mimeType = t, this
        }, setRequestHeader: function (t) {
            return this.requestHeader = t, this
        }
    }), Object.assign(An.prototype, {
        load: function (t, e, i, n) {
            var r = this, a = new En(r.manager);
            a.setPath(r.path), a.load(t, function (t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        }, parse: function (t, e) {
            for (var i = [], n = 0; n < t.length; n++) {
                var r = wn.parse(t[n]);
                i.push(r)
            }
            e(i)
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(Pn.prototype, {
        load: function (t, e, i, n) {
            function r(r) {
                l.load(t[r], function (t) {
                    t = a._parser(t, !0), o[r] = {
                        width: t.width,
                        height: t.height,
                        format: t.format,
                        mipmaps: t.mipmaps
                    }, 6 === (c += 1) && (1 === t.mipmapCount && (s.minFilter = 1006), s.format = t.format, s.needsUpdate = !0, e && e(s))
                }, i, n)
            }

            var a = this, o = [], s = new qe;
            s.image = o;
            var l = new En(this.manager);
            if (l.setPath(this.path), l.setResponseType("arraybuffer"), Array.isArray(t)) for (var c = 0, h = 0, u = t.length; h < u; ++h) r(h); else l.load(t, function (t) {
                if (t = a._parser(t, !0), t.isCubemap) for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) {
                    o[n] = {mipmaps: []};
                    for (var r = 0; r < t.mipmapCount; r++) o[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]), o[n].format = t.format, o[n].width = t.width, o[n].height = t.height
                } else s.image.width = t.width, s.image.height = t.height, s.mipmaps = t.mipmaps;
                1 === t.mipmapCount && (s.minFilter = 1006), s.format = t.format, s.needsUpdate = !0, e && e(s)
            }, i, n);
            return s
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(Ln.prototype, {
        load: function (t, e, i, n) {
            var r = this, a = new p, o = new En(this.manager);
            return o.setResponseType("arraybuffer"), o.setPath(this.path), o.load(t, function (t) {
                (t = r._parser(t)) && (void 0 !== t.image ? a.image = t.image : void 0 !== t.data && (a.image.width = t.width, a.image.height = t.height, a.image.data = t.data), a.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001, a.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001, a.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006, a.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008, a.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (a.format = t.format), void 0 !== t.type && (a.type = t.type), void 0 !== t.mipmaps && (a.mipmaps = t.mipmaps), 1 === t.mipmapCount && (a.minFilter = 1006), a.needsUpdate = !0, e && e(a, t))
            }, i, n), a
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(Cn.prototype, {
        crossOrigin: "anonymous", load: function (t, e, i, n) {
            function r() {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", a, !1), Ua.add(t, this), e && e(this), o.manager.itemEnd(t)
            }

            function a(e) {
                l.removeEventListener("load", r, !1), l.removeEventListener("error", a, !1), n && n(e), o.manager.itemError(t), o.manager.itemEnd(t)
            }

            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var o = this, s = Ua.get(t);
            if (void 0 !== s) return o.manager.itemStart(t), setTimeout(function () {
                e && e(s), o.manager.itemEnd(t)
            }, 0), s;
            var l = document.createElementNS("http://www.w3.org/1999/xhtml", "img");
            return l.addEventListener("load", r, !1), l.addEventListener("error", a, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (l.crossOrigin = this.crossOrigin), o.manager.itemStart(t), l.src = t, l
        }, setCrossOrigin: function (t) {
            return this.crossOrigin = t, this
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(Rn.prototype, {
        crossOrigin: "anonymous", load: function (t, e, i, n) {
            function r(i) {
                o.load(t[i], function (t) {
                    a.images[i] = t, 6 === ++s && (a.needsUpdate = !0, e && e(a))
                }, void 0, n)
            }

            var a = new lt, o = new Cn(this.manager);
            o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
            var s = 0;
            for (i = 0; i < t.length; ++i) r(i);
            return a
        }, setCrossOrigin: function (t) {
            return this.crossOrigin = t, this
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(On.prototype, {
        crossOrigin: "anonymous", load: function (t, e, i, n) {
            var r = new s, a = new Cn(this.manager);
            return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(t, function (i) {
                r.image = i, i = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r)
            }, i, n), r
        }, setCrossOrigin: function (t) {
            return this.crossOrigin = t, this
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(Dn.prototype, {
        getPoint: function () {
            return console.warn("THREE.Curve: .getPoint() not implemented."), null
        }, getPointAt: function (t, e) {
            return t = this.getUtoTmapping(t), this.getPoint(t, e)
        }, getPoints: function (t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
            return e
        }, getSpacedPoints: function (t) {
            void 0 === t && (t = 5);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPointAt(i / t));
            return e
        }, getLength: function () {
            var t = this.getLengths();
            return t[t.length - 1]
        }, getLengths: function (t) {
            if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths;
            this.needsUpdate = !1;
            var e = [], i = this.getPoint(0), n, r = 0;
            for (e.push(0), n = 1; n <= t; n++) {
                var a = this.getPoint(n / t);
                r += a.distanceTo(i), e.push(r), i = a
            }
            return this.cacheArcLengths = e
        }, updateArcLengths: function () {
            this.needsUpdate = !0, this.getLengths()
        }, getUtoTmapping: function (t, e) {
            var i = this.getLengths(), n = i.length;
            e = e ? e : t * i[n - 1];
            for (var r = 0, a = n - 1, o; r <= a;) if (t = Math.floor(r + (a - r) / 2), 0 > (o = i[t] - e)) r = t + 1; else {
                if (!(0 < o)) {
                    a = t;
                    break
                }
                a = t - 1
            }
            return t = a, i[t] === e ? t / (n - 1) : (r = i[t], (t + (e - r) / (i[t + 1] - r)) / (n - 1))
        }, getTangent: function (t) {
            var e = t - 1e-4;
            return t += 1e-4, 0 > e && (e = 0), 1 < t && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize()
        }, getTangentAt: function (t) {
            return t = this.getUtoTmapping(t), this.getTangent(t)
        }, computeFrenetFrames: function (t, e) {
            var i = new a, r = [], o = [], s = [], l = new a, c = new n, h;
            for (h = 0; h <= t; h++) {
                var u = h / t;
                r[h] = this.getTangentAt(u), r[h].normalize()
            }
            o[0] = new a, s[0] = new a, h = Number.MAX_VALUE, u = Math.abs(r[0].x);
            var p = Math.abs(r[0].y), d = Math.abs(r[0].z);
            for (u <= h && (h = u, i.set(1, 0, 0)), p <= h && (h = p, i.set(0, 1, 0)), d <= h && i.set(0, 0, 1), l.crossVectors(r[0], i).normalize(), o[0].crossVectors(r[0], l), s[0].crossVectors(r[0], o[0]), h = 1; h <= t; h++) o[h] = o[h - 1].clone(), s[h] = s[h - 1].clone(), l.crossVectors(r[h - 1], r[h]), l.length() > Number.EPSILON && (l.normalize(), i = Math.acos(la.clamp(r[h - 1].dot(r[h]), -1, 1)), o[h].applyMatrix4(c.makeRotationAxis(l, i))), s[h].crossVectors(r[h], o[h]);
            if (!0 === e) for (i = Math.acos(la.clamp(o[0].dot(o[t]), -1, 1)), i /= t, 0 < r[0].dot(l.crossVectors(o[0], o[t])) && (i = -i), h = 1; h <= t; h++) o[h].applyMatrix4(c.makeRotationAxis(r[h], i * h)), s[h].crossVectors(r[h], o[h]);
            return {tangents: r, normals: o, binormals: s}
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }, toJSON: function () {
            var t = {metadata: {version: 4.5, type: "Curve", generator: "Curve.toJSON"}};
            return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t
        }, fromJSON: function (t) {
            return this.arcLengthDivisions = t.arcLengthDivisions, this
        }
    }), In.prototype = Object.create(Dn.prototype), In.prototype.constructor = In, In.prototype.isEllipseCurve = !0, In.prototype.getPoint = function (t, e) {
        e = e || new i;
        for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, a = Math.abs(r) < Number.EPSILON; 0 > r;) r += n;
        for (; r > n;) r -= n;
        r < Number.EPSILON && (r = a ? 0 : n), !0 !== this.aClockwise || a || (r = r === n ? -n : r - n), n = this.aStartAngle + t * r, t = this.aX + this.xRadius * Math.cos(n);
        var o = this.aY + this.yRadius * Math.sin(n);
        return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), a = t - this.aX, o -= this.aY, t = a * n - o * r + this.aX, o = a * r + o * n + this.aY), e.set(t, o)
    }, In.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, In.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t
    }, In.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this
    }, Nn.prototype = Object.create(In.prototype), Nn.prototype.constructor = Nn, Nn.prototype.isArcCurve = !0;
    var Va = new a, Wa = new zn, qa = new zn, Xa = new zn;
    kn.prototype = Object.create(Dn.prototype), kn.prototype.constructor = kn, kn.prototype.isCatmullRomCurve3 = !0, kn.prototype.getPoint = function (t, e) {
        e = e || new a;
        var i = this.points, n = i.length;
        t *= n - (this.closed ? 0 : 1);
        var r = Math.floor(t);
        if (t -= r, this.closed ? r += 0 < r ? 0 : (Math.floor(Math.abs(r) / n) + 1) * n : 0 === t && r === n - 1 && (r = n - 2, t = 1), this.closed || 0 < r) var o = i[(r - 1) % n]; else Va.subVectors(i[0], i[1]).add(i[0]), o = Va;
        var s = i[r % n], l = i[(r + 1) % n];
        if (this.closed || r + 2 < n ? i = i[(r + 2) % n] : (Va.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Va), "centripetal" === this.curveType || "chordal" === this.curveType) {
            var c = "chordal" === this.curveType ? .5 : .25;
            n = Math.pow(o.distanceToSquared(s), c), r = Math.pow(s.distanceToSquared(l), c), c = Math.pow(l.distanceToSquared(i), c), 1e-4 > r && (r = 1), 1e-4 > n && (n = r), 1e-4 > c && (c = r), Wa.initNonuniformCatmullRom(o.x, s.x, l.x, i.x, n, r, c), qa.initNonuniformCatmullRom(o.y, s.y, l.y, i.y, n, r, c), Xa.initNonuniformCatmullRom(o.z, s.z, l.z, i.z, n, r, c)
        } else "catmullrom" === this.curveType && (Wa.initCatmullRom(o.x, s.x, l.x, i.x, this.tension), qa.initCatmullRom(o.y, s.y, l.y, i.y, this.tension), Xa.initCatmullRom(o.z, s.z, l.z, i.z, this.tension));
        return e.set(Wa.calc(t), qa.calc(t), Xa.calc(t)), e
    }, kn.prototype.copy = function (t) {
        Dn.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) this.points.push(t.points[e].clone());
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, kn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, i = this.points.length; e < i; e++) t.points.push(this.points[e].toArray());
        return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t
    }, kn.prototype.fromJSON = function (t) {
        Dn.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) {
            var n = t.points[e];
            this.points.push((new a).fromArray(n))
        }
        return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this
    }, Un.prototype = Object.create(Dn.prototype), Un.prototype.constructor = Un, Un.prototype.isCubicBezierCurve = !0, Un.prototype.getPoint = function (t, e) {
        e = e || new i;
        var n = this.v0, r = this.v1, a = this.v2, o = this.v3;
        return e.set(Hn(t, n.x, r.x, a.x, o.x), Hn(t, n.y, r.y, a.y, o.y)), e
    }, Un.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Un.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Un.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, Gn.prototype = Object.create(Dn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isCubicBezierCurve3 = !0, Gn.prototype.getPoint = function (t, e) {
        e = e || new a;
        var i = this.v0, n = this.v1, r = this.v2, o = this.v3;
        return e.set(Hn(t, i.x, n.x, r.x, o.x), Hn(t, i.y, n.y, r.y, o.y), Hn(t, i.z, n.z, r.z, o.z)), e
    }, Gn.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this
    }, Gn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t
    }, Gn.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this
    }, jn.prototype = Object.create(Dn.prototype), jn.prototype.constructor = jn, jn.prototype.isLineCurve = !0, jn.prototype.getPoint = function (t, e) {
        return e = e || new i, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
    }, jn.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e)
    }, jn.prototype.getTangent = function () {
        return this.v2.clone().sub(this.v1).normalize()
    }, jn.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, jn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, jn.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Vn.prototype = Object.create(Dn.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isLineCurve3 = !0, Vn.prototype.getPoint = function (t, e) {
        return e = e || new a, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e
    }, Vn.prototype.getPointAt = function (t, e) {
        return this.getPoint(t, e)
    }, Vn.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Vn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Vn.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Wn.prototype = Object.create(Dn.prototype), Wn.prototype.constructor = Wn, Wn.prototype.isQuadraticBezierCurve = !0, Wn.prototype.getPoint = function (t, e) {
        e = e || new i;
        var n = this.v0, r = this.v1, a = this.v2;
        return e.set(Fn(t, n.x, r.x, a.x), Fn(t, n.y, r.y, a.y)), e
    }, Wn.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, Wn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, Wn.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, qn.prototype = Object.create(Dn.prototype), qn.prototype.constructor = qn, qn.prototype.isQuadraticBezierCurve3 = !0, qn.prototype.getPoint = function (t, e) {
        e = e || new a;
        var i = this.v0, n = this.v1, r = this.v2;
        return e.set(Fn(t, i.x, n.x, r.x), Fn(t, i.y, n.y, r.y), Fn(t, i.z, n.z, r.z)), e
    }, qn.prototype.copy = function (t) {
        return Dn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this
    }, qn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t
    }, qn.prototype.fromJSON = function (t) {
        return Dn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this
    }, Xn.prototype = Object.create(Dn.prototype), Xn.prototype.constructor = Xn, Xn.prototype.isSplineCurve = !0, Xn.prototype.getPoint = function (t, e) {
        e = e || new i;
        var n = this.points, r = (n.length - 1) * t;
        t = Math.floor(r), r -= t
        ;var a = n[0 === t ? t : t - 1], o = n[t], s = n[t > n.length - 2 ? n.length - 1 : t + 1];
        return n = n[t > n.length - 3 ? n.length - 1 : t + 2], e.set(Bn(r, a.x, o.x, s.x, n.x), Bn(r, a.y, o.y, s.y, n.y)), e
    }, Xn.prototype.copy = function (t) {
        Dn.prototype.copy.call(this, t), this.points = [];
        for (var e = 0, i = t.points.length; e < i; e++) this.points.push(t.points[e].clone());
        return this
    }, Xn.prototype.toJSON = function () {
        var t = Dn.prototype.toJSON.call(this);
        t.points = [];
        for (var e = 0, i = this.points.length; e < i; e++) t.points.push(this.points[e].toArray());
        return t
    }, Xn.prototype.fromJSON = function (t) {
        Dn.prototype.fromJSON.call(this, t), this.points = [];
        for (var e = 0, n = t.points.length; e < n; e++) {
            var r = t.points[e];
            this.points.push((new i).fromArray(r))
        }
        return this
    };
    var Ya = Object.freeze({
        ArcCurve: Nn,
        CatmullRomCurve3: kn,
        CubicBezierCurve: Un,
        CubicBezierCurve3: Gn,
        EllipseCurve: In,
        LineCurve: jn,
        LineCurve3: Vn,
        QuadraticBezierCurve: Wn,
        QuadraticBezierCurve3: qn,
        SplineCurve: Xn
    });
    Yn.prototype = Object.assign(Object.create(Dn.prototype), {
        constructor: Yn, add: function (t) {
            this.curves.push(t)
        }, closePath: function () {
            var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1);
            t.equals(e) || this.curves.push(new jn(e, t))
        }, getPoint: function (t) {
            var e = t * this.getLength(), i = this.getCurveLengths();
            for (t = 0; t < i.length;) {
                if (i[t] >= e) return e = i[t] - e, t = this.curves[t], i = t.getLength(), t.getPointAt(0 === i ? 0 : 1 - e / i);
                t++
            }
            return null
        }, getLength: function () {
            var t = this.getCurveLengths();
            return t[t.length - 1]
        }, updateArcLengths: function () {
            this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
        }, getCurveLengths: function () {
            if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
            for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++) e += this.curves[i].getLength(), t.push(e);
            return this.cacheLengths = t
        }, getSpacedPoints: function (t) {
            void 0 === t && (t = 40);
            for (var e = [], i = 0; i <= t; i++) e.push(this.getPoint(i / t));
            return this.autoClose && e.push(e[0]), e
        }, getPoints: function (t) {
            t = t || 12;
            for (var e = [], i, n = 0, r = this.curves; n < r.length; n++) {
                var a = r[n];
                a = a.getPoints(a && a.isEllipseCurve ? 2 * t : a && (a.isLineCurve || a.isLineCurve3) ? 1 : a && a.isSplineCurve ? t * a.points.length : t);
                for (var o = 0; o < a.length; o++) {
                    var s = a[o];
                    i && i.equals(s) || (e.push(s), i = s)
                }
            }
            return this.autoClose && 1 < e.length && !e[e.length - 1].equals(e[0]) && e.push(e[0]), e
        }, copy: function (t) {
            Dn.prototype.copy.call(this, t), this.curves = [];
            for (var e = 0, i = t.curves.length; e < i; e++) this.curves.push(t.curves[e].clone());
            return this.autoClose = t.autoClose, this
        }, toJSON: function () {
            var t = Dn.prototype.toJSON.call(this);
            t.autoClose = this.autoClose, t.curves = [];
            for (var e = 0, i = this.curves.length; e < i; e++) t.curves.push(this.curves[e].toJSON());
            return t
        }, fromJSON: function (t) {
            Dn.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = [];
            for (var e = 0, i = t.curves.length; e < i; e++) {
                var n = t.curves[e];
                this.curves.push((new Ya[n.type]).fromJSON(n))
            }
            return this
        }
    }), Jn.prototype = Object.assign(Object.create(Yn.prototype), {
        constructor: Jn, setFromPoints: function (t) {
            this.moveTo(t[0].x, t[0].y);
            for (var e = 1, i = t.length; e < i; e++) this.lineTo(t[e].x, t[e].y)
        }, moveTo: function (t, e) {
            this.currentPoint.set(t, e)
        }, lineTo: function (t, e) {
            var n = new jn(this.currentPoint.clone(), new i(t, e));
            this.curves.push(n), this.currentPoint.set(t, e)
        }, quadraticCurveTo: function (t, e, n, r) {
            t = new Wn(this.currentPoint.clone(), new i(t, e), new i(n, r)), this.curves.push(t), this.currentPoint.set(n, r)
        }, bezierCurveTo: function (t, e, n, r, a, o) {
            t = new Un(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(a, o)), this.curves.push(t), this.currentPoint.set(a, o)
        }, splineThru: function (t) {
            var e = [this.currentPoint.clone()].concat(t);
            e = new Xn(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1])
        }, arc: function (t, e, i, n, r, a) {
            this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, a)
        }, absarc: function (t, e, i, n, r, a) {
            this.absellipse(t, e, i, i, n, r, a)
        }, ellipse: function (t, e, i, n, r, a, o, s) {
            this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, a, o, s)
        }, absellipse: function (t, e, i, n, r, a, o, s) {
            t = new In(t, e, i, n, r, a, o, s), 0 < this.curves.length && (e = t.getPoint(0), e.equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t)
        }, copy: function (t) {
            return Yn.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this
        }, toJSON: function () {
            var t = Yn.prototype.toJSON.call(this);
            return t.currentPoint = this.currentPoint.toArray(), t
        }, fromJSON: function (t) {
            return Yn.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this
        }
    }), Zn.prototype = Object.assign(Object.create(Jn.prototype), {
        constructor: Zn, getPointsHoles: function (t) {
            for (var e = [], i = 0, n = this.holes.length; i < n; i++) e[i] = this.holes[i].getPoints(t);
            return e
        }, extractPoints: function (t) {
            return {shape: this.getPoints(t), holes: this.getPointsHoles(t)}
        }, copy: function (t) {
            Jn.prototype.copy.call(this, t), this.holes = [];
            for (var e = 0, i = t.holes.length; e < i; e++) this.holes.push(t.holes[e].clone());
            return this
        }, toJSON: function () {
            var t = Jn.prototype.toJSON.call(this);
            t.uuid = this.uuid, t.holes = [];
            for (var e = 0, i = this.holes.length; e < i; e++) t.holes.push(this.holes[e].toJSON());
            return t
        }, fromJSON: function (t) {
            Jn.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = [];
            for (var e = 0, i = t.holes.length; e < i; e++) {
                var n = t.holes[e];
                this.holes.push((new Jn).fromJSON(n))
            }
            return this
        }
    }), $n.prototype = Object.assign(Object.create(S.prototype), {
        constructor: $n, isLight: !0, copy: function (t) {
            return S.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this
        }, toJSON: function (t) {
            return t = S.prototype.toJSON.call(this, t), t.object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t
        }
    }), Qn.prototype = Object.assign(Object.create($n.prototype), {
        constructor: Qn,
        isHemisphereLight: !0,
        copy: function (t) {
            return $n.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this
        }
    }), Object.assign(Kn.prototype, {
        copy: function (t) {
            return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, toJSON: function () {
            var t = {};
            return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t
        }
    }), tr.prototype = Object.assign(Object.create(Kn.prototype), {
        constructor: tr,
        isSpotLightShadow: !0,
        update: function (t) {
            var e = this.camera, i = 2 * la.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height;
            t = t.distance || e.far, i === e.fov && n === e.aspect && t === e.far || (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix())
        }
    }), er.prototype = Object.assign(Object.create($n.prototype), {
        constructor: er,
        isSpotLight: !0,
        copy: function (t) {
            return $n.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), ir.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ir,
        isPointLight: !0,
        copy: function (t) {
            return $n.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this
        }
    }), nr.prototype = Object.assign(Object.create(be.prototype), {
        constructor: nr, isOrthographicCamera: !0, copy: function (t, e) {
            return be.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this
        }, setViewOffset: function (t, e, i, n, r, a) {
            null === this.view && (this.view = {
                enabled: !0,
                fullWidth: 1,
                fullHeight: 1,
                offsetX: 0,
                offsetY: 0,
                width: 1,
                height: 1
            }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
        }, clearViewOffset: function () {
            null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix()
        }, updateProjectionMatrix: function () {
            var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom),
                i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - t;
            if (i += t, t = n + e, e = n - e, null !== this.view && this.view.enabled) {
                i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight);
                var a = (this.right - this.left) / this.view.width;
                n = (this.top - this.bottom) / this.view.height, r += this.view.offsetX / i * a, i = r + this.view.width / i * a, t -= this.view.offsetY / e * n, e = t - this.view.height / e * n
            }
            this.projectionMatrix.makeOrthographic(r, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix)
        }, toJSON: function (t) {
            return t = S.prototype.toJSON.call(this, t), t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t
        }
    }), rr.prototype = Object.assign(Object.create(Kn.prototype), {constructor: rr}), ar.prototype = Object.assign(Object.create($n.prototype), {
        constructor: ar,
        isDirectionalLight: !0,
        copy: function (t) {
            return $n.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this
        }
    }), or.prototype = Object.assign(Object.create($n.prototype), {
        constructor: or,
        isAmbientLight: !0
    }), sr.prototype = Object.assign(Object.create($n.prototype), {
        constructor: sr,
        isRectAreaLight: !0,
        copy: function (t) {
            return $n.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this
        },
        toJSON: function (t) {
            return t = $n.prototype.toJSON.call(this, t), t.object.width = this.width, t.object.height = this.height, t
        }
    }), Object.assign(lr.prototype, {
        load: function (t, e, i, n) {
            var r = this, a = new En(r.manager);
            a.setPath(r.path), a.load(t, function (t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        }, parse: function (t) {
            function e(t) {
                return void 0 === r[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), r[t]
            }

            var r = this.textures, s = new Fa[t.type];
            if (void 0 !== t.uuid && (s.uuid = t.uuid), void 0 !== t.name && (s.name = t.name), void 0 !== t.color && s.color.setHex(t.color), void 0 !== t.roughness && (s.roughness = t.roughness), void 0 !== t.metalness && (s.metalness = t.metalness), void 0 !== t.emissive && s.emissive.setHex(t.emissive), void 0 !== t.specular && s.specular.setHex(t.specular), void 0 !== t.shininess && (s.shininess = t.shininess), void 0 !== t.clearCoat && (s.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (s.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (s.vertexColors = t.vertexColors), void 0 !== t.fog && (s.fog = t.fog), void 0 !== t.flatShading && (s.flatShading = t.flatShading), void 0 !== t.blending && (s.blending = t.blending), void 0 !== t.combine && (s.combine = t.combine), void 0 !== t.side && (s.side = t.side), void 0 !== t.opacity && (s.opacity = t.opacity), void 0 !== t.transparent && (s.transparent = t.transparent), void 0 !== t.alphaTest && (s.alphaTest = t.alphaTest), void 0 !== t.depthTest && (s.depthTest = t.depthTest), void 0 !== t.depthWrite && (s.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (s.colorWrite = t.colorWrite), void 0 !== t.wireframe && (s.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (s.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (s.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (s.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (s.rotation = t.rotation), 1 !== t.linewidth && (s.linewidth = t.linewidth), void 0 !== t.dashSize && (s.dashSize = t.dashSize), void 0 !== t.gapSize && (s.gapSize = t.gapSize), void 0 !== t.scale && (s.scale = t.scale), void 0 !== t.polygonOffset && (s.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (s.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (s.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (s.skinning = t.skinning), void 0 !== t.morphTargets && (s.morphTargets = t.morphTargets), void 0 !== t.dithering && (s.dithering = t.dithering), void 0 !== t.visible && (s.visible = t.visible), void 0 !== t.userData && (s.userData = t.userData), void 0 !== t.uniforms) for (var c in t.uniforms) {
                var h = t.uniforms[c];
                switch (s.uniforms[c] = {}, h.type) {
                    case"t":
                        s.uniforms[c].value = e(h.value);
                        break;
                    case"c":
                        s.uniforms[c].value = (new x).setHex(h.value);
                        break;
                    case"v2":
                        s.uniforms[c].value = (new i).fromArray(h.value);
                        break;
                    case"v3":
                        s.uniforms[c].value = (new a).fromArray(h.value);
                        break;
                    case"v4":
                        s.uniforms[c].value = (new l).fromArray(h.value);
                        break;
                    case"m3":
                        s.uniforms[c].value = (new o).fromArray(h.value);
                    case"m4":
                        s.uniforms[c].value = (new n).fromArray(h.value);
                        break;
                    default:
                        s.uniforms[c].value = h.value
                }
            }
            if (void 0 !== t.defines && (s.defines = t.defines), void 0 !== t.vertexShader && (s.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (s.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var u in t.extensions) s.extensions[u] = t.extensions[u];
            return void 0 !== t.shading && (s.flatShading = 1 === t.shading), void 0 !== t.size && (s.size = t.size), void 0 !== t.sizeAttenuation && (s.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (s.map = e(t.map)), void 0 !== t.alphaMap && (s.alphaMap = e(t.alphaMap), s.transparent = !0), void 0 !== t.bumpMap && (s.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (s.bumpScale = t.bumpScale), void 0 !== t.normalMap && (s.normalMap = e(t.normalMap)), void 0 !== t.normalMapType && (s.normalMapType = t.normalMapType), void 0 !== t.normalScale && (c = t.normalScale, !1 === Array.isArray(c) && (c = [c, c]), s.normalScale = (new i).fromArray(c)), void 0 !== t.displacementMap && (s.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (s.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (s.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (s.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (s.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (s.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (s.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (s.specularMap = e(t.specularMap)), void 0 !== t.envMap && (s.envMap = e(t.envMap)), void 0 !== t.envMapIntensity && (s.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (s.reflectivity = t.reflectivity), void 0 !== t.lightMap && (s.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (s.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (s.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (s.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (s.gradientMap = e(t.gradientMap)), s
        }, setPath: function (t) {
            return this.path = t, this
        }, setTextures: function (t) {
            return this.textures = t, this
        }
    });
    var Ja = {
        decodeText: function (t) {
            if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t);
            for (var e = "", i = 0, n = t.length; i < n; i++) e += String.fromCharCode(t[i]);
            return decodeURIComponent(escape(e))
        }, extractUrlBase: function (t) {
            var e = t.lastIndexOf("/");
            return -1 === e ? "./" : t.substr(0, e + 1)
        }
    };
    Object.assign(cr.prototype, {
        load: function (t, e, i, n) {
            var r = this, a = new En(r.manager);
            a.setPath(r.path), a.load(t, function (t) {
                e(r.parse(JSON.parse(t)))
            }, i, n)
        }, parse: function (t) {
            var e = new F, i = t.data.index;
            void 0 !== i && (i = new Za[i.type](i.array), e.setIndex(new A(i, 1)));
            var n = t.data.attributes;
            for (o in n) {
                var r = n[o];
                i = new Za[r.type](r.array), e.addAttribute(o, new A(i, r.itemSize, r.normalized))
            }
            var o = t.data.groups || t.data.drawcalls || t.data.offsets;
            if (void 0 !== o) for (i = 0, n = o.length; i !== n; ++i) r = o[i], e.addGroup(r.start, r.count, r.materialIndex);
            return o = t.data.boundingSphere, void 0 !== o && (i = new a, void 0 !== o.center && i.fromArray(o.center), e.boundingSphere = new f(i, o.radius)), t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e
        }, setPath: function (t) {
            return this.path = t, this
        }
    });
    var Za = {
        Int8Array: Int8Array,
        Uint8Array: Uint8Array,
        Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array,
        Int16Array: Int16Array,
        Uint16Array: Uint16Array,
        Int32Array: Int32Array,
        Uint32Array: Uint32Array,
        Float32Array: Float32Array,
        Float64Array: Float64Array
    };
    Object.assign(hr.prototype, {
        crossOrigin: "anonymous", load: function (t, e, i, n) {
            var r = this, a = void 0 === this.path ? Ja.extractUrlBase(t) : this.path;
            this.resourcePath = this.resourcePath || a, a = new En(r.manager), a.setPath(this.path), a.load(t, function (i) {
                var a = null;
                try {
                    a = JSON.parse(i)
                } catch (e) {
                    return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message)
                }
                i = a.metadata, void 0 === i || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + t) : r.parse(a, e)
            }, i, n)
        }, setPath: function (t) {
            return this.path = t, this
        }, setResourcePath: function (t) {
            return this.resourcePath = t, this
        }, setCrossOrigin: function (t) {
            return this.crossOrigin = t, this
        }, parse: function (t, e) {
            var i = this.parseShape(t.shapes);
            i = this.parseGeometries(t.geometries, i);
            var n = this.parseImages(t.images, function () {
                void 0 !== e && e(r)
            });
            n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n);
            var r = this.parseObject(t.object, i, n);
            return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r), r
        }, parseShape: function (t) {
            var e = {};
            if (void 0 !== t) for (var i = 0, n = t.length; i < n; i++) {
                var r = (new Zn).fromJSON(t[i]);
                e[r.uuid] = r
            }
            return e
        }, parseGeometries: function (t, e) {
            var i = {};
            if (void 0 !== t) for (var n = new cr, r = 0, a = t.length; r < a; r++) {
                var o = t[r];
                switch (o.type) {
                    case"PlaneGeometry":
                    case"PlaneBufferGeometry":
                        var s = new Ba[o.type](o.width, o.height, o.widthSegments, o.heightSegments);
                        break;
                    case"BoxGeometry":
                    case"BoxBufferGeometry":
                    case"CubeGeometry":
                        s = new Ba[o.type](o.width, o.height, o.depth, o.widthSegments, o.heightSegments, o.depthSegments);
                        break;
                    case"CircleGeometry":
                    case"CircleBufferGeometry":
                        s = new Ba[o.type](o.radius, o.segments, o.thetaStart, o.thetaLength);
                        break;
                    case"CylinderGeometry":
                    case"CylinderBufferGeometry":
                        s = new Ba[o.type](o.radiusTop, o.radiusBottom, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                        break;
                    case"ConeGeometry":
                    case"ConeBufferGeometry":
                        s = new Ba[o.type](o.radius, o.height, o.radialSegments, o.heightSegments, o.openEnded, o.thetaStart, o.thetaLength);
                        break;
                    case"SphereGeometry":
                    case"SphereBufferGeometry":
                        s = new Ba[o.type](o.radius, o.widthSegments, o.heightSegments, o.phiStart, o.phiLength, o.thetaStart, o.thetaLength);
                        break;
                    case"DodecahedronGeometry":
                    case"DodecahedronBufferGeometry":
                    case"IcosahedronGeometry":
                    case"IcosahedronBufferGeometry":
                    case"OctahedronGeometry":
                    case"OctahedronBufferGeometry":
                    case"TetrahedronGeometry":
                    case"TetrahedronBufferGeometry":
                        s = new Ba[o.type](o.radius, o.detail);
                        break;
                    case"RingGeometry":
                    case"RingBufferGeometry":
                        s = new Ba[o.type](o.innerRadius, o.outerRadius, o.thetaSegments, o.phiSegments, o.thetaStart, o.thetaLength);
                        break;
                    case"TorusGeometry":
                    case"TorusBufferGeometry":
                        s = new Ba[o.type](o.radius, o.tube, o.radialSegments, o.tubularSegments, o.arc);
                        break;
                    case"TorusKnotGeometry":
                    case"TorusKnotBufferGeometry":
                        s = new Ba[o.type](o.radius, o.tube, o.tubularSegments, o.radialSegments, o.p, o.q);
                        break;
                    case"LatheGeometry":
                    case"LatheBufferGeometry":
                        s = new Ba[o.type](o.points, o.segments, o.phiStart, o.phiLength);
                        break;
                    case"PolyhedronGeometry":
                    case"PolyhedronBufferGeometry":
                        s = new Ba[o.type](o.vertices, o.indices, o.radius, o.details);
                        break;
                    case"ShapeGeometry":
                    case"ShapeBufferGeometry":
                        s = [];
                        for (var l = 0, c = o.shapes.length; l < c; l++) {
                            var h = e[o.shapes[l]];
                            s.push(h)
                        }
                        s = new Ba[o.type](s, o.curveSegments);
                        break;
                    case"ExtrudeGeometry":
                    case"ExtrudeBufferGeometry":
                        for (s = [], l = 0, c = o.shapes.length; l < c; l++) h = e[o.shapes[l]], s.push(h);
                        l = o.options.extrudePath, void 0 !== l && (o.options.extrudePath = (new Ya[l.type]).fromJSON(l)), s = new Ba[o.type](s, o.options);
                        break;
                    case"BufferGeometry":
                        s = n.parse(o);
                        break;
                    case"Geometry":
                        "THREE" in window && "LegacyJSONLoader" in THREE ? s = (new THREE.LegacyJSONLoader).parse(o, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".');
                        break;
                    default:
                        console.warn('THREE.ObjectLoader: Unsupported geometry type "' + o.type + '"');
                        continue
                }
                s.uuid = o.uuid, void 0 !== o.name && (s.name = o.name), !0 === s.isBufferGeometry && void 0 !== o.userData && (s.userData = o.userData), i[o.uuid] = s
            }
            return i
        }, parseMaterials: function (t, e) {
            var i = {}, n = {};
            if (void 0 !== t) {
                var r = new lr;
                r.setTextures(e), e = 0;
                for (var a = t.length; e < a; e++) {
                    var o = t[e];
                    if ("MultiMaterial" === o.type) {
                        for (var s = [], l = 0; l < o.materials.length; l++) {
                            var c = o.materials[l];
                            void 0 === i[c.uuid] && (i[c.uuid] = r.parse(c)), s.push(i[c.uuid])
                        }
                        n[o.uuid] = s
                    } else void 0 === i[o.uuid] && (i[o.uuid] = r.parse(o)), n[o.uuid] = i[o.uuid]
                }
            }
            return n
        }, parseAnimations: function (t) {
            for (var e = [], i = 0; i < t.length; i++) {
                var n = t[i], r = wn.parse(n);
                void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r)
            }
            return e
        }, parseImages: function (t, e) {
            function i(t) {
                return n.manager.itemStart(t), a.load(t, function () {
                    n.manager.itemEnd(t)
                }, void 0, function () {
                    n.manager.itemError(t), n.manager.itemEnd(t)
                })
            }

            var n = this, r = {};
            if (void 0 !== t && 0 < t.length) {
                e = new Sn(e);
                var a = new Cn(e);
                a.setCrossOrigin(this.crossOrigin), e = 0;
                for (var o = t.length; e < o; e++) {
                    var s = t[e], l = s.url;
                    if (Array.isArray(l)) {
                        r[s.uuid] = [];
                        for (var c = 0, h = l.length; c < h; c++) {
                            var u = l[c];
                            u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u, r[s.uuid].push(i(u))
                        }
                    } else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.resourcePath + s.url, r[s.uuid] = i(u)
                }
            }
            return r
        }, parseTextures: function (t, e) {
            function i(t, e) {
                return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t])
            }

            var n = {};
            if (void 0 !== t) for (var r = 0, a = t.length; r < a; r++) {
                var o = t[r];
                void 0 === o.image && console.warn('THREE.ObjectLoader: No "image" specified for', o.uuid), void 0 === e[o.image] && console.warn("THREE.ObjectLoader: Undefined image", o.image);
                var l = Array.isArray(e[o.image]) ? new lt(e[o.image]) : new s(e[o.image]);
                l.needsUpdate = !0, l.uuid = o.uuid, void 0 !== o.name && (l.name = o.name), void 0 !== o.mapping && (l.mapping = i(o.mapping, $a)), void 0 !== o.offset && l.offset.fromArray(o.offset), void 0 !== o.repeat && l.repeat.fromArray(o.repeat), void 0 !== o.center && l.center.fromArray(o.center), void 0 !== o.rotation && (l.rotation = o.rotation), void 0 !== o.wrap && (l.wrapS = i(o.wrap[0], Qa), l.wrapT = i(o.wrap[1], Qa)), void 0 !== o.format && (l.format = o.format), void 0 !== o.type && (l.type = o.type), void 0 !== o.encoding && (l.encoding = o.encoding), void 0 !== o.minFilter && (l.minFilter = i(o.minFilter, Ka)), void 0 !== o.magFilter && (l.magFilter = i(o.magFilter, Ka)), void 0 !== o.anisotropy && (l.anisotropy = o.anisotropy), void 0 !== o.flipY && (l.flipY = o.flipY), void 0 !== o.premultiplyAlpha && (l.premultiplyAlpha = o.premultiplyAlpha), void 0 !== o.unpackAlignment && (l.unpackAlignment = o.unpackAlignment), n[o.uuid] = l
            }
            return n
        }, parseObject: function (t, e, i) {
            function n(t) {
                return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t]
            }

            function r(t) {
                if (void 0 !== t) {
                    if (Array.isArray(t)) {
                        for (var e = [], n = 0, r = t.length; n < r; n++) {
                            var a = t[n];
                            void 0 === i[a] && console.warn("THREE.ObjectLoader: Undefined material", a), e.push(i[a])
                        }
                        return e
                    }
                    return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t]
                }
            }

            switch (t.type) {
                case"Scene":
                    var a = new Ce;
                    void 0 !== t.background && Number.isInteger(t.background) && (a.background = new x(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? a.fog = new Le(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (a.fog = new Pe(t.fog.color, t.fog.density)));
                    break;
                case"PerspectiveCamera":
                    a = new we(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (a.focus = t.focus), void 0 !== t.zoom && (a.zoom = t.zoom), void 0 !== t.filmGauge && (a.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (a.filmOffset = t.filmOffset), void 0 !== t.view && (a.view = Object.assign({}, t.view));
                    break;
                case"OrthographicCamera":
                    a = new nr(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (a.zoom = t.zoom), void 0 !== t.view && (a.view = Object.assign({}, t.view));
                    break;
                case"AmbientLight":
                    a = new or(t.color, t.intensity);
                    break;
                case"DirectionalLight":
                    a = new ar(t.color, t.intensity);
                    break;
                case"PointLight":
                    a = new ir(t.color, t.intensity, t.distance, t.decay);
                    break;
                case"RectAreaLight":
                    a = new sr(t.color, t.intensity, t.width, t.height);
                    break;
                case"SpotLight":
                    a = new er(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay);
                    break;
                case"HemisphereLight":
                    a = new Qn(t.color, t.groundColor, t.intensity);
                    break;
                case"SkinnedMesh":
                    console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.");
                case"Mesh":
                    a = n(t.geometry);
                    var o = r(t.material);
                    a = a.bones && 0 < a.bones.length ? new ze(a, o) : new J(a, o), void 0 !== t.drawMode && a.setDrawMode(t.drawMode);
                    break;
                case"LOD":
                    a = new Ne;
                    break;
                case"Line":
                    a = new He(n(t.geometry), r(t.material), t.mode);
                    break;
                case"LineLoop":
                    a = new Ge(n(t.geometry), r(t.material));
                    break;
                case"LineSegments":
                    a = new Ue(n(t.geometry), r(t.material));
                    break;
                case"PointCloud":
                case"Points":
                    a = new Ve(n(t.geometry), r(t.material));
                    break;
                case"Sprite":
                    a = new Ie(r(t.material));
                    break;
                case"Group":
                    a = new _e;
                    break;
                default:
                    a = new S
            }
            if (a.uuid = t.uuid, void 0 !== t.name && (a.name = t.name), void 0 !== t.matrix ? (a.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (a.matrixAutoUpdate = t.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (void 0 !== t.position && a.position.fromArray(t.position), void 0 !== t.rotation && a.rotation.fromArray(t.rotation), void 0 !== t.quaternion && a.quaternion.fromArray(t.quaternion), void 0 !== t.scale && a.scale.fromArray(t.scale)), void 0 !== t.castShadow && (a.castShadow = t.castShadow), void 0 !== t.receiveShadow && (a.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (a.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (a.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && a.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (a.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (a.visible = t.visible), void 0 !== t.frustumCulled && (a.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (a.renderOrder = t.renderOrder), void 0 !== t.userData && (a.userData = t.userData), void 0 !== t.layers && (a.layers.mask = t.layers), void 0 !== t.children) {
                o = t.children;
                for (var s = 0; s < o.length; s++) a.add(this.parseObject(o[s], e, i))
            }
            if ("LOD" === t.type) for (t = t.levels, o = 0; o < t.length; o++) {
                s = t[o];
                var l = a.getObjectByProperty("uuid", s.object);
                void 0 !== l && a.addLevel(l, s.distance)
            }
            return a
        }
    });
    var $a = {
        UVMapping: 300,
        CubeReflectionMapping: 301,
        CubeRefractionMapping: 302,
        EquirectangularReflectionMapping: 303,
        EquirectangularRefractionMapping: 304,
        SphericalReflectionMapping: 305,
        CubeUVReflectionMapping: 306,
        CubeUVRefractionMapping: 307
    }, Qa = {RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002}, Ka = {
        NearestFilter: 1003,
        NearestMipMapNearestFilter: 1004,
        NearestMipMapLinearFilter: 1005,
        LinearFilter: 1006,
        LinearMipMapNearestFilter: 1007,
        LinearMipMapLinearFilter: 1008
    };
    ur.prototype = {
        constructor: ur, setOptions: function (t) {
            return this.options = t, this
        }, load: function (t, e, i, n) {
            void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t);
            var r = this, a = Ua.get(t);
            if (void 0 !== a) return r.manager.itemStart(t), setTimeout(function () {
                e && e(a), r.manager.itemEnd(t)
            }, 0), a;
            fetch(t).then(function (t) {
                return t.blob()
            }).then(function (t) {
                return createImageBitmap(t, r.options)
            }).then(function (i) {
                Ua.add(t, i), e && e(i), r.manager.itemEnd(t)
            }).catch(function (e) {
                n && n(e), r.manager.itemError(t), r.manager.itemEnd(t)
            })
        }, setCrossOrigin: function () {
            return this
        }, setPath: function (t) {
            return this.path = t, this
        }
    }, Object.assign(pr.prototype, {
        moveTo: function (t, e) {
            this.currentPath = new Jn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e)
        }, lineTo: function (t, e) {
            this.currentPath.lineTo(t, e)
        }, quadraticCurveTo: function (t, e, i, n) {
            this.currentPath.quadraticCurveTo(t, e, i, n)
        }, bezierCurveTo: function (t, e, i, n, r, a) {
            this.currentPath.bezierCurveTo(t, e, i, n, r, a)
        }, splineThru: function (t) {
            this.currentPath.splineThru(t)
        }, toShapes: function (t, e) {
            function i(t) {
                for (var e = [], i = 0, n = t.length; i < n; i++) {
                    var r = t[i], a = new Zn;
                    a.curves = r.curves, e.push(a)
                }
                return e
            }

            function n(t, e) {
                for (var i = e.length, n = !1, r = i - 1, a = 0; a < i; r = a++) {
                    var o = e[r], s = e[a], l = s.x - o.x, c = s.y - o.y;
                    if (Math.abs(c) > Number.EPSILON) {
                        if (0 > c && (o = e[a], l = -l, s = e[r], c = -c), !(t.y < o.y || t.y > s.y)) if (t.y === o.y) {
                            if (t.x === o.x) return !0
                        } else {
                            if (0 === (r = c * (t.x - o.x) - l * (t.y - o.y))) return !0;
                            0 > r || (n = !n)
                        }
                    } else if (t.y === o.y && (s.x <= t.x && t.x <= o.x || o.x <= t.x && t.x <= s.x)) return !0
                }
                return n
            }

            var r = za.isClockWise, a = this.subPaths;
            if (0 === a.length) return [];
            if (!0 === e) return i(a);
            if (e = [], 1 === a.length) {
                var o = a[0], s = new Zn;
                return s.curves = o.curves, e.push(s), e
            }
            var l = !r(a[0].getPoints());
            l = t ? !l : l, s = [];
            var c = [], h = [], u = 0;
            c[u] = void 0, h[u] = [];
            for (var p = 0, d = a.length; p < d; p++) {
                o = a[p];
                var f = o.getPoints(), m = r(f);
                (m = t ? !m : m) ? (!l && c[u] && u++, c[u] = {
                    s: new Zn,
                    p: f
                }, c[u].s.curves = o.curves, l && u++, h[u] = []) : h[u].push({h: o, p: f[0]})
            }
            if (!c[0]) return i(a);
            if (1 < c.length) {
                for (p = !1, t = [], r = 0, a = c.length; r < a; r++) s[r] = [];
                for (r = 0, a = c.length; r < a; r++) for (o = h[r], m = 0; m < o.length; m++) {
                    for (l = o[m], u = !0, f = 0; f < c.length; f++) n(l.p, c[f].p) && (r !== f && t.push({
                        froms: r,
                        tos: f,
                        hole: m
                    }), u ? (u = !1, s[f].push(l)) : p = !0);
                    u && s[r].push(l)
                }
                0 < t.length && (p || (h = s))
            }
            for (p = 0, r = c.length; p < r; p++) for (s = c[p].s, e.push(s), t = h[p], a = 0, o = t.length; a < o; a++) s.holes.push(t[a].h);
            return e
        }
    }), Object.assign(dr.prototype, {
        isFont: !0, generateShapes: function (t, e) {
            void 0 === e && (e = 100);
            var i = [], n = e;
            e = this.data;
            var r = Array.from ? Array.from(t) : String(t).split("");
            n /= e.resolution;
            var a = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n;
            t = [];
            for (var o = 0, s = 0, l = 0; l < r.length; l++) {
                var c = r[l];
                if ("\n" === c) o = 0, s -= a; else {
                    var h = n, u = o, p = s;
                    if (c = e.glyphs[c] || e.glyphs["?"]) {
                        var d = new pr;
                        if (c.o) for (var f = c._cachedOutline || (c._cachedOutline = c.o.split(" ")), m = 0, g = f.length; m < g;) switch (f[m++]) {
                            case"m":
                                var v = f[m++] * h + u, y = f[m++] * h + p;
                                d.moveTo(v, y);
                                break;
                            case"l":
                                v = f[m++] * h + u, y = f[m++] * h + p, d.lineTo(v, y);
                                break;
                            case"q":
                                var x = f[m++] * h + u, _ = f[m++] * h + p, b = f[m++] * h + u, w = f[m++] * h + p;
                                d.quadraticCurveTo(b, w, x, _);
                                break;
                            case"b":
                                x = f[m++] * h + u, _ = f[m++] * h + p, b = f[m++] * h + u, w = f[m++] * h + p, v = f[m++] * h + u, y = f[m++] * h + p, d.bezierCurveTo(b, w, v, y, x, _)
                        }
                        h = {offsetX: c.ha * h, path: d}
                    } else h = void 0;
                    o += h.offsetX, t.push(h.path)
                }
            }
            for (e = 0, r = t.length; e < r; e++) Array.prototype.push.apply(i, t[e].toShapes());
            return i
        }
    }), Object.assign(fr.prototype, {
        load: function (t, e, i, n) {
            var r = this, a = new En(this.manager);
            a.setPath(this.path), a.load(t, function (t) {
                try {
                    var i = JSON.parse(t)
                } catch (e) {
                    console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2))
                }
                t = r.parse(i), e && e(t)
            }, i, n)
        }, parse: function (t) {
            return new dr(t)
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), mr.Handlers = {
        handlers: [], add: function (t, e) {
            this.handlers.push(t, e)
        }, get: function (t) {
            for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) {
                var r = e[i + 1];
                if (e[i].test(t)) return r
            }
            return null
        }
    }, Object.assign(mr.prototype, {
        crossOrigin: "anonymous", onLoadStart: function () {
        }, onLoadProgress: function () {
        }, onLoadComplete: function () {
        }, initMaterials: function (t, e, i) {
            for (var n = [], r = 0; r < t.length; ++r) n[r] = this.createMaterial(t[r], e, i);
            return n
        }, createMaterial: function () {
            var t = {
                NoBlending: 0,
                NormalBlending: 1,
                AdditiveBlending: 2,
                SubtractiveBlending: 3,
                MultiplyBlending: 4,
                CustomBlending: 5
            }, e = new x, i = new On, n = new lr;
            return function (r, a, o) {
                function s(t, e, n, r, s) {
                    t = a + t;
                    var c = mr.Handlers.get(t);
                    return null !== c ? t = c.load(t) : (i.setCrossOrigin(o), t = i.load(t)), void 0 !== e && (t.repeat.fromArray(e), 1 !== e[0] && (t.wrapS = 1e3), 1 !== e[1] && (t.wrapT = 1e3)), void 0 !== n && t.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (t.wrapS = 1e3), "mirror" === r[0] && (t.wrapS = 1002), "repeat" === r[1] && (t.wrapT = 1e3), "mirror" === r[1] && (t.wrapT = 1002)), void 0 !== s && (t.anisotropy = s), e = la.generateUUID(), l[e] = t, e
                }

                var l = {}, c = {uuid: la.generateUUID(), type: "MeshLambertMaterial"}, h;
                for (h in r) {
                    var u = r[h];
                    switch (h) {
                        case"DbgColor":
                        case"DbgIndex":
                        case"opticalDensity":
                        case"illumination":
                            break;
                        case"DbgName":
                            c.name = u;
                            break;
                        case"blending":
                            c.blending = t[u];
                            break;
                        case"colorAmbient":
                        case"mapAmbient":
                            console.warn("THREE.Loader.createMaterial:", h, "is no longer supported.");
                            break;
                        case"colorDiffuse":
                            c.color = e.fromArray(u).getHex();
                            break;
                        case"colorSpecular":
                            c.specular = e.fromArray(u).getHex();
                            break;
                        case"colorEmissive":
                            c.emissive = e.fromArray(u).getHex();
                            break;
                        case"specularCoef":
                            c.shininess = u;
                            break;
                        case"shading":
                            "basic" === u.toLowerCase() && (c.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (c.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (c.type = "MeshStandardMaterial");
                            break;
                        case"mapDiffuse":
                            c.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy);
                            break;
                        case"mapDiffuseRepeat":
                        case"mapDiffuseOffset":
                        case"mapDiffuseWrap":
                        case"mapDiffuseAnisotropy":
                            break;
                        case"mapEmissive":
                            c.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy);
                            break;
                        case"mapEmissiveRepeat":
                        case"mapEmissiveOffset":
                        case"mapEmissiveWrap":
                        case"mapEmissiveAnisotropy":
                            break;
                        case"mapLight":
                            c.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy);
                            break;
                        case"mapLightRepeat":
                        case"mapLightOffset":
                        case"mapLightWrap":
                        case"mapLightAnisotropy":
                            break;
                        case"mapAO":
                            c.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy);
                            break;
                        case"mapAORepeat":
                        case"mapAOOffset":
                        case"mapAOWrap":
                        case"mapAOAnisotropy":
                            break;
                        case"mapBump":
                            c.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy);
                            break;
                        case"mapBumpScale":
                            c.bumpScale = u;
                            break;
                        case"mapBumpRepeat":
                        case"mapBumpOffset":
                        case"mapBumpWrap":
                        case"mapBumpAnisotropy":
                            break;
                        case"mapNormal":
                            c.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy);
                            break;
                        case"mapNormalFactor":
                            c.normalScale = u;
                            break;
                        case"mapNormalRepeat":
                        case"mapNormalOffset":
                        case"mapNormalWrap":
                        case"mapNormalAnisotropy":
                            break;
                        case"mapSpecular":
                            c.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy);
                            break;
                        case"mapSpecularRepeat":
                        case"mapSpecularOffset":
                        case"mapSpecularWrap":
                        case"mapSpecularAnisotropy":
                            break;
                        case"mapMetalness":
                            c.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy);
                            break;
                        case"mapMetalnessRepeat":
                        case"mapMetalnessOffset":
                        case"mapMetalnessWrap":
                        case"mapMetalnessAnisotropy":
                            break;
                        case"mapRoughness":
                            c.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy);
                            break;
                        case"mapRoughnessRepeat":
                        case"mapRoughnessOffset":
                        case"mapRoughnessWrap":
                        case"mapRoughnessAnisotropy":
                            break;
                        case"mapAlpha":
                            c.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy);
                            break;
                        case"mapAlphaRepeat":
                        case"mapAlphaOffset":
                        case"mapAlphaWrap":
                        case"mapAlphaAnisotropy":
                            break;
                        case"flipSided":
                            c.side = 1;
                            break;
                        case"doubleSided":
                            c.side = 2;
                            break;
                        case"transparency":
                            console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), c.opacity = u;
                            break;
                        case"depthTest":
                        case"depthWrite":
                        case"colorWrite":
                        case"opacity":
                        case"reflectivity":
                        case"transparent":
                        case"visible":
                        case"wireframe":
                            c[h] = u;
                            break;
                        case"vertexColors":
                            !0 === u && (c.vertexColors = 2), "face" === u && (c.vertexColors = 1);
                            break;
                        default:
                            console.error("THREE.Loader.createMaterial: Unsupported", h, u)
                    }
                }
                return "MeshBasicMaterial" === c.type && delete c.emissive, "MeshPhongMaterial" !== c.type && delete c.specular, 1 > c.opacity && (c.transparent = !0), n.setTextures(l), n.parse(c)
            }
        }()
    });
    var to, eo = {
        getContext: function () {
            return void 0 === to && (to = new (window.AudioContext || window.webkitAudioContext)), to
        }, setContext: function (t) {
            to = t
        }
    };
    Object.assign(gr.prototype, {
        load: function (t, e, i, n) {
            var r = new En(this.manager);
            r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, function (t) {
                t = t.slice(0), eo.getContext().decodeAudioData(t, function (t) {
                    e(t)
                })
            }, i, n)
        }, setPath: function (t) {
            return this.path = t, this
        }
    }), Object.assign(vr.prototype, {
        update: function () {
            var t, e, i, r, a, o, s, l, c = new n, h = new n;
            return function (n) {
                if (t !== this || e !== n.focus || i !== n.fov || r !== n.aspect * this.aspect || a !== n.near || o !== n.far || s !== n.zoom || l !== this.eyeSep) {
                    t = this, e = n.focus, i = n.fov, r = n.aspect * this.aspect, a = n.near, o = n.far, s = n.zoom;
                    var u = n.projectionMatrix.clone();
                    l = this.eyeSep / 2;
                    var p = l * a / e, d = a * Math.tan(la.DEG2RAD * i * .5) / s;
                    h.elements[12] = -l, c.elements[12] = l;
                    var f = -d * r + p, m = d * r + p;
                    u.elements[0] = 2 * a / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraL.projectionMatrix.copy(u), f = -d * r - p, m = d * r - p, u.elements[0] = 2 * a / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraR.projectionMatrix.copy(u)
                }
                this.cameraL.matrixWorld.copy(n.matrixWorld).multiply(h), this.cameraR.matrixWorld.copy(n.matrixWorld).multiply(c)
            }
        }()
    }), yr.prototype = Object.create(S.prototype), yr.prototype.constructor = yr, Object.assign(xr.prototype, {
        start: function () {
            this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0
        }, stop: function () {
            this.getElapsedTime(), this.autoStart = this.running = !1
        }, getElapsedTime: function () {
            return this.getDelta(), this.elapsedTime
        }, getDelta: function () {
            var t = 0;
            if (this.autoStart && !this.running) return this.start(), 0;
            if (this.running) {
                var e = ("undefined" == typeof performance ? Date : performance).now();
                t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t
            }
            return t
        }
    }), _r.prototype = Object.assign(Object.create(S.prototype), {
        constructor: _r, getInput: function () {
            return this.gain
        }, removeFilter: function () {
            return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
        }, getFilter: function () {
            return this.filter
        }, setFilter: function (t) {
            return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
        }, getMasterVolume: function () {
            return this.gain.gain.value
        }, setMasterVolume: function (t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        }, updateMatrixWorld: function () {
            var t = new a, e = new r, i = new a, n = new a, o = new xr;
            return function (r) {
                S.prototype.updateMatrixWorld.call(this, r), r = this.context.listener;
                var a = this.up;
                if (this.timeDelta = o.getDelta(), this.matrixWorld.decompose(t, e, i), n.set(0, 0, -1).applyQuaternion(e), r.positionX) {
                    var s = this.context.currentTime + this.timeDelta;
                    r.positionX.linearRampToValueAtTime(t.x, s), r.positionY.linearRampToValueAtTime(t.y, s), r.positionZ.linearRampToValueAtTime(t.z, s), r.forwardX.linearRampToValueAtTime(n.x, s), r.forwardY.linearRampToValueAtTime(n.y, s), r.forwardZ.linearRampToValueAtTime(n.z, s), r.upX.linearRampToValueAtTime(a.x, s), r.upY.linearRampToValueAtTime(a.y, s), r.upZ.linearRampToValueAtTime(a.z, s)
                } else r.setPosition(t.x, t.y, t.z), r.setOrientation(n.x, n.y, n.z, a.x, a.y, a.z)
            }
        }()
    }), br.prototype = Object.assign(Object.create(S.prototype), {
        constructor: br, getOutput: function () {
            return this.gain
        }, setNodeSource: function (t) {
            return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this
        }, setMediaElementSource: function (t) {
            return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this
        }, setBuffer: function (t) {
            return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this
        }, play: function () {
            if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else {
                if (!1 !== this.hasPlaybackControl) {
                    var t = this.context.createBufferSource();
                    return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
                }
                console.warn("THREE.Audio: this Audio has no playback control.")
            }
        }, pause: function () {
            if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, stop: function () {
            if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, connect: function () {
            if (0 < this.filters.length) {
                this.source.connect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].connect(this.filters[t]);
                this.filters[this.filters.length - 1].connect(this.getOutput())
            } else this.source.connect(this.getOutput());
            return this
        }, disconnect: function () {
            if (0 < this.filters.length) {
                this.source.disconnect(this.filters[0]);
                for (var t = 1, e = this.filters.length; t < e; t++) this.filters[t - 1].disconnect(this.filters[t]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this
        }, getFilters: function () {
            return this.filters
        }, setFilters: function (t) {
            return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this
        }, setDetune: function (t) {
            if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
        }, getDetune: function () {
            return this.detune
        }, getFilter: function () {
            return this.getFilters()[0]
        }, setFilter: function (t) {
            return this.setFilters(t ? [t] : [])
        }, setPlaybackRate: function (t) {
            if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, getPlaybackRate: function () {
            return this.playbackRate
        }, onEnded: function () {
            this.isPlaying = !1
        }, getLoop: function () {
            return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
        }, setLoop: function (t) {
            if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this;
            console.warn("THREE.Audio: this Audio has no playback control.")
        }, getVolume: function () {
            return this.gain.gain.value
        }, setVolume: function (t) {
            return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this
        }
    }), wr.prototype = Object.assign(Object.create(br.prototype), {
        constructor: wr, getOutput: function () {
            return this.panner
        }, getRefDistance: function () {
            return this.panner.refDistance
        }, setRefDistance: function (t) {
            return this.panner.refDistance = t, this
        }, getRolloffFactor: function () {
            return this.panner.rolloffFactor
        }, setRolloffFactor: function (t) {
            return this.panner.rolloffFactor = t, this
        }, getDistanceModel: function () {
            return this.panner.distanceModel
        }, setDistanceModel: function (t) {
            return this.panner.distanceModel = t, this
        }, getMaxDistance: function () {
            return this.panner.maxDistance
        }, setMaxDistance: function (t) {
            return this.panner.maxDistance = t, this
        }, setDirectionalCone: function (t, e, i) {
            return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this
        }, updateMatrixWorld: function () {
            var t = new a, e = new r, i = new a, n = new a;
            return function (r) {
                if (S.prototype.updateMatrixWorld.call(this, r), !1 !== this.isPlaying) if (this.matrixWorld.decompose(t, e, i), n.set(0, 0, 1).applyQuaternion(e), r = this.panner, r.positionX) {
                    var a = this.context.currentTime + this.listener.timeDelta;
                    r.positionX.linearRampToValueAtTime(t.x, a), r.positionY.linearRampToValueAtTime(t.y, a), r.positionZ.linearRampToValueAtTime(t.z, a), r.orientationX.linearRampToValueAtTime(n.x, a), r.orientationY.linearRampToValueAtTime(n.y, a), r.orientationZ.linearRampToValueAtTime(n.z, a)
                } else r.setPosition(t.x, t.y, t.z), r.setOrientation(n.x, n.y, n.z)
            }
        }()
    }), Object.assign(Mr.prototype, {
        getFrequencyData: function () {
            return this.analyser.getByteFrequencyData(this.data), this.data
        }, getAverageFrequency: function () {
            for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++) t += e[i];
            return t / e.length
        }
    }), Object.assign(Tr.prototype, {
        accumulate: function (t, e) {
            var i = this.buffer, n = this.valueSize;
            t = t * n + n;
            var r = this.cumulativeWeight;
            if (0 === r) {
                for (r = 0; r !== n; ++r) i[t + r] = i[r];
                r = e
            } else r += e, this._mixBufferRegion(i, t, 0, e / r, n);
            this.cumulativeWeight = r
        }, apply: function (t) {
            var e = this.valueSize, i = this.buffer;
            t = t * e + e;
            var n = this.cumulativeWeight, r = this.binding;
            this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e;
            for (var a = e + e; n !== a; ++n) if (i[n] !== i[n + e]) {
                r.setValue(i, t);
                break
            }
        }, saveOriginalState: function () {
            var t = this.buffer, e = this.valueSize, i = 3 * e;
            this.binding.getValue(t, i);
            for (var n = e; n !== i; ++n) t[n] = t[i + n % e];
            this.cumulativeWeight = 0
        }, restoreOriginalState: function () {
            this.binding.setValue(this.buffer, 3 * this.valueSize)
        }, _select: function (t, e, i, n, r) {
            if (.5 <= n) for (n = 0; n !== r; ++n) t[e + n] = t[i + n]
        }, _slerp: function (t, e, i, n) {
            r.slerpFlat(t, e, t, e, t, i, n)
        }, _lerp: function (t, e, i, n, r) {
            for (var a = 1 - n, o = 0; o !== r; ++o) {
                var s = e + o;
                t[s] = t[s] * a + t[i + o] * n
            }
        }
    }), Object.assign(Sr.prototype, {
        getValue: function (t, e) {
            this.bind();
            var i = this._bindings[this._targetGroup.nCachedObjects_];
            void 0 !== i && i.getValue(t, e)
        }, setValue: function (t, e) {
            for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n) i[n].setValue(t, e)
        }, bind: function () {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].bind()
        }, unbind: function () {
            for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e) t[e].unbind()
        }
    }), Object.assign(Er, {
        Composite: Sr, create: function (t, e, i) {
            return t && t.isAnimationObjectGroup ? new Er.Composite(t, e, i) : new Er(t, e, i)
        }, sanitizeNodeName: function () {
            var t = /[\[\]\.:\/]/g;
            return function (t) {
                return t.replace(/\s/g, "_").replace(/[\[\]\.:\/]/g, "")
            }
        }(), parseTrackName: function () {
            var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]",
                e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]");
            t = /(WCOD+)?/.source.replace("WCOD", t);
            var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"),
                r = new RegExp("^" + e + t + i + n + "$"), a = ["material", "materials", "bones"];
            return function (t) {
                var e = r.exec(t);
                if (!e) throw Error("PropertyBinding: Cannot parse trackName: " + t);
                e = {nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6]};
                var i = e.nodeName && e.nodeName.lastIndexOf(".");
                if (void 0 !== i && -1 !== i) {
                    var n = e.nodeName.substring(i + 1);
                    -1 !== a.indexOf(n) && (e.nodeName = e.nodeName.substring(0, i), e.objectName = n)
                }
                if (null === e.propertyName || 0 === e.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + t);
                return e
            }
        }(), findNode: function (t, e) {
            if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t;
            if (t.skeleton) {
                var i = t.skeleton.getBoneByName(e);
                if (void 0 !== i) return i
            }
            if (t.children) {
                var n = function (t) {
                    for (var i = 0; i < t.length; i++) {
                        var r = t[i];
                        if (r.name === e || r.uuid === e || (r = n(r.children))) return r
                    }
                    return null
                };
                if (t = n(t.children)) return t
            }
            return null
        }
    }), Object.assign(Er.prototype, {
        _getValue_unavailable: function () {
        },
        _setValue_unavailable: function () {
        },
        BindingType: {Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3},
        Versioning: {None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2},
        GetterByBindingType: [function (t, e) {
            t[e] = this.node[this.propertyName]
        }, function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) t[e++] = i[n]
        }, function (t, e) {
            t[e] = this.resolvedProperty[this.propertyIndex]
        }, function (t, e) {
            this.resolvedProperty.toArray(t, e)
        }],
        SetterByBindingTypeAndVersioning: [[function (t, e) {
            this.targetObject[this.propertyName] = t[e]
        }, function (t, e) {
            this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0
        }, function (t, e) {
            this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++]
        }, function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
            this.targetObject.needsUpdate = !0
        }, function (t, e) {
            for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n) i[n] = t[e++];
            this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e]
        }, function (t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0
        }, function (t, e) {
            this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0
        }], [function (t, e) {
            this.resolvedProperty.fromArray(t, e)
        }, function (t, e) {
            this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0
        }, function (t, e) {
            this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0
        }]],
        getValue: function (t, e) {
            this.bind(), this.getValue(t, e)
        },
        setValue: function (t, e) {
            this.bind(), this.setValue(t, e)
        },
        bind: function () {
            var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, r = e.propertyIndex;
            if (t || (this.node = t = Er.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) {
                if (i) {
                    var a = e.objectIndex;
                    switch (i) {
                        case"materials":
                            if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                            if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                            t = t.material.materials;
                            break;
                        case"bones":
                            if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                            for (t = t.skeleton.bones, i = 0; i < t.length; i++) if (t[i].name === a) {
                                a = i;
                                break
                            }
                            break;
                        default:
                            if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                            t = t[i]
                    }
                    if (void 0 !== a) {
                        if (void 0 === t[a]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t);
                        t = t[a]
                    }
                }
                if (void 0 === (a = t[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.", t); else {
                    if (e = this.Versioning.None, this.targetObject = t, void 0 !== t.needsUpdate ? e = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) {
                        if ("morphTargetInfluences" === n) {
                            if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                            if (t.geometry.isBufferGeometry) {
                                if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                                for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++) if (t.geometry.morphAttributes.position[i].name === r) {
                                    r = i;
                                    break
                                }
                            } else {
                                if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this);
                                for (i = 0; i < this.node.geometry.morphTargets.length; i++) if (t.geometry.morphTargets[i].name === r) {
                                    r = i;
                                    break
                                }
                            }
                        }
                        i = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
                    } else void 0 !== a.fromArray && void 0 !== a.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (i = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = n;
                    this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e]
                }
            } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.")
        },
        unbind: function () {
            this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
        }
    }), Object.assign(Er.prototype, {
        _getValue_unbound: Er.prototype.getValue,
        _setValue_unbound: Er.prototype.setValue
    }), Object.assign(Ar.prototype, {
        isAnimationObjectGroup: !0, add: function () {
            for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, a = this._parsedPaths, o = this._bindings, s = o.length, l = void 0, c = 0, h = arguments.length; c !== h; ++c) {
                var u = arguments[c], p = u.uuid, d = n[p];
                if (void 0 === d) {
                    d = e++, n[p] = d, t.push(u), p = 0;
                    for (var f = s; p !== f; ++p) o[p].push(new Er(u, r[p], a[p]))
                } else if (d < i) {
                    l = t[d];
                    var m = --i;
                    for (f = t[m], n[f.uuid] = d, t[d] = f, n[p] = m, t[m] = u, p = 0, f = s; p !== f; ++p) {
                        var g = o[p], v = g[d];
                        g[d] = g[m], void 0 === v && (v = new Er(u, r[p], a[p])), g[m] = v
                    }
                } else t[d] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
            }
            this.nCachedObjects_ = i
        }, remove: function () {
            for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, a = 0, o = arguments.length; a !== o; ++a) {
                var s = arguments[a], l = s.uuid, c = i[l];
                if (void 0 !== c && c >= e) {
                    var h = e++, u = t[h];
                    for (i[u.uuid] = c, t[c] = u, i[l] = h, t[h] = s, s = 0, l = r; s !== l; ++s) {
                        u = n[s];
                        var p = u[c];
                        u[c] = u[h], u[h] = p
                    }
                }
            }
            this.nCachedObjects_ = e
        }, uncache: function () {
            for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, a = r.length, o = 0, s = arguments.length; o !== s; ++o) {
                var l = arguments[o].uuid, c = n[l];
                if (void 0 !== c) if (delete n[l], c < i) {
                    l = --i;
                    var h = t[l], u = --e, p = t[u];
                    for (n[h.uuid] = c, t[c] = h, n[p.uuid] = l, t[l] = p, t.pop(), h = 0, p = a; h !== p; ++h) {
                        var d = r[h], f = d[u];
                        d[c] = d[l], d[l] = f, d.pop()
                    }
                } else for (u = --e, p = t[u], n[p.uuid] = c, t[c] = p, t.pop(), h = 0, p = a; h !== p; ++h) d = r[h], d[c] = d[u], d.pop()
            }
            this.nCachedObjects_ = i
        }, subscribe_: function (t, e) {
            var i = this._bindingsIndicesByPath, n = i[t], r = this._bindings;
            if (void 0 !== n) return r[n];
            var a = this._paths, o = this._parsedPaths, s = this._objects, l = this.nCachedObjects_,
                c = Array(s.length);
            for (n = r.length, i[t] = n, a.push(t), o.push(e), r.push(c), i = l, n = s.length; i !== n; ++i) c[i] = new Er(s[i], t, e);
            return c
        }, unsubscribe_: function (t) {
            var e = this._bindingsIndicesByPath, i = e[t];
            if (void 0 !== i) {
                var n = this._paths, r = this._parsedPaths, a = this._bindings, o = a.length - 1, s = a[o];
                e[t[o]] = i, a[i] = s, a.pop(), r[i] = r[o], r.pop(), n[i] = n[o], n.pop()
            }
        }
    }), Object.assign(Pr.prototype, {
        play: function () {
            return this._mixer._activateAction(this), this
        }, stop: function () {
            return this._mixer._deactivateAction(this), this.reset()
        }, reset: function () {
            return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
        }, isRunning: function () {
            return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this)
        }, isScheduled: function () {
            return this._mixer._isActiveAction(this)
        }, startAt: function (t) {
            return this._startTime = t, this
        }, setLoop: function (t, e) {
            return this.loop = t, this.repetitions = e, this
        }, setEffectiveWeight: function (t) {
            return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading()
        }, getEffectiveWeight: function () {
            return this._effectiveWeight
        }, fadeIn: function (t) {
            return this._scheduleFading(t, 0, 1)
        }, fadeOut: function (t) {
            return this._scheduleFading(t, 1, 0)
        }, crossFadeFrom: function (t, e, i) {
            if (t.fadeOut(e), this.fadeIn(e), i) {
                i = this._clip.duration;
                var n = t._clip.duration, r = i / n;
                t.warp(1, n / i, e), this.warp(r, 1, e)
            }
            return this
        }, crossFadeTo: function (t, e, i) {
            return t.crossFadeFrom(this, e, i)
        }, stopFading: function () {
            var t = this._weightInterpolant;
            return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        }, setEffectiveTimeScale: function (t) {
            return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping()
        }, getEffectiveTimeScale: function () {
            return this._effectiveTimeScale
        }, setDuration: function (t) {
            return this.timeScale = this._clip.duration / t, this.stopWarping()
        }, syncWith: function (t) {
            return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping()
        }, halt: function (t) {
            return this.warp(this._effectiveTimeScale, 0, t)
        }, warp: function (t, e, i) {
            var n = this._mixer, r = n.time, a = this._timeScaleInterpolant, o = this.timeScale;
            return null === a && (this._timeScaleInterpolant = a = n._lendControlInterpolant()), n = a.parameterPositions, a = a.sampleValues, n[0] = r, n[1] = r + i, a[0] = t / o, a[1] = e / o, this
        }, stopWarping: function () {
            var t = this._timeScaleInterpolant;
            return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this
        }, getMixer: function () {
            return this._mixer
        }, getClip: function () {
            return this._clip
        }, getRoot: function () {
            return this._localRoot || this._mixer._root
        }, _update: function (t, e, i, n) {
            if (this.enabled) {
                var r = this._startTime;
                if (null !== r) {
                    if (0 > (e = (t - r) * i) || 0 === i) return;
                    this._startTime = null, e *= i
                }
                if (e *= this._updateTimeScale(t), i = this._updateTime(e), 0 < (t = this._updateWeight(t))) {
                    e = this._interpolants, r = this._propertyBindings;
                    for (var a = 0, o = e.length; a !== o; ++a) e[a].evaluate(i), r[a].accumulate(n, t)
                }
            } else this._updateWeight(t)
        }, _updateWeight: function (t) {
            var e = 0;
            if (this.enabled) {
                e = this.weight;
                var i = this._weightInterpolant;
                if (null !== i) {
                    var n = i.evaluate(t)[0];
                    e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1))
                }
            }
            return this._effectiveWeight = e
        }, _updateTimeScale: function (t) {
            var e = 0;
            if (!this.paused) {
                e = this.timeScale;
                var i = this._timeScaleInterpolant;
                if (null !== i) {
                    e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e)
                }
            }
            return this._effectiveTimeScale = e
        }, _updateTime: function (t) {
            var e = this.time + t, i = this._clip.duration, n = this.loop, r = this._loopCount, a = 2202 === n;
            if (0 === t) return -1 === r ? e : a && 1 == (1 & r) ? i - e : e;
            if (2200 === n) t:{
                if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i) e = i; else {
                    if (!(0 > e)) break t;
                    e = 0
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: 0 > t ? -1 : 1
                })
            } else {
                if (-1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this.repetitions, a)) : this._setEndings(0 === this.repetitions, !0, a)), e >= i || 0 > e) {
                    n = Math.floor(e / i), e -= i * n, r += Math.abs(n);
                    var o = this.repetitions - r;
                    0 >= o ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, e = 0 < t ? i : 0, this._mixer.dispatchEvent({
                        type: "finished",
                        action: this,
                        direction: 0 < t ? 1 : -1
                    })) : (1 === o ? (t = 0 > t, this._setEndings(t, !t, a)) : this._setEndings(!1, !1, a), this._loopCount = r, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: n
                    }))
                }
                if (a && 1 == (1 & r)) return this.time = e, i - e
            }
            return this.time = e
        }, _setEndings: function (t, e, i) {
            var n = this._interpolantSettings;
            i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402)
        }, _scheduleFading: function (t, e, i) {
            var n = this._mixer, r = n.time, a = this._weightInterpolant;
            return null === a && (this._weightInterpolant = a = n._lendControlInterpolant()), n = a.parameterPositions, a = a.sampleValues, n[0] = r, a[0] = e, n[1] = r + t, a[1] = i, this
        }
    }), Lr.prototype = Object.assign(Object.create(e.prototype), {
        constructor: Lr, _bindAction: function (t, e) {
            var i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, a = t._propertyBindings;
            t = t._interpolants;
            var o = i.uuid, s = this._bindingsByRootAndName, l = s[o];
            for (void 0 === l && (l = {}, s[o] = l), s = 0; s !== r; ++s) {
                var c = n[s], h = c.name, u = l[h];
                if (void 0 === u) {
                    if (void 0 !== (u = a[s])) {
                        null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, o, h));
                        continue
                    }
                    u = new Tr(Er.create(i, h, e && e._propertyBindings[s].binding.parsedPath), c.ValueTypeName, c.getValueSize()), ++u.referenceCount, this._addInactiveBinding(u, o, h)
                }
                a[s] = u, t[s].resultBuffer = u.buffer
            }
        }, _activateAction: function (t) {
            if (!this._isActiveAction(t)) {
                if (null === t._cacheIndex) {
                    var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i];
                    this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e)
                }
                for (e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState())
                }
                this._lendAction(t)
            }
        }, _deactivateAction: function (t) {
            if (this._isActiveAction(t)) {
                for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) {
                    var r = e[i];
                    0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r))
                }
                this._takeBackAction(t)
            }
        }, _initMemoryManager: function () {
            this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
            var t = this;
            this.stats = {
                actions: {
                    get total() {
                        return t._actions.length
                    }, get inUse() {
                        return t._nActiveActions
                    }
                }, bindings: {
                    get total() {
                        return t._bindings.length
                    }, get inUse() {
                        return t._nActiveBindings
                    }
                }, controlInterpolants: {
                    get total() {
                        return t._controlInterpolants.length
                    }, get inUse() {
                        return t._nActiveControlInterpolants
                    }
                }
            }
        }, _isActiveAction: function (t) {
            return null !== (t = t._cacheIndex) && t < this._nActiveActions
        }, _addInactiveAction: function (t, e, i) {
            var n = this._actions, r = this._actionsByClip, a = r[e];
            void 0 === a ? (a = {
                knownActions: [t],
                actionByRoot: {}
            }, t._byClipCacheIndex = 0, r[e] = a) : (e = a.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), a.actionByRoot[i] = t
        }, _removeInactiveAction: function (t) {
            var e = this._actions, i = e[e.length - 1], n = t._cacheIndex;
            i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid, i = this._actionsByClip, n = i[e];
            var r = n.knownActions, a = r[r.length - 1], o = t._byClipCacheIndex;
            a._byClipCacheIndex = o, r[o] = a, r.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], 0 === r.length && delete i[e], this._removeInactiveBindingsForAction(t)
        }, _removeInactiveBindingsForAction: function (t) {
            t = t._propertyBindings;
            for (var e = 0, i = t.length; e !== i; ++e) {
                var n = t[e];
                0 == --n.referenceCount && this._removeInactiveBinding(n)
            }
        }, _lendAction: function (t) {
            var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        }, _takeBackAction: function (t) {
            var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        }, _addInactiveBinding: function (t, e, i) {
            var n = this._bindingsByRootAndName, r = n[e], a = this._bindings;
            void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = a.length, a.push(t)
        }, _removeInactiveBinding: function (t) {
            var e = this._bindings, i = t.binding, n = i.rootNode.uuid;
            i = i.path;
            var r = this._bindingsByRootAndName, a = r[n], o = e[e.length - 1];
            t = t._cacheIndex, o._cacheIndex = t, e[t] = o, e.pop(), delete a[i];
            t:{
                for (var s in a) break t;
                delete r[n]
            }
        }, _lendBinding: function (t) {
            var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        }, _takeBackBinding: function (t) {
            var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n];
            t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r
        }, _lendControlInterpolant: function () {
            var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e];
            return void 0 === i && (i = new pn(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer), i.__cacheIndex = e, t[e] = i), i
        }, _takeBackControlInterpolant: function (t) {
            var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n];
            t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r
        }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e) {
            var i = e || this._root, n = i.uuid;
            i = "string" == typeof t ? wn.findByName(i, t) : t, t = null !== i ? i.uuid : t;
            var r = this._actionsByClip[t], a = null;
            if (void 0 !== r) {
                if (void 0 !== (a = r.actionByRoot[n])) return a;
                a = r.knownActions[0], null === i && (i = a._clip)
            }
            return null === i ? null : (e = new Pr(this, i, e), this._bindAction(e, a), this._addInactiveAction(e, t, n), e)
        }, existingAction: function (t, e) {
            var i = e || this._root;
            return e = i.uuid, i = "string" == typeof t ? wn.findByName(i, t) : t, t = this._actionsByClip[i ? i.uuid : t], void 0 !== t ? t.actionByRoot[e] || null : null
        }, stopAllAction: function () {
            for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r) t[r].reset();
            for (r = 0; r !== n; ++r) i[r].useCount = 0;
            return this
        }, update: function (t) {
            t *= this.timeScale;
            for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), a = this._accuIndex ^= 1, o = 0; o !== i; ++o) e[o]._update(n, t, r, a);
            for (t = this._bindings, e = this._nActiveBindings, o = 0; o !== e; ++o) t[o].apply(a);
            return this
        }, getRoot: function () {
            return this._root
        }, uncacheClip: function (t) {
            var e = this._actions;
            t = t.uuid;
            var i = this._actionsByClip, n = i[t];
            if (void 0 !== n) {
                n = n.knownActions;
                for (var r = 0, a = n.length; r !== a; ++r) {
                    var o = n[r];
                    this._deactivateAction(o);
                    var s = o._cacheIndex, l = e[e.length - 1];
                    o._cacheIndex = null, o._byClipCacheIndex = null, l._cacheIndex = s, e[s] = l, e.pop(), this._removeInactiveBindingsForAction(o)
                }
                delete i[t]
            }
        }, uncacheRoot: function (t) {
            t = t.uuid;
            var e = this._actionsByClip;
            for (n in e) {
                var i = e[n].actionByRoot[t];
                void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i))
            }
            var n = this._bindingsByRootAndName[t];
            if (void 0 !== n) for (var r in n) t = n[r], t.restoreOriginalState(), this._removeInactiveBinding(t)
        }, uncacheAction: function (t, e) {
            null !== (t = this.existingAction(t, e)) && (this._deactivateAction(t), this._removeInactiveAction(t))
        }
    }), Cr.prototype.clone = function () {
        return new Cr(void 0 === this.value.clone ? this.value : this.value.clone())
    }, Rr.prototype = Object.assign(Object.create(F.prototype), {
        constructor: Rr,
        isInstancedBufferGeometry: !0,
        copy: function (t) {
            return F.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this
        },
        clone: function () {
            return (new this.constructor).copy(this)
        }
    }), Or.prototype = Object.assign(Object.create(Re.prototype), {
        constructor: Or,
        isInstancedInterleavedBuffer: !0,
        copy: function (t) {
            return Re.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }
    }), Dr.prototype = Object.assign(Object.create(A.prototype), {
        constructor: Dr, isInstancedBufferAttribute: !0, copy: function (t) {
            return A.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this
        }
    }), Object.assign(Ir.prototype, {
        linePrecision: 1, set: function (t, e) {
            this.ray.set(t, e)
        }, setFromCamera: function (t, e) {
            e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.")
        }, intersectObject: function (t, e, i) {
            return i = i || [], zr(t, this, i, e), i.sort(Nr), i
        }, intersectObjects: function (t, e, i) {
            if (i = i || [], !1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i;
            for (var n = 0, r = t.length; n < r; n++) zr(t[n], this, i, e);
            return i.sort(Nr), i
        }
    }), Object.assign(kr.prototype, {
        set: function (t, e, i) {
            return this.radius = t, this.phi = e, this.theta = i, this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this
        }, makeSafe: function () {
            return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
        }, setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        }, setFromCartesianCoords: function (t, e, i) {
            return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(la.clamp(e / this.radius, -1, 1))), this
        }
    }), Object.assign(Br.prototype, {
        set: function (t, e, i) {
            return this.radius = t, this.theta = e, this.y = i, this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this
        }, setFromVector3: function (t) {
            return this.setFromCartesianCoords(t.x, t.y, t.z)
        }, setFromCartesianCoords: function (t, e, i) {
            return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this
        }
    }), Object.assign(Fr.prototype, {
        set: function (t, e) {
            return this.min.copy(t), this.max.copy(e), this
        }, setFromPoints: function (t) {
            this.makeEmpty();
            for (var e = 0, i = t.length; e < i; e++) this.expandByPoint(t[e]);
            return this
        }, setFromCenterAndSize: function () {
            var t = new i;
            return function (e, i) {
                return i = t.copy(i).multiplyScalar(.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this
            }
        }(), clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.min.copy(t.min), this.max.copy(t.max), this
        }, makeEmpty: function () {
            return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -(1 / 0), this
        }, isEmpty: function () {
            return this.max.x < this.min.x || this.max.y < this.min.y
        }, getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new i), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5)
        }, getSize: function (t) {
            return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new i), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min)
        }, expandByPoint: function (t) {
            return this.min.min(t), this.max.max(t), this
        }, expandByVector: function (t) {
            return this.min.sub(t), this.max.add(t), this
        }, expandByScalar: function (t) {
            return this.min.addScalar(-t), this.max.addScalar(t), this
        }, containsPoint: function (t) {
            return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y)
        }, containsBox: function (t) {
            return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y
        }, getParameter: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new i), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y))
        }, intersectsBox: function (t) {
            return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y)
        }, clampPoint: function (t, e) {
            return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new i), e.copy(t).clamp(this.min, this.max)
        }, distanceToPoint: function () {
            var t = new i;
            return function (e) {
                return t.copy(e).clamp(this.min, this.max).sub(e).length()
            }
        }(), intersect: function (t) {
            return this.min.max(t.min), this.max.min(t.max), this
        }, union: function (t) {
            return this.min.min(t.min), this.max.max(t.max), this
        }, translate: function (t) {
            return this.min.add(t), this.max.add(t), this
        }, equals: function (t) {
            return t.min.equals(this.min) && t.max.equals(this.max)
        }
    }), Object.assign(Hr.prototype, {
        set: function (t, e) {
            return this.start.copy(t), this.end.copy(e), this
        }, clone: function () {
            return (new this.constructor).copy(this)
        }, copy: function (t) {
            return this.start.copy(t.start), this.end.copy(t.end), this
        }, getCenter: function (t) {
            return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new a), t.addVectors(this.start, this.end).multiplyScalar(.5)
        }, delta: function (t) {
            return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new a), t.subVectors(this.end, this.start)
        }, distanceSq: function () {
            return this.start.distanceToSquared(this.end)
        }, distance: function () {
            return this.start.distanceTo(this.end)
        }, at: function (t, e) {
            return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new a), this.delta(e).multiplyScalar(t).add(this.start)
        }, closestPointToPointParameter: function () {
            var t = new a, e = new a;
            return function (i, n) {
                return t.subVectors(i, this.start), e.subVectors(this.end, this.start), i = e.dot(e), i = e.dot(t) / i, n && (i = la.clamp(i, 0, 1)), i
            }
        }(), closestPointToPoint: function (t, e, i) {
            return t = this.closestPointToPointParameter(t, e), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new a), this.delta(i).multiplyScalar(t).add(this.start)
        }, applyMatrix4: function (t) {
            return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this
        }, equals: function (t) {
            return t.start.equals(this.start) && t.end.equals(this.end)
        }
    }), Ur.prototype = Object.create(S.prototype), Ur.prototype.constructor = Ur, Ur.prototype.isImmediateRenderObject = !0, Gr.prototype = Object.create(Ue.prototype), Gr.prototype.constructor = Gr, Gr.prototype.update = function () {
        var t = new a, e = new a, i = new o;
        return function () {
            var n = ["a", "b", "c"];
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var r = this.object.matrixWorld, a = this.geometry.attributes.position, o = this.object.geometry;
            if (o && o.isGeometry) for (var s = o.vertices, l = o.faces, c = o = 0, h = l.length; c < h; c++) for (var u = l[c], p = 0, d = u.vertexNormals.length; p < d; p++) {
                var f = u.vertexNormals[p];
                t.copy(s[u[n[p]]]).applyMatrix4(r), e.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a.setXYZ(o, t.x, t.y, t.z), o += 1, a.setXYZ(o, e.x, e.y, e.z), o += 1
            } else if (o && o.isBufferGeometry) for (n = o.attributes.position, s = o.attributes.normal, p = o = 0, d = n.count; p < d; p++) t.set(n.getX(p), n.getY(p), n.getZ(p)).applyMatrix4(r), e.set(s.getX(p), s.getY(p), s.getZ(p)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), a.setXYZ(o, t.x, t.y, t.z), o += 1, a.setXYZ(o, e.x, e.y, e.z), o += 1;
            a.needsUpdate = !0
        }
    }(), jr.prototype = Object.create(S.prototype), jr.prototype.constructor = jr, jr.prototype.dispose = function () {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }, jr.prototype.update = function () {
        var t = new a;
        return function () {
            this.light.updateMatrixWorld();
            var e = this.light.distance ? this.light.distance : 1e3, i = e * Math.tan(this.light.angle);
            this.cone.scale.set(i, i, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
        }
    }(), Wr.prototype = Object.create(Ue.prototype), Wr.prototype.constructor = Wr, Wr.prototype.updateMatrixWorld = function () {
        var t = new a, e = new n, i = new n;
        return function (n) {
            var r = this.bones, a = this.geometry, o = a.getAttribute("position");
            i.getInverse(this.root.matrixWorld);
            for (var s = 0, l = 0; s < r.length; s++) {
                var c = r[s];
                c.parent && c.parent.isBone && (e.multiplyMatrices(i, c.matrixWorld), t.setFromMatrixPosition(e), o.setXYZ(l, t.x, t.y, t.z), e.multiplyMatrices(i, c.parent.matrixWorld), t.setFromMatrixPosition(e), o.setXYZ(l + 1, t.x, t.y, t.z), l += 2)
            }
            a.getAttribute("position").needsUpdate = !0, S.prototype.updateMatrixWorld.call(this, n)
        }
    }(), qr.prototype = Object.create(J.prototype), qr.prototype.constructor = qr, qr.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose()
    }, qr.prototype.update = function () {
        void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }, Xr.prototype = Object.create(He.prototype), Xr.prototype.constructor = Xr, Xr.prototype.update = function () {
        if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else {
            this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity);
            var t = this.material.color, e = Math.max(t.r, t.g, t.b);
            1 < e && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color)
        }
    }, Xr.prototype.dispose = function () {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Yr.prototype = Object.create(S.prototype), Yr.prototype.constructor = Yr, Yr.prototype.dispose = function () {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }, Yr.prototype.update = function () {
        var t = new a, e = new x, i = new x;
        return function () {
            var n = this.children[0];
            if (void 0 !== this.color) this.material.color.set(this.color); else {
                var r = n.geometry.getAttribute("color");
                e.copy(this.light.color), i.copy(this.light.groundColor);
                for (var a = 0, o = r.count; a < o; a++) {
                    var s = a < o / 2 ? e : i;
                    r.setXYZ(a, s.r, s.g, s.b)
                }
                r.needsUpdate = !0
            }
            n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate())
        }
    }(), Jr.prototype = Object.create(Ue.prototype), Jr.prototype.constructor = Jr, Zr.prototype = Object.create(Ue.prototype), Zr.prototype.constructor = Zr, $r.prototype = Object.create(Ue.prototype), $r.prototype.constructor = $r, $r.prototype.update = function () {
        var t = new a, e = new a, i = new o;
        return function () {
            this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld);
            var n = this.object.matrixWorld, r = this.geometry.attributes.position, a = this.object.geometry,
                o = a.vertices;
            a = a.faces;
            for (var s = 0, l = 0, c = a.length; l < c; l++) {
                var h = a[l], u = h.normal;
                t.copy(o[h.a]).add(o[h.b]).add(o[h.c]).divideScalar(3).applyMatrix4(n), e.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(s, t.x, t.y, t.z), s += 1, r.setXYZ(s, e.x, e.y, e.z), s += 1
            }
            r.needsUpdate = !0
        }
    }(), Qr.prototype = Object.create(S.prototype), Qr.prototype.constructor = Qr, Qr.prototype.dispose = function () {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }, Qr.prototype.update = function () {
        var t = new a, e = new a, i = new a;
        return function () {
            t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = i.length()
        }
    }(), Kr.prototype = Object.create(Ue.prototype), Kr.prototype.constructor = Kr, Kr.prototype.update = function () {
        function t(t, a, o, s) {
            if (n.set(a, o, s).unproject(r), void 0 !== (t = i[t])) for (a = e.getAttribute("position"), o = 0, s = t.length; o < s; o++) a.setXYZ(t[o], n.x, n.y, n.z)
        }

        var e, i, n = new a, r = new be;
        return function () {
            e = this.geometry, i = this.pointMap, r.projectionMatrix.copy(this.camera.projectionMatrix), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0
        }
    }(), ta.prototype = Object.create(Ue.prototype), ta.prototype.constructor = ta, ta.prototype.update = function () {
        var t = new d;
        return function (e) {
            if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) {
                e = t.min;
                var i = t.max, n = this.geometry.attributes.position, r = n.array;
                r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = e.x, r[4] = i.y, r[5] = i.z, r[6] = e.x, r[7] = e.y, r[8] = i.z, r[9] = i.x, r[10] = e.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = e.z, r[15] = e.x, r[16] = i.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = i.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere()
            }
        }
    }(), ta.prototype.setFromObject = function (t) {
        return this.object = t, this.update(), this
    }, ta.prototype.copy = function (t) {
        return Ue.prototype.copy.call(this, t), this.object = t.object, this
    }, ta.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, ea.prototype = Object.create(Ue.prototype), ea.prototype.constructor = ea, ea.prototype.updateMatrixWorld = function (t) {
        var e = this.box;
        e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), S.prototype.updateMatrixWorld.call(this, t))
    }, ia.prototype = Object.create(He.prototype), ia.prototype.constructor = ia, ia.prototype.updateMatrixWorld = function (t) {
        var e = -this.plane.constant;
        1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), S.prototype.updateMatrixWorld.call(this, t)
    };
    var io, no;
    na.prototype = Object.create(S.prototype), na.prototype.constructor = na, na.prototype.setDirection = function () {
        var t = new a, e;
        return function (i) {
            .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (t.set(i.z, 0, -i.x).normalize(), e = Math.acos(i.y), this.quaternion.setFromAxisAngle(t, e))
        }
    }(), na.prototype.setLength = function (t, e, i) {
        void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix()
    }, na.prototype.setColor = function (t) {
        this.line.material.color.copy(t), this.cone.material.color.copy(t)
    }, na.prototype.copy = function (t) {
        return S.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this
    }, na.prototype.clone = function () {
        return (new this.constructor).copy(this)
    }, ra.prototype = Object.create(Ue.prototype), ra.prototype.constructor = ra, Dn.create = function (t, e) {
        return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Dn.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t
    }, Object.assign(Yn.prototype, {
        createPointsGeometry: function (t) {
            return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getPoints(t), this.createGeometry(t)
        }, createSpacedPointsGeometry: function (t) {
            return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getSpacedPoints(t), this.createGeometry(t)
        }, createGeometry: function (t) {
            console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.");
            for (var e = new E, i = 0, n = t.length; i < n; i++) {
                var r = t[i];
                e.vertices.push(new a(r.x, r.y, r.z || 0))
            }
            return e
        }
    }), Object.assign(Jn.prototype, {
        fromPoints: function (t) {
            console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t)
        }
    }), aa.prototype = Object.create(kn.prototype), oa.prototype = Object.create(kn.prototype), sa.prototype = Object.create(kn.prototype), Object.assign(sa.prototype, {
        initFromArray: function () {
            console.error("THREE.Spline: .initFromArray() has been removed.")
        }, getControlPointsArray: function () {
            console.error("THREE.Spline: .getControlPointsArray() has been removed.")
        }, reparametrizeByArcLength: function () {
            console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.")
        }
    }), Jr.prototype.setColors = function () {
        console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.")
    }, Wr.prototype.update = function () {
        console.error("THREE.SkeletonHelper: update() no longer needs to be called.")
    }, Object.assign(mr.prototype, {
        extractUrlBase: function (t) {
            return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), Ja.extractUrlBase(t)
        }
    }), Object.assign(hr.prototype, {
        setTexturePath: function (t) {
            return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t)
        }
    }), Object.assign(Fr.prototype, {
        center: function (t) {
            return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, empty: function () {
            return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, isIntersectionBox: function (t) {
            return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, size: function (t) {
            return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Object.assign(d.prototype, {
        center: function (t) {
            return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t)
        }, empty: function () {
            return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty()
        }, isIntersectionBox: function (t) {
            return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, isIntersectionSphere: function (t) {
            return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }, size: function (t) {
            return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t)
        }
    }), Hr.prototype.center = function (t) {
        return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t)
    }, Object.assign(la, {
        random16: function () {
            return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random()
        }, nearestPowerOfTwo: function (t) {
            return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), la.floorPowerOfTwo(t)
        }, nextPowerOfTwo: function (t) {
            return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), la.ceilPowerOfTwo(t)
        }
    }), Object.assign(o.prototype, {
        flattenToArrayOffset: function (t, e) {
            return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, multiplyVector3: function (t) {
            return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this)
        }, multiplyVector3Array: function () {
            console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.")
        }, applyToBuffer: function (t) {
            return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        }, applyToVector3Array: function () {
            console.error("THREE.Matrix3: .applyToVector3Array() has been removed.")
        }
    }), Object.assign(n.prototype, {
        extractPosition: function (t) {
            return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t)
        }, flattenToArrayOffset: function (t, e) {
            return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e)
        }, getPosition: function () {
            var t;
            return function () {
                return void 0 === t && (t = new a), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3)
            }
        }(), setRotationFromQuaternion: function (t) {
            return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t)
        }, multiplyToArray: function () {
            console.warn("THREE.Matrix4: .multiplyToArray() has been removed.")
        }, multiplyVector3: function (t) {
            return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, multiplyVector4: function (t) {
            return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, multiplyVector3Array: function () {
            console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.")
        }, rotateAxis: function (t) {
            console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this)
        }, crossVector: function (t) {
            return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this)
        }, translate: function () {
            console.error("THREE.Matrix4: .translate() has been removed.")
        }, rotateX: function () {
            console.error("THREE.Matrix4: .rotateX() has been removed.")
        }, rotateY: function () {
            console.error("THREE.Matrix4: .rotateY() has been removed.")
        }, rotateZ: function () {
            console.error("THREE.Matrix4: .rotateZ() has been removed.")
        }, rotateByAxis: function () {
            console.error("THREE.Matrix4: .rotateByAxis() has been removed.")
        }, applyToBuffer: function (t) {
            return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t)
        }, applyToVector3Array: function () {
            console.error("THREE.Matrix4: .applyToVector3Array() has been removed.")
        }, makeFrustum: function (t, e, i, n, r, a) {
            return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, a)
        }
    }), m.prototype.isIntersectionLine = function (t) {
        return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t)
    }, r.prototype.multiplyVector3 = function (t) {
        return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this)
    }, Object.assign(q.prototype, {
        isIntersectionBox: function (t) {
            return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t)
        }, isIntersectionPlane: function (t) {
            return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t)
        }, isIntersectionSphere: function (t) {
            return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t)
        }
    }), Object.assign(X.prototype, {
        area: function () {
            return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea()
        }, barycoordFromPoint: function (t, e) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e)
        }, midpoint: function (t) {
            return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t)
        }, normal: function (t) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t)
        }, plane: function (t) {
            return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t)
        }
    }), Object.assign(X, {
        barycoordFromPoint: function (t, e, i, n, r) {
            return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(t, e, i, n, r)
        }, normal: function (t, e, i, n) {
            return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(t, e, i, n)
        }
    }), Object.assign(Zn.prototype, {
        extractAllPoints: function (t) {
            return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t)
        }, extrude: function (t) {
            return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Oi(this, t)
        }, makeGeometry: function (t) {
            return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ji(this, t)
        }
    }), Object.assign(i.prototype, {
        fromAttribute: function (t, e, i) {
            return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        }, distanceToManhattan: function (t) {
            return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, lengthManhattan: function () {
            return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(a.prototype, {
        setEulerFromRotationMatrix: function () {
            console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.")
        }, setEulerFromQuaternion: function () {
            console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.")
        }, getPositionFromMatrix: function (t) {
            return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t)
        }, getScaleFromMatrix: function (t) {
            return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t)
        }, getColumnFromMatrix: function (t, e) {
            return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t)
        }, applyProjection: function (t) {
            return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t)
        }, fromAttribute: function (t, e, i) {
            return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        }, distanceToManhattan: function (t) {
            return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t)
        }, lengthManhattan: function () {
            return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(l.prototype, {
        fromAttribute: function (t, e, i) {
            return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i)
        }, lengthManhattan: function () {
            return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength()
        }
    }), Object.assign(E.prototype, {
        computeTangents: function () {
            console.error("THREE.Geometry: .computeTangents() has been removed.")
        }, computeLineDistances: function () {
            console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.")
        }
    }), Object.assign(S.prototype, {
        getChildByName: function (t) {
            return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t)
        }, renderDepth: function () {
            console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.")
        }, translate: function (t, e) {
            return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t)
        }, getWorldRotation: function () {
            console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.")
        }
    }), Object.defineProperties(S.prototype, {
        eulerOrder: {
            get: function () {
                return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order
            }, set: function (t) {
                console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t
            }
        }, useQuaternion: {
            get: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }, set: function () {
                console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.")
            }
        }
    }), Object.defineProperties(Ne.prototype, {
        objects: {
            get: function () {
                return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels
            }
        }
    }), Object.defineProperty(ke.prototype, "useVertexTexture", {
        get: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }, set: function () {
            console.warn("THREE.Skeleton: useVertexTexture has been removed.")
        }
    }), ze.prototype.initBones = function () {
        console.error("THREE.SkinnedMesh: initBones() has been removed.")
    }, Object.defineProperty(Dn.prototype, "__arcLengthDivisions", {
        get: function () {
            return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions
        }, set: function (t) {
            console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t
        }
    }), we.prototype.setLens = function (t, e) {
        console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t)
    }, Object.defineProperties($n.prototype, {
        onlyShadow: {
            set: function () {
                console.warn("THREE.Light: .onlyShadow has been removed.")
            }
        }, shadowCameraFov: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t
            }
        }, shadowCameraLeft: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t
            }
        }, shadowCameraRight: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t
            }
        }, shadowCameraTop: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t
            }
        }, shadowCameraBottom: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t
            }
        }, shadowCameraNear: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t
            }
        }, shadowCameraFar: {
            set: function (t) {
                console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t
            }
        }, shadowCameraVisible: {
            set: function () {
                console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.")
            }
        }, shadowBias: {
            set: function (t) {
                console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t
            }
        }, shadowDarkness: {
            set: function () {
                console.warn("THREE.Light: .shadowDarkness has been removed.")
            }
        }, shadowMapWidth: {
            set: function (t) {
                console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t
            }
        }, shadowMapHeight: {
            set: function (t) {
                console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t
            }
        }
    }), Object.defineProperties(A.prototype, {
        length: {
            get: function () {
                return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length
            }
        }, copyIndicesArray: function () {
            console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.")
        }
    }), Object.assign(F.prototype, {
        addIndex: function (t) {
            console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t)
        }, addDrawCall: function (t, e, i) {
            void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e)
        }, clearDrawCalls: function () {
            console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups()
        }, computeTangents: function () {
            console.warn("THREE.BufferGeometry: .computeTangents() has been removed.")
        }, computeOffsets: function () {
            console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.")
        }
    }), Object.defineProperties(F.prototype, {
        drawcalls: {
            get: function () {
                return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups
            }
        }, offsets: {
            get: function () {
                return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups
            }
        }
    }), Object.assign(Di.prototype, {
        getArrays: function () {
            console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.")
        }, addShapeList: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.")
        }, addShape: function () {
            console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.")
        }
    }), Object.defineProperties(Cr.prototype, {
        dynamic: {
            set: function () {
                console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.")
            }
        }, onUpdate: {
            value: function () {
                return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this
            }
        }
    }), Object.defineProperties(V.prototype, {
        wrapAround: {
            get: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }, set: function () {
                console.warn("THREE.Material: .wrapAround has been removed.")
            }
        }, overdraw: {
            get: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            }, set: function () {
                console.warn("THREE.Material: .overdraw has been removed.")
            }
        }, wrapRGB: {
            get: function () {
                return console.warn("THREE.Material: .wrapRGB has been removed."), new x
            }
        }, shading: {
            get: function () {
                console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.")
            }, set: function (t) {
                console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t
            }
        }
    }), Object.defineProperties(rn.prototype, {
        metal: {
            get: function () {
                return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1
            }, set: function () {
                console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead")
            }
        }
    }), Object.defineProperties(W.prototype, {
        derivatives: {
            get: function () {
                return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives
            }, set: function (t) {
                console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t
            }
        }
    }), Object.assign(Ae.prototype, {
        clearTarget: function (t, e, i, n) {
            console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n)
        }, animate: function (t) {
            console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t)
        }, getCurrentRenderTarget: function () {
            return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget()
        }, getMaxAnisotropy: function () {
            return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy()
        }, getPrecision: function () {
            return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision
        }, resetGLState: function () {
            return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset()
        }, supportsFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float")
        }, supportsHalfFloatTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float")
        }, supportsStandardDerivatives: function () {
            return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives")
        }, supportsCompressedTextureS3TC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc")
        }, supportsCompressedTexturePVRTC: function () {
            return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc")
        }, supportsBlendMinMax: function () {
            return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax")
        }, supportsVertexTextures: function () {
            return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures
        }, supportsInstancedArrays: function () {
            return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays")
        }, enableScissorTest: function (t) {
            console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t)
        }, initMaterial: function () {
            console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.")
        }, addPrePlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.")
        }, addPostPlugin: function () {
            console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.")
        }, updateShadowMap: function () {
            console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.")
        }, setFaceCulling: function () {
            console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.")
        }
    }), Object.defineProperties(Ae.prototype, {
        shadowMapEnabled: {
            get: function () {
                return this.shadowMap.enabled
            }, set: function (t) {
                console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t
            }
        }, shadowMapType: {
            get: function () {
                return this.shadowMap.type
            }, set: function (t) {
                console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t
            }
        }, shadowMapCullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(ge.prototype, {
        cullFace: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.")
            }
        }, renderReverseSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.")
            }
        }, renderSingleSided: {
            get: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }, set: function () {
                console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.")
            }
        }
    }), Object.defineProperties(c.prototype, {
        wrapS: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t
            }
        }, wrapT: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t
            }
        }, magFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t
            }
        }, minFilter: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t
            }
        }, anisotropy: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t
            }
        }, offset: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t
            }
        }, repeat: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t
            }
        }, format: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t
            }
        }, type: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t
            }
        }, generateMipmaps: {
            get: function () {
                return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps
            }, set: function (t) {
                console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t
            }
        }
    }), Object.defineProperties(Se.prototype, {
        standing: {
            set: function () {
                console.warn("THREE.WebVRManager: .standing has been removed.")
            }
        }, userHeight: {
            set: function () {
                console.warn("THREE.WebVRManager: .userHeight has been removed.")
            }
        }
    }), br.prototype.load = function (t) {
        console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.");
        var e = this;
        return (new gr).load(t, function (t) {
            e.setBuffer(t)
        }), this
    }, Mr.prototype.getData = function () {
        return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData()
    }, yr.prototype.updateCubeMap = function (t, e) {
        return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e)
    }, ha.crossOrigin = void 0, ha.loadTexture = function (t, e, i, n) {
        console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.");
        var r = new On;
        return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
    }, ha.loadTextureCube = function (t, e, i, n) {
        console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.");
        var r = new Rn;
        return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t
    }, ha.loadCompressedTexture = function () {
        console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.")
    }, ha.loadCompressedTextureCube = function () {
        console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.")
    }, t.WebGLMultisampleRenderTarget = h, t.WebGLRenderTargetCube = u, t.WebGLRenderTarget = c, t.WebGLRenderer = Ae, t.ShaderLib = ga, t.UniformsLib = ma, t.UniformsUtils = da, t.ShaderChunk = pa, t.FogExp2 = Pe, t.Fog = Le, t.Scene = Ce, t.Sprite = Ie, t.LOD = Ne, t.SkinnedMesh = ze, t.Skeleton = ke, t.Bone = Be, t.Mesh = J, t.LineSegments = Ue, t.LineLoop = Ge, t.Line = He, t.Points = Ve, t.Group = _e, t.VideoTexture = We, t.DataTexture = p, t.DataTexture3D = ct, t.CompressedTexture = qe, t.CubeTexture = lt, t.CanvasTexture = Xe, t.DepthTexture = Ye, t.Texture = s, t.AnimationLoader = An, t.CompressedTextureLoader = Pn, t.DataTextureLoader = Ln, t.CubeTextureLoader = Rn, t.TextureLoader = On, t.ObjectLoader = hr,t.MaterialLoader = lr,t.BufferGeometryLoader = cr,t.DefaultLoadingManager = Ga,t.LoadingManager = Sn,t.ImageLoader = Cn,t.ImageBitmapLoader = ur,t.FontLoader = fr,t.FileLoader = En,t.Loader = mr,t.LoaderUtils = Ja,t.Cache = Ua,t.AudioLoader = gr,t.SpotLightShadow = tr,t.SpotLight = er,t.PointLight = ir,t.RectAreaLight = sr,t.HemisphereLight = Qn,t.DirectionalLightShadow = rr,t.DirectionalLight = ar,t.AmbientLight = or,t.LightShadow = Kn,t.Light = $n,t.StereoCamera = vr,t.PerspectiveCamera = we,t.OrthographicCamera = nr,t.CubeCamera = yr,t.ArrayCamera = Me,t.Camera = be,t.AudioListener = _r,t.PositionalAudio = wr,t.AudioContext = eo,t.AudioAnalyser = Mr,t.Audio = br,t.VectorKeyframeTrack = bn,t.StringKeyframeTrack = _n,t.QuaternionKeyframeTrack = xn,t.NumberKeyframeTrack = vn,t.ColorKeyframeTrack = gn,t.BooleanKeyframeTrack = mn,t.PropertyMixer = Tr,t.PropertyBinding = Er,t.KeyframeTrack = fn,t.AnimationUtils = Ha,t.AnimationObjectGroup = Ar,t.AnimationMixer = Lr,t.AnimationClip = wn,t.Uniform = Cr,t.InstancedBufferGeometry = Rr,t.BufferGeometry = F,t.Geometry = E,t.InterleavedBufferAttribute = Oe,t.InstancedInterleavedBuffer = Or,t.InterleavedBuffer = Re,t.InstancedBufferAttribute = Dr,t.Face3 = w,t.Object3D = S,t.Raycaster = Ir,t.Layers = T,t.EventDispatcher = e,t.Clock = xr,t.QuaternionLinearInterpolant = yn,t.LinearInterpolant = pn,t.DiscreteInterpolant = dn,t.CubicInterpolant = un,t.Interpolant = hn,t.Triangle = X,t.Math = la,t.Spherical = kr,t.Cylindrical = Br,t.Plane = m,t.Frustum = g,t.Sphere = f,t.Ray = q,t.Matrix4 = n,t.Matrix3 = o,t.Box3 = d,t.Box2 = Fr,t.Line3 = Hr,t.Euler = M,t.Vector4 = l,t.Vector3 = a,t.Vector2 = i,t.Quaternion = r,t.Color = x,t.ImmediateRenderObject = Ur,t.VertexNormalsHelper = Gr,t.SpotLightHelper = jr,t.SkeletonHelper = Wr,t.PointLightHelper = qr,t.RectAreaLightHelper = Xr,t.HemisphereLightHelper = Yr,t.GridHelper = Jr,t.PolarGridHelper = Zr,t.FaceNormalsHelper = $r,t.DirectionalLightHelper = Qr,t.CameraHelper = Kr,t.BoxHelper = ta,t.Box3Helper = ea,t.PlaneHelper = ia;
    t.ArrowHelper = na, t.AxesHelper = ra, t.Shape = Zn, t.Path = Jn, t.ShapePath = pr, t.Font = dr, t.CurvePath = Yn, t.Curve = Dn, t.ImageUtils = ha, t.ShapeUtils = za, t.WebGLUtils = xe, t.WireframeGeometry = Je, t.ParametricGeometry = Ze, t.ParametricBufferGeometry = $e, t.TetrahedronGeometry = ti, t.TetrahedronBufferGeometry = ei, t.OctahedronGeometry = ii, t.OctahedronBufferGeometry = ni, t.IcosahedronGeometry = ri, t.IcosahedronBufferGeometry = ai, t.DodecahedronGeometry = oi, t.DodecahedronBufferGeometry = si, t.PolyhedronGeometry = Qe, t.PolyhedronBufferGeometry = Ke, t.TubeGeometry = li, t.TubeBufferGeometry = ci, t.TorusKnotGeometry = hi, t.TorusKnotBufferGeometry = ui, t.TorusGeometry = pi, t.TorusBufferGeometry = di, t.TextGeometry = Ni, t.TextBufferGeometry = zi, t.SphereGeometry = ki, t.SphereBufferGeometry = Bi, t.RingGeometry = Fi, t.RingBufferGeometry = Hi, t.PlaneGeometry = G, t.PlaneBufferGeometry = j, t.LatheGeometry = Ui, t.LatheBufferGeometry = Gi, t.ShapeGeometry = ji, t.ShapeBufferGeometry = Vi, t.ExtrudeGeometry = Oi, t.ExtrudeBufferGeometry = Di, t.EdgesGeometry = qi, t.ConeGeometry = Ji, t.ConeBufferGeometry = Zi, t.CylinderGeometry = Xi, t.CylinderBufferGeometry = Yi, t.CircleGeometry = $i, t.CircleBufferGeometry = Qi, t.BoxGeometry = H, t.BoxBufferGeometry = U, t.ShadowMaterial = Ki, t.SpriteMaterial = De, t.RawShaderMaterial = tn, t.ShaderMaterial = W, t.PointsMaterial = je, t.MeshPhysicalMaterial = nn, t.MeshStandardMaterial = en, t.MeshPhongMaterial = rn, t.MeshToonMaterial = an, t.MeshNormalMaterial = on, t.MeshLambertMaterial = sn, t.MeshDepthMaterial = fe, t.MeshDistanceMaterial = me, t.MeshBasicMaterial = Y, t.MeshMatcapMaterial = ln, t.LineDashedMaterial = cn, t.LineBasicMaterial = Fe, t.Material = V, t.Float64BufferAttribute = z, t.Float32BufferAttribute = N, t.Uint32BufferAttribute = I, t.Int32BufferAttribute = D, t.Uint16BufferAttribute = O, t.Int16BufferAttribute = R, t.Uint8ClampedBufferAttribute = C, t.Uint8BufferAttribute = L, t.Int8BufferAttribute = P, t.BufferAttribute = A, t.ArcCurve = Nn, t.CatmullRomCurve3 = kn, t.CubicBezierCurve = Un, t.CubicBezierCurve3 = Gn, t.EllipseCurve = In, t.LineCurve = jn, t.LineCurve3 = Vn, t.QuadraticBezierCurve = Wn, t.QuadraticBezierCurve3 = qn, t.SplineCurve = Xn, t.REVISION = "101", t.MOUSE = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2
    }, t.CullFaceNone = 0, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.FrontFaceDirectionCW = 0, t.FrontFaceDirectionCCW = 1, t.BasicShadowMap = 0, t.PCFShadowMap = 1,t.PCFSoftShadowMap = 2,t.FrontSide = 0,t.BackSide = 1,t.DoubleSide = 2,t.FlatShading = 1,t.SmoothShading = 2,t.NoColors = 0,t.FaceColors = 1,t.VertexColors = 2,t.NoBlending = 0,t.NormalBlending = 1,t.AdditiveBlending = 2,t.SubtractiveBlending = 3,t.MultiplyBlending = 4,t.CustomBlending = 5,t.AddEquation = 100,t.SubtractEquation = 101,t.ReverseSubtractEquation = 102,t.MinEquation = 103,t.MaxEquation = 104,t.ZeroFactor = 200,t.OneFactor = 201,t.SrcColorFactor = 202,t.OneMinusSrcColorFactor = 203,t.SrcAlphaFactor = 204,t.OneMinusSrcAlphaFactor = 205,t.DstAlphaFactor = 206,t.OneMinusDstAlphaFactor = 207,t.DstColorFactor = 208,t.OneMinusDstColorFactor = 209,t.SrcAlphaSaturateFactor = 210,t.NeverDepth = 0,t.AlwaysDepth = 1,t.LessDepth = 2,t.LessEqualDepth = 3,t.EqualDepth = 4,t.GreaterEqualDepth = 5,t.GreaterDepth = 6,t.NotEqualDepth = 7,t.MultiplyOperation = 0,t.MixOperation = 1,t.AddOperation = 2,t.NoToneMapping = 0,t.LinearToneMapping = 1,t.ReinhardToneMapping = 2,t.Uncharted2ToneMapping = 3,t.CineonToneMapping = 4,t.ACESFilmicToneMapping = 5,t.UVMapping = 300,t.CubeReflectionMapping = 301,t.CubeRefractionMapping = 302,t.EquirectangularReflectionMapping = 303,t.EquirectangularRefractionMapping = 304,t.SphericalReflectionMapping = 305,t.CubeUVReflectionMapping = 306,t.CubeUVRefractionMapping = 307,t.RepeatWrapping = 1e3,t.ClampToEdgeWrapping = 1001,t.MirroredRepeatWrapping = 1002,t.NearestFilter = 1003,t.NearestMipMapNearestFilter = 1004,t.NearestMipMapLinearFilter = 1005,t.LinearFilter = 1006,t.LinearMipMapNearestFilter = 1007,t.LinearMipMapLinearFilter = 1008,t.UnsignedByteType = 1009,t.ByteType = 1010,t.ShortType = 1011,t.UnsignedShortType = 1012,t.IntType = 1013,t.UnsignedIntType = 1014,t.FloatType = 1015,t.HalfFloatType = 1016,t.UnsignedShort4444Type = 1017,t.UnsignedShort5551Type = 1018,t.UnsignedShort565Type = 1019,t.UnsignedInt248Type = 1020,t.AlphaFormat = 1021,t.RGBFormat = 1022,t.RGBAFormat = 1023,t.LuminanceFormat = 1024,t.LuminanceAlphaFormat = 1025,t.RGBEFormat = 1023,t.DepthFormat = 1026,t.DepthStencilFormat = 1027,t.RedFormat = 1028,t.RGB_S3TC_DXT1_Format = 33776,t.RGBA_S3TC_DXT1_Format = 33777,t.RGBA_S3TC_DXT3_Format = 33778,t.RGBA_S3TC_DXT5_Format = 33779,t.RGB_PVRTC_4BPPV1_Format = 35840,t.RGB_PVRTC_2BPPV1_Format = 35841,t.RGBA_PVRTC_4BPPV1_Format = 35842,t.RGBA_PVRTC_2BPPV1_Format = 35843,t.RGB_ETC1_Format = 36196,t.RGBA_ASTC_4x4_Format = 37808,t.RGBA_ASTC_5x4_Format = 37809,t.RGBA_ASTC_5x5_Format = 37810,t.RGBA_ASTC_6x5_Format = 37811;
    t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.LoopOnce = 2200, t.LoopRepeat = 2201, t.LoopPingPong = 2202, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.ZeroCurvatureEnding = 2400, t.ZeroSlopeEnding = 2401, t.WrapAroundEnding = 2402, t.TrianglesDrawMode = 0, t.TriangleStripDrawMode = 1, t.TriangleFanDrawMode = 2, t.LinearEncoding = 3e3, t.sRGBEncoding = 3001, t.GammaEncoding = 3007, t.RGBEEncoding = 3002, t.LogLuvEncoding = 3003, t.RGBM7Encoding = 3004, t.RGBM16Encoding = 3005, t.RGBDEncoding = 3006, t.BasicDepthPacking = 3200, t.RGBADepthPacking = 3201, t.TangentSpaceNormalMap = 0, t.ObjectSpaceNormalMap = 1, t.CubeGeometry = H, t.Face4 = function (t, e, i, n, r, a, o) {
        return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new w(t, e, i, r, a, o)
    }, t.LineStrip = 0, t.LinePieces = 1, t.MeshFaceMaterial = function (t) {
        return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t
    }, t.MultiMaterial = function (t) {
        return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function () {
            return t.slice()
        }, t
    }, t.PointCloud = function (t, e) {
        return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ve(t, e)
    }, t.Particle = function (t) {
        return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Ie(t)
    }, t.ParticleSystem = function (t, e) {
        return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ve(t, e)
    }, t.PointCloudMaterial = function (t) {
        return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new je(t)
    }, t.ParticleBasicMaterial = function (t) {
        return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new je(t)
    }, t.ParticleSystemMaterial = function (t) {
        return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new je(t)
    }, t.Vertex = function (t, e, i) {
        return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new a(t, e, i)
    }, t.DynamicBufferAttribute = function (t, e) {
        return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new A(t, e).setDynamic(!0)
    }, t.Int8Attribute = function (t, e) {
        return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new P(t, e)
    }, t.Uint8Attribute = function (t, e) {
        return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new L(t, e)
    }, t.Uint8ClampedAttribute = function (t, e) {
        return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new C(t, e)
    }, t.Int16Attribute = function (t, e) {
        return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new R(t, e)
    }, t.Uint16Attribute = function (t, e) {
        return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new O(t, e)
    }, t.Int32Attribute = function (t, e) {
        return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new D(t, e)
    }, t.Uint32Attribute = function (t, e) {
        return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new I(t, e)
    }, t.Float32Attribute = function (t, e) {
        return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new N(t, e)
    }, t.Float64Attribute = function (t, e) {
        return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new z(t, e)
    }, t.ClosedSplineCurve3 = aa, t.SplineCurve3 = oa, t.Spline = sa, t.AxisHelper = function (t) {
        return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new ra(t)
    }, t.BoundingBoxHelper = function (t, e) {
        return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ta(t, e)
    }, t.EdgesHelper = function (t, e) {
        return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ue(new qi(t.geometry), new Fe({color: void 0 !== e ? e : 16777215}))
    }, t.WireframeHelper = function (t, e) {
        return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ue(new Je(t.geometry), new Fe({color: void 0 !== e ? e : 16777215}))
    }, t.XHRLoader = function (t) {
        return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new En(t)
    }, t.BinaryTextureLoader = function (t) {
        return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Ln(t)
    }, t.GeometryUtils = {
        merge: function (t, e, i) {
            if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh) {
                e.matrixAutoUpdate && e.updateMatrix();
                var n = e.matrix;
                e = e.geometry
            }
            t.merge(e, n, i)
        }, center: function (t) {
            return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center()
        }
    }, t.Projector = function () {
        console.error("THREE.Projector has been moved to /examples/js/renderers/Projector.js."), this.projectVector = function (t, e) {
            console.warn("THREE.Projector: .projectVector() is now vector.project()."), t.project(e)
        }, this.unprojectVector = function (t, e) {
            console.warn("THREE.Projector: .unprojectVector() is now vector.unproject()."), t.unproject(e)
        }, this.pickingRay = function () {
            console.error("THREE.Projector: .pickingRay() is now raycaster.setFromCamera().")
        }
    }, t.CanvasRenderer = function () {
        console.error("THREE.CanvasRenderer has been removed")
    }, t.JSONLoader = function () {
        console.error("THREE.JSONLoader has been removed.")
    }, t.SceneUtils = {
        createMultiMaterialObject: function () {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }, detach: function () {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }, attach: function () {
            console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js")
        }
    }, t.LensFlare = function () {
        console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js")
    }, Object.defineProperty(t, "__esModule", {value: !0})
}), function (t, e) {
    "use strict";
    "object" == typeof module && "object" == typeof module.exports ? module.exports = t.document ? e(t, !0) : function (t) {
        if (!t.document) throw new Error("jQuery requires a window with a document");
        return e(t)
    } : e(t)
}("undefined" != typeof window ? window : this, function (t, e) {
    "use strict";

    function i(t, e, i) {
        var n, r = (e = e || ot).createElement("script");
        if (r.text = t, i) for (n in _t) i[n] && (r[n] = i[n]);
        e.head.appendChild(r).parentNode.removeChild(r)
    }

    function n(t) {
        return null == t ? t + "" : "object" == typeof t || "function" == typeof t ? pt[dt.call(t)] || "object" : typeof t
    }

    function r(t) {
        var e = !!t && "length" in t && t.length, i = n(t);
        return !yt(t) && !xt(t) && ("array" === i || 0 === e || "number" == typeof e && e > 0 && e - 1 in t)
    }

    function a(t, e) {
        return t.nodeName && t.nodeName.toLowerCase() === e.toLowerCase()
    }

    function o(t, e, i) {
        return yt(e) ? wt.grep(t, function (t, n) {
            return !!e.call(t, n, t) !== i
        }) : e.nodeType ? wt.grep(t, function (t) {
            return t === e !== i
        }) : "string" != typeof e ? wt.grep(t, function (t) {
            return ut.call(e, t) > -1 !== i
        }) : wt.filter(e, t, i)
    }

    function s(t, e) {
        for (; (t = t[e]) && 1 !== t.nodeType;) ;
        return t
    }

    function l(t) {
        var e = {};
        return wt.each(t.match(Dt) || [], function (t, i) {
            e[i] = !0
        }), e
    }

    function c(t) {
        return t
    }

    function h(t) {
        throw t
    }

    function $(t, e, i, n) {
        var r;
        try {
            t && yt(r = t.promise) ? r.call(t).done(e).fail(i) : t && yt(r = t.then) ? r.call(t, e, i) : e.apply(void 0, [t].slice(n))
        } catch (t) {
            i.apply(void 0, [t])
        }
    }

    function u() {
        ot.removeEventListener("DOMContentLoaded", u), t.removeEventListener("load", u), wt.ready()
    }

    function p(t, e) {
        return e.toUpperCase()
    }

    function d(t) {
        return t.replace(kt, "ms-").replace(Bt, p)
    }

    function f() {
        this.expando = wt.expando + f.uid++
    }

    function m(t) {
        return "true" === t || "false" !== t && ("null" === t ? null : t === +t + "" ? +t : Gt.test(t) ? JSON.parse(t) : t)
    }

    function g(t, e, i) {
        var n;
        if (void 0 === i && 1 === t.nodeType) if (n = "data-" + e.replace(jt, "-$&").toLowerCase(), "string" == typeof (i = t.getAttribute(n))) {
            try {
                i = m(i)
            } catch (t) {
            }
            Ut.set(t, e, i)
        } else i = void 0;
        return i
    }

    function v(t, e, i, n) {
        var r, a, o = 20, s = n ? function () {
                return n.cur()
            } : function () {
                return wt.css(t, e, "")
            }, l = s(), c = i && i[3] || (wt.cssNumber[e] ? "" : "px"),
            h = (wt.cssNumber[e] || "px" !== c && +l) && Wt.exec(wt.css(t, e));
        if (h && h[3] !== c) {
            for (l /= 2, c = c || h[3], h = +l || 1; o--;) wt.style(t, e, h + c), (1 - a) * (1 - (a = s() / l || .5)) <= 0 && (o = 0), h /= a;
            h *= 2, wt.style(t, e, h + c), i = i || []
        }
        return i && (h = +h || +l || 0, r = i[1] ? h + (i[1] + 1) * i[2] : +i[2], n && (n.unit = c, n.start = h, n.end = r)), r
    }

    function y(t) {
        var e, i = t.ownerDocument, n = t.nodeName, r = Jt[n];
        return r || (e = i.body.appendChild(i.createElement(n)), r = wt.css(e, "display"), e.parentNode.removeChild(e), "none" === r && (r = "block"), Jt[n] = r, r)
    }

    function x(t, e) {
        for (var i, n, r = [], a = 0, o = t.length; a < o; a++) (n = t[a]).style && (i = n.style.display, e ? ("none" === i && (r[a] = Ht.get(n, "display") || null, r[a] || (n.style.display = "")), "" === n.style.display && Xt(n) && (r[a] = y(n))) : "none" !== i && (r[a] = "none", Ht.set(n, "display", i)));
        for (a = 0; a < o; a++) null != r[a] && (t[a].style.display = r[a]);
        return t
    }

    function _(t, e) {
        var i;
        return i = void 0 !== t.getElementsByTagName ? t.getElementsByTagName(e || "*") : void 0 !== t.querySelectorAll ? t.querySelectorAll(e || "*") : [], void 0 === e || e && a(t, e) ? wt.merge([t], i) : i
    }

    function b(t, e) {
        for (var i = 0, n = t.length; i < n; i++) Ht.set(t[i], "globalEval", !e || Ht.get(e[i], "globalEval"))
    }

    function w(t, e, i, r, a) {
        for (var o, s, l, c, h, u, p = e.createDocumentFragment(), d = [], f = 0, m = t.length; f < m; f++) if ((o = t[f]) || 0 === o) if ("object" === n(o)) wt.merge(d, o.nodeType ? [o] : o); else if (te.test(o)) {
            for (s = s || p.appendChild(e.createElement("div")), l = ($t.exec(o) || ["", ""])[1].toLowerCase(), c = Kt[l] || Kt._default, s.innerHTML = c[1] + wt.htmlPrefilter(o) + c[2], u = c[0]; u--;) s = s.lastChild;
            wt.merge(d, s.childNodes), (s = p.firstChild).textContent = ""
        } else d.push(e.createTextNode(o));
        for (p.textContent = "", f = 0; o = d[f++];) if (r && wt.inArray(o, r) > -1) a && a.push(o); else if (h = wt.contains(o.ownerDocument, o), s = _(p.appendChild(o), "script"), h && b(s), i) for (u = 0; o = s[u++];) Qt.test(o.type || "") && i.push(o);
        return p
    }

    function M() {
        return !0
    }

    function T() {
        return !1
    }

    function S() {
        try {
            return ot.activeElement
        } catch (t) {
        }
    }

    function E(t, e, i, n, r, a) {
        var o, s;
        if ("object" == typeof e) {
            "string" != typeof i && (n = n || i, i = void 0);
            for (s in e) E(t, s, i, n, e[s], a);
            return t
        }
        if (null == n && null == r ? (r = i, n = i = void 0) : null == r && ("string" == typeof i ? (r = n, n = void 0) : (r = n, n = i, i = void 0)), !1 === r) r = T; else if (!r) return t;
        return 1 === a && (o = r, (r = function (t) {
            return wt().off(t), o.apply(this, arguments)
        }).guid = o.guid || (o.guid = wt.guid++)), t.each(function () {
            wt.event.add(this, e, r, n, i)
        })
    }

    function A(t, e) {
        return a(t, "table") && a(11 !== e.nodeType ? e : e.firstChild, "tr") ? wt(t).children("tbody")[0] || t : t
    }

    function P(t) {
        return t.type = (null !== t.getAttribute("type")) + "/" + t.type, t
    }

    function L(t) {
        return "true/" === (t.type || "").slice(0, 5) ? t.type = t.type.slice(5) : t.removeAttribute("type"), t
    }

    function C(t, e) {
        var i, n, r, a, o, s, l, c;
        if (1 === e.nodeType) {
            if (Ht.hasData(t) && (a = Ht.access(t), o = Ht.set(e, a), c = a.events)) {
                delete o.handle, o.events = {};
                for (r in c) for (i = 0, n = c[r].length; i < n; i++) wt.event.add(e, r, c[r][i])
            }
            Ut.hasData(t) && (s = Ut.access(t), l = wt.extend({}, s), Ut.set(e, l))
        }
    }

    function R(t, e) {
        var i = e.nodeName.toLowerCase();
        "input" === i && Zt.test(t.type) ? e.checked = t.checked : "input" !== i && "textarea" !== i || (e.defaultValue = t.defaultValue)
    }

    function O(t, e, n, r) {
        e = ct.apply([], e);
        var a, o, s, l, c, h, u = 0, p = t.length, d = p - 1, f = e[0], m = yt(f);
        if (m || p > 1 && "string" == typeof f && !vt.checkClone && se.test(f)) return t.each(function (i) {
            var a = t.eq(i);
            m && (e[0] = f.call(this, i, a.html())), O(a, e, n, r)
        });
        if (p && (a = w(e, t[0].ownerDocument, !1, t, r), o = a.firstChild, 1 === a.childNodes.length && (a = o), o || r)) {
            for (l = (s = wt.map(_(a, "script"), P)).length; u < p; u++) c = a, u !== d && (c = wt.clone(c, !0, !0), l && wt.merge(s, _(c, "script"))), n.call(t[u], c, u);
            if (l) for (h = s[s.length - 1].ownerDocument, wt.map(s, L), u = 0; u < l; u++) c = s[u], Qt.test(c.type || "") && !Ht.access(c, "globalEval") && wt.contains(h, c) && (c.src && "module" !== (c.type || "").toLowerCase() ? wt._evalUrl && wt._evalUrl(c.src) : i(c.textContent.replace(le, ""), h, c))
        }
        return t
    }

    function D(t, e, i) {
        for (var n, r = e ? wt.filter(e, t) : t, a = 0; null != (n = r[a]); a++) i || 1 !== n.nodeType || wt.cleanData(_(n)), n.parentNode && (i && wt.contains(n.ownerDocument, n) && b(_(n, "script")), n.parentNode.removeChild(n));
        return t
    }

    function I(t, e, i) {
        var n, r, a, o, s = t.style;
        return (i = i || he(t)) && ("" !== (o = i.getPropertyValue(e) || i[e]) || wt.contains(t.ownerDocument, t) || (o = wt.style(t, e)), !vt.pixelBoxStyles() && ce.test(o) && ue.test(e) && (n = s.width, r = s.minWidth, a = s.maxWidth, s.minWidth = s.maxWidth = s.width = o, o = i.width, s.width = n, s.minWidth = r, s.maxWidth = a)), void 0 !== o ? o + "" : o
    }

    function N(t, e) {
        return {
            get: function () {
                if (!t()) return (this.get = e).apply(this, arguments);
                delete this.get
            }
        }
    }

    function z(t) {
        if (t in ve) return t;
        for (var e = t[0].toUpperCase() + t.slice(1), i = ge.length; i--;) if ((t = ge[i] + e) in ve) return t
    }

    function k(t) {
        var e = wt.cssProps[t];
        return e || (e = wt.cssProps[t] = z(t) || t), e
    }

    function B(t, e, i) {
        var n = Wt.exec(e);
        return n ? Math.max(0, n[2] - (i || 0)) + (n[3] || "px") : e
    }

    function F(t, e, i, n, r, a) {
        var o = "width" === e ? 1 : 0, s = 0, l = 0;
        if (i === (n ? "border" : "content")) return 0;
        for (; o < 4; o += 2) "margin" === i && (l += wt.css(t, i + qt[o], !0, r)), n ? ("content" === i && (l -= wt.css(t, "padding" + qt[o], !0, r)), "margin" !== i && (l -= wt.css(t, "border" + qt[o] + "Width", !0, r))) : (l += wt.css(t, "padding" + qt[o], !0, r), "padding" !== i ? l += wt.css(t, "border" + qt[o] + "Width", !0, r) : s += wt.css(t, "border" + qt[o] + "Width", !0, r));
        return !n && a >= 0 && (l += Math.max(0, Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - a - l - s - .5))), l
    }

    function H(t, e, i) {
        var n = he(t), r = I(t, e, n), a = "border-box" === wt.css(t, "boxSizing", !1, n), o = a;
        if (ce.test(r)) {
            if (!i) return r;
            r = "auto"
        }
        return o = o && (vt.boxSizingReliable() || r === t.style[e]), ("auto" === r || !parseFloat(r) && "inline" === wt.css(t, "display", !1, n)) && (r = t["offset" + e[0].toUpperCase() + e.slice(1)], o = !0), (r = parseFloat(r) || 0) + F(t, e, i || (a ? "border" : "content"), o, n, r) + "px"
    }

    function U(t, e, i, n, r) {
        return new U.prototype.init(t, e, i, n, r)
    }

    function G() {
        xe && (!1 === ot.hidden && t.requestAnimationFrame ? t.requestAnimationFrame(G) : t.setTimeout(G, wt.fx.interval), wt.fx.tick())
    }

    function j() {
        return t.setTimeout(function () {
            ye = void 0
        }), ye = Date.now()
    }

    function V(t, e) {
        var i, n = 0, r = {height: t};
        for (e = e ? 1 : 0; n < 4; n += 2 - e) r["margin" + (i = qt[n])] = r["padding" + i] = t;
        return e && (r.opacity = r.width = t), r
    }

    function W(t, e, i) {
        for (var n, r = (Y.tweeners[e] || []).concat(Y.tweeners["*"]), a = 0, o = r.length; a < o; a++) if (n = r[a].call(i, e, t)) return n
    }

    function q(t, e, i) {
        var n, r, a, o, s, l, c, h, u = "width" in e || "height" in e, p = this, d = {}, f = t.style,
            m = t.nodeType && Xt(t), g = Ht.get(t, "fxshow");
        i.queue || (null == (o = wt._queueHooks(t, "fx")).unqueued && (o.unqueued = 0, s = o.empty.fire, o.empty.fire = function () {
            o.unqueued || s()
        }), o.unqueued++, p.always(function () {
            p.always(function () {
                o.unqueued--, wt.queue(t, "fx").length || o.empty.fire()
            })
        }));
        for (n in e) if (r = e[n], _e.test(r)) {
            if (delete e[n],
                a = a || "toggle" === r, r === (m ? "hide" : "show")) {
                if ("show" !== r || !g || void 0 === g[n]) continue;
                m = !0
            }
            d[n] = g && g[n] || wt.style(t, n)
        }
        if ((l = !wt.isEmptyObject(e)) || !wt.isEmptyObject(d)) {
            u && 1 === t.nodeType && (i.overflow = [f.overflow, f.overflowX, f.overflowY], null == (c = g && g.display) && (c = Ht.get(t, "display")), "none" === (h = wt.css(t, "display")) && (c ? h = c : (x([t], !0), c = t.style.display || c, h = wt.css(t, "display"), x([t]))), ("inline" === h || "inline-block" === h && null != c) && "none" === wt.css(t, "float") && (l || (p.done(function () {
                f.display = c
            }), null == c && (h = f.display, c = "none" === h ? "" : h)), f.display = "inline-block")), i.overflow && (f.overflow = "hidden", p.always(function () {
                f.overflow = i.overflow[0], f.overflowX = i.overflow[1], f.overflowY = i.overflow[2]
            })), l = !1;
            for (n in d) l || (g ? "hidden" in g && (m = g.hidden) : g = Ht.access(t, "fxshow", {display: c}), a && (g.hidden = !m), m && x([t], !0), p.done(function () {
                m || x([t]), Ht.remove(t, "fxshow");
                for (n in d) wt.style(t, n, d[n])
            })), l = W(m ? g[n] : 0, n, p), n in g || (g[n] = l.start, m && (l.end = l.start, l.start = 0))
        }
    }

    function X(t, e) {
        var i, n, r, a, o;
        for (i in t) if (n = d(i), r = e[n], a = t[i], Array.isArray(a) && (r = a[1], a = t[i] = a[0]), i !== n && (t[n] = a, delete t[i]), (o = wt.cssHooks[n]) && "expand" in o) {
            a = o.expand(a), delete t[n];
            for (i in a) i in t || (t[i] = a[i], e[i] = r)
        } else e[n] = r
    }

    function Y(t, e, i) {
        var n, r, a = 0, o = Y.prefilters.length, s = wt.Deferred().always(function () {
            delete l.elem
        }), l = function () {
            if (r) return !1;
            for (var e = ye || j(), i = Math.max(0, c.startTime + c.duration - e), n = 1 - (i / c.duration || 0), a = 0, o = c.tweens.length; a < o; a++) c.tweens[a].run(n);
            return s.notifyWith(t, [c, n, i]), n < 1 && o ? i : (o || s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c]), !1)
        }, c = s.promise({
            elem: t,
            props: wt.extend({}, e),
            opts: wt.extend(!0, {specialEasing: {}, easing: wt.easing._default}, i),
            originalProperties: e,
            originalOptions: i,
            startTime: ye || j(),
            duration: i.duration,
            tweens: [],
            createTween: function (e, i) {
                var n = wt.Tween(t, c.opts, e, i, c.opts.specialEasing[e] || c.opts.easing);
                return c.tweens.push(n), n
            },
            stop: function (e) {
                var i = 0, n = e ? c.tweens.length : 0;
                if (r) return this;
                for (r = !0; i < n; i++) c.tweens[i].run(1);
                return e ? (s.notifyWith(t, [c, 1, 0]), s.resolveWith(t, [c, e])) : s.rejectWith(t, [c, e]), this
            }
        }), h = c.props;
        for (X(h, c.opts.specialEasing); a < o; a++) if (n = Y.prefilters[a].call(c, t, h, c.opts)) return yt(n.stop) && (wt._queueHooks(c.elem, c.opts.queue).stop = n.stop.bind(n)), n;
        return wt.map(h, W, c), yt(c.opts.start) && c.opts.start.call(t, c), c.progress(c.opts.progress).done(c.opts.done, c.opts.complete).fail(c.opts.fail).always(c.opts.always), wt.fx.timer(wt.extend(l, {
            elem: t,
            anim: c,
            queue: c.opts.queue
        })), c
    }

    function J(t) {
        return (t.match(Dt) || []).join(" ")
    }

    function Z(t) {
        return t.getAttribute && t.getAttribute("class") || ""
    }

    function Q(t) {
        return Array.isArray(t) ? t : "string" == typeof t ? t.match(Dt) || [] : []
    }

    function K(t, e, i, r) {
        var a;
        if (Array.isArray(e)) wt.each(e, function (e, n) {
            i || Oe.test(t) ? r(t, n) : K(t + "[" + ("object" == typeof n && null != n ? e : "") + "]", n, i, r)
        }); else if (i || "object" !== n(e)) r(t, e); else for (a in e) K(t + "[" + a + "]", e[a], i, r)
    }

    function tt(t) {
        return function (e, i) {
            "string" != typeof e && (i = e, e = "*");
            var n, r = 0, a = e.toLowerCase().match(Dt) || [];
            if (yt(i)) for (; n = a[r++];) "+" === n[0] ? (n = n.slice(1) || "*", (t[n] = t[n] || []).unshift(i)) : (t[n] = t[n] || []).push(i)
        }
    }

    function et(t, e, i, n) {
        function r(s) {
            var l;
            return a[s] = !0, wt.each(t[s] || [], function (t, s) {
                var c = s(e, i, n);
                return "string" != typeof c || o || a[c] ? o ? !(l = c) : void 0 : (e.dataTypes.unshift(c), r(c), !1)
            }), l
        }

        var a = {}, o = t === Ve;
        return r(e.dataTypes[0]) || !a["*"] && r("*")
    }

    function it(t, e) {
        var i, n, r = wt.ajaxSettings.flatOptions || {};
        for (i in e) void 0 !== e[i] && ((r[i] ? t : n || (n = {}))[i] = e[i]);
        return n && wt.extend(!0, t, n), t
    }

    function nt(t, e, i) {
        for (var n, r, a, o, s = t.contents, l = t.dataTypes; "*" === l[0];) l.shift(), void 0 === n && (n = t.mimeType || e.getResponseHeader("Content-Type"));
        if (n) for (r in s) if (s[r] && s[r].test(n)) {
            l.unshift(r);
            break
        }
        if (l[0] in i) a = l[0]; else {
            for (r in i) {
                if (!l[0] || t.converters[r + " " + l[0]]) {
                    a = r;
                    break
                }
                o || (o = r)
            }
            a = a || o
        }
        if (a) return a !== l[0] && l.unshift(a), i[a]
    }

    function rt(t, e, i, n) {
        var r, a, o, s, l, c = {}, h = t.dataTypes.slice();
        if (h[1]) for (o in t.converters) c[o.toLowerCase()] = t.converters[o];
        for (a = h.shift(); a;) if (t.responseFields[a] && (i[t.responseFields[a]] = e), !l && n && t.dataFilter && (e = t.dataFilter(e, t.dataType)), l = a, a = h.shift()) if ("*" === a) a = l; else if ("*" !== l && l !== a) {
            if (!(o = c[l + " " + a] || c["* " + a])) for (r in c) if ((s = r.split(" "))[1] === a && (o = c[l + " " + s[0]] || c["* " + s[0]])) {
                !0 === o ? o = c[r] : !0 !== c[r] && (a = s[0], h.unshift(s[1]));
                break
            }
            if (!0 !== o) if (o && t.throws) e = o(e); else try {
                e = o(e)
            } catch (t) {
                return {state: "parsererror", error: o ? t : "No conversion from " + l + " to " + a}
            }
        }
        return {state: "success", data: e}
    }

    var at = [], ot = t.document, st = Object.getPrototypeOf, lt = at.slice, ct = at.concat, ht = at.push,
        ut = at.indexOf, pt = {}, dt = pt.toString, ft = pt.hasOwnProperty, mt = ft.toString, gt = mt.call(Object),
        vt = {}, yt = function t(e) {
            return "function" == typeof e && "number" != typeof e.nodeType
        }, xt = function t(e) {
            return null != e && e === e.window
        }, _t = {type: !0, src: !0, noModule: !0}, bt = "3.3.1", wt = function (t, e) {
            return new wt.fn.init(t, e)
        }, Mt = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
    wt.fn = wt.prototype = {
        jquery: "3.3.1", constructor: wt, length: 0, toArray: function () {
            return lt.call(this)
        }, get: function (t) {
            return null == t ? lt.call(this) : t < 0 ? this[t + this.length] : this[t]
        }, pushStack: function (t) {
            var e = wt.merge(this.constructor(), t);
            return e.prevObject = this, e
        }, each: function (t) {
            return wt.each(this, t)
        }, map: function (t) {
            return this.pushStack(wt.map(this, function (e, i) {
                return t.call(e, i, e)
            }))
        }, slice: function () {
            return this.pushStack(lt.apply(this, arguments))
        }, first: function () {
            return this.eq(0)
        }, last: function () {
            return this.eq(-1)
        }, eq: function (t) {
            var e = this.length, i = +t + (t < 0 ? e : 0);
            return this.pushStack(i >= 0 && i < e ? [this[i]] : [])
        }, end: function () {
            return this.prevObject || this.constructor()
        }, push: ht, sort: at.sort, splice: at.splice
    }, wt.extend = wt.fn.extend = function () {
        var t, e, i, n, r, a, o = arguments[0] || {}, s = 1, l = arguments.length, c = !1;
        for ("boolean" == typeof o && (c = o, o = arguments[s] || {}, s++), "object" == typeof o || yt(o) || (o = {}), s === l && (o = this, s--); s < l; s++) if (null != (t = arguments[s])) for (e in t) i = o[e], o !== (n = t[e]) && (c && n && (wt.isPlainObject(n) || (r = Array.isArray(n))) ? (r ? (r = !1, a = i && Array.isArray(i) ? i : []) : a = i && wt.isPlainObject(i) ? i : {}, o[e] = wt.extend(c, a, n)) : void 0 !== n && (o[e] = n));
        return o
    }, wt.extend({
        expando: "jQuery" + ("3.3.1" + Math.random()).replace(/\D/g, ""), isReady: !0, error: function (t) {
            throw new Error(t)
        }, noop: function () {
        }, isPlainObject: function (t) {
            var e, i;
            return !(!t || "[object Object]" !== dt.call(t) || (e = st(t)) && ("function" != typeof (i = ft.call(e, "constructor") && e.constructor) || mt.call(i) !== gt))
        }, isEmptyObject: function (t) {
            var e;
            for (e in t) return !1;
            return !0
        }, globalEval: function (t) {
            i(t)
        }, each: function (t, e) {
            var i, n = 0;
            if (r(t)) for (i = t.length; n < i && !1 !== e.call(t[n], n, t[n]); n++) ; else for (n in t) if (!1 === e.call(t[n], n, t[n])) break;
            return t
        }, trim: function (t) {
            return null == t ? "" : (t + "").replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
        }, makeArray: function (t, e) {
            var i = e || [];
            return null != t && (r(Object(t)) ? wt.merge(i, "string" == typeof t ? [t] : t) : ht.call(i, t)), i
        }, inArray: function (t, e, i) {
            return null == e ? -1 : ut.call(e, t, i)
        }, merge: function (t, e) {
            for (var i = +e.length, n = 0, r = t.length; n < i; n++) t[r++] = e[n];
            return t.length = r, t
        }, grep: function (t, e, i) {
            for (var n, r = [], a = 0, o = t.length, s = !i; a < o; a++) (n = !e(t[a], a)) !== s && r.push(t[a]);
            return r
        }, map: function (t, e, i) {
            var n, a, o = 0, s = [];
            if (r(t)) for (n = t.length; o < n; o++) null != (a = e(t[o], o, i)) && s.push(a); else for (o in t) null != (a = e(t[o], o, i)) && s.push(a);
            return ct.apply([], s)
        }, guid: 1, support: vt
    }), "function" == typeof Symbol && (wt.fn[Symbol.iterator] = at[Symbol.iterator]), wt.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (t, e) {
        pt["[object " + e + "]"] = e.toLowerCase()
    });
    var Tt = function (t) {
        function e(t, e, i, n) {
            var r, a, o, s, l, c, h, p = e && e.ownerDocument, f = e ? e.nodeType : 9;
            if (i = i || [], "string" != typeof t || !t || 1 !== f && 9 !== f && 11 !== f) return i;
            if (!n && ((e ? e.ownerDocument || e : U) !== D && O(e), e = e || D, N)) {
                if (11 !== f && (l = vt.exec(t))) if (r = l[1]) {
                    if (9 === f) {
                        if (!(o = e.getElementById(r))) return i;
                        if (o.id === r) return i.push(o), i
                    } else if (p && (o = p.getElementById(r)) && F(e, o) && o.id === r) return i.push(o), i
                } else {
                    if (l[2]) return K.apply(i, e.getElementsByTagName(t)), i;
                    if ((r = l[3]) && w.getElementsByClassName && e.getElementsByClassName) return K.apply(i, e.getElementsByClassName(r)), i
                }
                if (w.qsa && !q[t + " "] && (!z || !z.test(t))) {
                    if (1 !== f) p = e, h = t; else if ("object" !== e.nodeName.toLowerCase()) {
                        for ((s = e.getAttribute("id")) ? s = s.replace(bt, wt) : e.setAttribute("id", s = H), a = (c = E(t)).length; a--;) c[a] = "#" + s + " " + d(c[a]);
                        h = c.join(","), p = yt.test(t) && u(e.parentNode) || e
                    }
                    if (h) try {
                        return K.apply(i, p.querySelectorAll(h)), i
                    } catch (t) {
                    } finally {
                        s === H && e.removeAttribute("id")
                    }
                }
            }
            return P(t.replace(st, "$1"), e, i, n)
        }

        function i() {
            function t(i, n) {
                return e.push(i + " ") > M.cacheLength && delete t[e.shift()], t[i + " "] = n
            }

            var e = [];
            return t
        }

        function n(t) {
            return t[H] = !0, t
        }

        function r(t) {
            var e = D.createElement("fieldset");
            try {
                return !!t(e)
            } catch (t) {
                return !1
            } finally {
                e.parentNode && e.parentNode.removeChild(e), e = null
            }
        }

        function a(t, e) {
            for (var i = t.split("|"), n = i.length; n--;) M.attrHandle[i[n]] = e
        }

        function o(t, e) {
            var i = e && t, n = i && 1 === t.nodeType && 1 === e.nodeType && t.sourceIndex - e.sourceIndex;
            if (n) return n;
            if (i) for (; i = i.nextSibling;) if (i === e) return -1;
            return t ? 1 : -1
        }

        function s(t) {
            return function (e) {
                return "input" === e.nodeName.toLowerCase() && e.type === t
            }
        }

        function l(t) {
            return function (e) {
                var i = e.nodeName.toLowerCase();
                return ("input" === i || "button" === i) && e.type === t
            }
        }

        function c(t) {
            return function (e) {
                return "form" in e ? e.parentNode && !1 === e.disabled ? "label" in e ? "label" in e.parentNode ? e.parentNode.disabled === t : e.disabled === t : e.isDisabled === t || e.isDisabled !== !t && Tt(e) === t : e.disabled === t : "label" in e && e.disabled === t
            }
        }

        function h(t) {
            return n(function (e) {
                return e = +e, n(function (i, n) {
                    for (var r, a = t([], i.length, e), o = a.length; o--;) i[r = a[o]] && (i[r] = !(n[r] = i[r]))
                })
            })
        }

        function u(t) {
            return t && void 0 !== t.getElementsByTagName && t
        }

        function p() {
        }

        function d(t) {
            for (var e = 0, i = t.length, n = ""; e < i; e++) n += t[e].value;
            return n
        }

        function f(t, e, i) {
            var n = e.dir, r = e.next, a = r || n, o = i && "parentNode" === a, s = j++;
            return e.first ? function (e, i, r) {
                for (; e = e[n];) if (1 === e.nodeType || o) return t(e, i, r);
                return !1
            } : function (e, i, l) {
                var c, h, u, p = [G, s];
                if (l) {
                    for (; e = e[n];) if ((1 === e.nodeType || o) && t(e, i, l)) return !0
                } else for (; e = e[n];) if (1 === e.nodeType || o) if (u = e[H] || (e[H] = {}), h = u[e.uniqueID] || (u[e.uniqueID] = {}), r && r === e.nodeName.toLowerCase()) e = e[n] || e; else {
                    if ((c = h[a]) && c[0] === G && c[1] === s) return p[2] = c[2];
                    if (h[a] = p, p[2] = t(e, i, l)) return !0
                }
                return !1
            }
        }

        function m(t) {
            return t.length > 1 ? function (e, i, n) {
                for (var r = t.length; r--;) if (!t[r](e, i, n)) return !1;
                return !0
            } : t[0]
        }

        function g(t, i, n) {
            for (var r = 0, a = i.length; r < a; r++) e(t, i[r], n);
            return n
        }

        function v(t, e, i, n, r) {
            for (var a, o = [], s = 0, l = t.length, c = null != e; s < l; s++) (a = t[s]) && (i && !i(a, n, r) || (o.push(a), c && e.push(s)));
            return o
        }

        function y(t, e, i, r, a, o) {
            return r && !r[H] && (r = y(r)), a && !a[H] && (a = y(a, o)), n(function (n, o, s, l) {
                var c, h, u, p = [], d = [], f = o.length, m = n || g(e || "*", s.nodeType ? [s] : s, []),
                    y = !t || !n && e ? m : v(m, p, t, s, l), x = i ? a || (n ? t : f || r) ? [] : o : y;
                if (i && i(y, x, s, l), r) for (c = v(x, d), r(c, [], s, l), h = c.length; h--;) (u = c[h]) && (x[d[h]] = !(y[d[h]] = u));
                if (n) {
                    if (a || t) {
                        if (a) {
                            for (c = [], h = x.length; h--;) (u = x[h]) && c.push(y[h] = u);
                            a(null, x = [], c, l)
                        }
                        for (h = x.length; h--;) (u = x[h]) && (c = a ? et(n, u) : p[h]) > -1 && (n[c] = !(o[c] = u))
                    }
                } else x = v(x === o ? x.splice(f, x.length) : x), a ? a(null, o, x, l) : K.apply(o, x)
            })
        }

        function x(t) {
            for (var e, i, n, r = t.length, a = M.relative[t[0].type], o = a || M.relative[" "], s = a ? 1 : 0, l = f(function (t) {
                return t === e
            }, o, !0), c = f(function (t) {
                return et(e, t) > -1
            }, o, !0), h = [function (t, i, n) {
                var r = !a && (n || i !== L) || ((e = i).nodeType ? l(t, i, n) : c(t, i, n));
                return e = null, r
            }]; s < r; s++) if (i = M.relative[t[s].type]) h = [f(m(h), i)]; else {
                if ((i = M.filter[t[s].type].apply(null, t[s].matches))[H]) {
                    for (n = ++s; n < r && !M.relative[t[n].type]; n++) ;
                    return y(s > 1 && m(h), s > 1 && d(t.slice(0, s - 1).concat({value: " " === t[s - 2].type ? "*" : ""})).replace(st, "$1"), i, s < n && x(t.slice(s, n)), n < r && x(t = t.slice(n)), n < r && d(t))
                }
                h.push(i)
            }
            return m(h)
        }

        function _(t, i) {
            var r = i.length > 0, a = t.length > 0, o = function (n, o, s, l, c) {
                var h, u, p, d = 0, f = "0", m = n && [], g = [], y = L, x = n || a && M.find.TAG("*", c),
                    _ = G += null == y ? 1 : Math.random() || .1, b = x.length;
                for (c && (L = o === D || o || c); f !== b && null != (h = x[f]); f++) {
                    if (a && h) {
                        for (u = 0, o || h.ownerDocument === D || (O(h), s = !N); p = t[u++];) if (p(h, o || D, s)) {
                            l.push(h);
                            break
                        }
                        c && (G = _)
                    }
                    r && ((h = !p && h) && d--, n && m.push(h))
                }
                if (d += f, r && f !== d) {
                    for (u = 0; p = i[u++];) p(m, g, o, s);
                    if (n) {
                        if (d > 0) for (; f--;) m[f] || g[f] || (g[f] = Z.call(l));
                        g = v(g)
                    }
                    K.apply(l, g), c && !n && g.length > 0 && d + i.length > 1 && e.uniqueSort(l)
                }
                return c && (G = _, L = y), m
            };
            return r ? n(o) : o
        }

        var b, w, M, T, S, E, A, P, L, C, R, O, D, I, N, z, k, B, F, H = "sizzle" + 1 * new Date, U = t.document, G = 0,
            j = 0, V = i(), W = i(), q = i(), X = function (t, e) {
                return t === e && (R = !0), 0
            }, Y = {}.hasOwnProperty, J = [], Z = J.pop, Q = J.push, K = J.push, tt = J.slice, et = function (t, e) {
                for (var i = 0, n = t.length; i < n; i++) if (t[i] === e) return i;
                return -1
            },
            it = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
            nt = "[\\x20\\t\\r\\n\\f]", rt = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",
            at = "\\[" + nt + "*(" + rt + ")(?:" + nt + "*([*^$|!~]?=)" + nt + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + rt + "))|)" + nt + "*\\]",
            ot = ":(" + rt + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + at + ")*)|.*)\\)|)",
            $ = new RegExp(nt + "+", "g"), st = new RegExp("^" + nt + "+|((?:^|[^\\\\])(?:\\\\.)*)" + nt + "+$", "g"),
            lt = new RegExp("^" + nt + "*," + nt + "*"), ct = new RegExp("^" + nt + "*([>+~]|" + nt + ")" + nt + "*"),
            ht = new RegExp("=" + nt + "*([^\\]'\"]*?)" + nt + "*\\]", "g"), ut = new RegExp(ot),
            pt = new RegExp("^" + rt + "$"), dt = {
                ID: new RegExp("^#(" + rt + ")"),
                CLASS: new RegExp("^\\.(" + rt + ")"),
                TAG: new RegExp("^(" + rt + "|[*])"),
                ATTR: new RegExp("^" + at),
                PSEUDO: new RegExp("^" + ot),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + nt + "*(even|odd|(([+-]|)(\\d*)n|)" + nt + "*(?:([+-]|)" + nt + "*(\\d+)|))" + nt + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + it + ")$", "i"),
                needsContext: new RegExp("^" + nt + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + nt + "*((?:-\\d)?\\d*)" + nt + "*\\)|)(?=[^-]|$)", "i")
            }, ft = /^(?:input|select|textarea|button)$/i, mt = /^h\d$/i, gt = /^[^{]+\{\s*\[native \w/,
            vt = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, yt = /[+~]/,
            xt = new RegExp("\\\\([\\da-f]{1,6}" + nt + "?|(" + nt + ")|.)", "ig"), _t = function (t, e, i) {
                var n = "0x" + e - 65536;
                return n !== n || i ? e : n < 0 ? String.fromCharCode(n + 65536) : String.fromCharCode(n >> 10 | 55296, 1023 & n | 56320)
            }, bt = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, wt = function (t, e) {
                return e ? "\0" === t ? "ï¿½" : t.slice(0, -1) + "\\" + t.charCodeAt(t.length - 1).toString(16) + " " : "\\" + t
            }, Mt = function () {
                O()
            }, Tt = f(function (t) {
                return !0 === t.disabled && ("form" in t || "label" in t)
            }, {dir: "parentNode", next: "legend"});
        try {
            K.apply(J = tt.call(U.childNodes), U.childNodes), J[U.childNodes.length].nodeType
        } catch (t) {
            K = {
                apply: J.length ? function (t, e) {
                    Q.apply(t, tt.call(e))
                } : function (t, e) {
                    for (var i = t.length, n = 0; t[i++] = e[n++];) ;
                    t.length = i - 1
                }
            }
        }
        w = e.support = {}, S = e.isXML = function (t) {
            var e = t && (t.ownerDocument || t).documentElement;
            return !!e && "HTML" !== e.nodeName
        }, O = e.setDocument = function (t) {
            var e, i, n = t ? t.ownerDocument || t : U;
            return n !== D && 9 === n.nodeType && n.documentElement ? (D = n, I = D.documentElement, N = !S(D), U !== D && (i = D.defaultView) && i.top !== i && (i.addEventListener ? i.addEventListener("unload", Mt, !1) : i.attachEvent && i.attachEvent("onunload", Mt)), w.attributes = r(function (t) {
                return t.className = "i", !t.getAttribute("className")
            }), w.getElementsByTagName = r(function (t) {
                return t.appendChild(D.createComment("")), !t.getElementsByTagName("*").length
            }), w.getElementsByClassName = gt.test(D.getElementsByClassName), w.getById = r(function (t) {
                return I.appendChild(t).id = H, !D.getElementsByName || !D.getElementsByName(H).length
            }), w.getById ? (M.filter.ID = function (t) {
                var e = t.replace(xt, _t);
                return function (t) {
                    return t.getAttribute("id") === e
                }
            }, M.find.ID = function (t, e) {
                if (void 0 !== e.getElementById && N) {
                    var i = e.getElementById(t);
                    return i ? [i] : []
                }
            }) : (M.filter.ID = function (t) {
                var e = t.replace(xt, _t);
                return function (t) {
                    var i = void 0 !== t.getAttributeNode && t.getAttributeNode("id");
                    return i && i.value === e
                }
            }, M.find.ID = function (t, e) {
                if (void 0 !== e.getElementById && N) {
                    var i, n, r, a = e.getElementById(t);
                    if (a) {
                        if ((i = a.getAttributeNode("id")) && i.value === t) return [a];
                        for (r = e.getElementsByName(t), n = 0; a = r[n++];) if ((i = a.getAttributeNode("id")) && i.value === t) return [a]
                    }
                    return []
                }
            }), M.find.TAG = w.getElementsByTagName ? function (t, e) {
                return void 0 !== e.getElementsByTagName ? e.getElementsByTagName(t) : w.qsa ? e.querySelectorAll(t) : void 0
            } : function (t, e) {
                var i, n = [], r = 0, a = e.getElementsByTagName(t);
                if ("*" === t) {
                    for (; i = a[r++];) 1 === i.nodeType && n.push(i);
                    return n
                }
                return a
            }, M.find.CLASS = w.getElementsByClassName && function (t, e) {
                if (void 0 !== e.getElementsByClassName && N) return e.getElementsByClassName(t)
            }, k = [], z = [], (w.qsa = gt.test(D.querySelectorAll)) && (r(function (t) {
                I.appendChild(t).innerHTML = "<a id='" + H + "'></a><select id='" + H + "-\r\\' msallowcapture=''><option selected=''></option></select>", t.querySelectorAll("[msallowcapture^='']").length && z.push("[*^$]=" + nt + "*(?:''|\"\")"), t.querySelectorAll("[selected]").length || z.push("\\[" + nt + "*(?:value|" + it + ")"), t.querySelectorAll("[id~=" + H + "-]").length || z.push("~="), t.querySelectorAll(":checked").length || z.push(":checked"), t.querySelectorAll("a#" + H + "+*").length || z.push(".#.+[+~]")
            }), r(function (t) {
                t.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                var e = D.createElement("input");
                e.setAttribute("type", "hidden"), t.appendChild(e).setAttribute("name", "D"), t.querySelectorAll("[name=d]").length && z.push("name" + nt + "*[*^$|!~]?="), 2 !== t.querySelectorAll(":enabled").length && z.push(":enabled", ":disabled"), I.appendChild(t).disabled = !0, 2 !== t.querySelectorAll(":disabled").length && z.push(":enabled", ":disabled"), t.querySelectorAll("*,:x"), z.push(",.*:")
            })), (w.matchesSelector = gt.test(B = I.matches || I.webkitMatchesSelector || I.mozMatchesSelector || I.oMatchesSelector || I.msMatchesSelector)) && r(function (t) {
                w.disconnectedMatch = B.call(t, "*"), B.call(t, "[s!='']:x"), k.push("!=", ot)
            }), z = z.length && new RegExp(z.join("|")), k = k.length && new RegExp(k.join("|")), e = gt.test(I.compareDocumentPosition), F = e || gt.test(I.contains) ? function (t, e) {
                var i = 9 === t.nodeType ? t.documentElement : t, n = e && e.parentNode;
                return t === n || !(!n || 1 !== n.nodeType || !(i.contains ? i.contains(n) : t.compareDocumentPosition && 16 & t.compareDocumentPosition(n)))
            } : function (t, e) {
                if (e) for (; e = e.parentNode;) if (e === t) return !0;
                return !1
            }, X = e ? function (t, e) {
                if (t === e) return R = !0, 0;
                var i = !t.compareDocumentPosition - !e.compareDocumentPosition;
                return i || (1 & (i = (t.ownerDocument || t) === (e.ownerDocument || e) ? t.compareDocumentPosition(e) : 1) || !w.sortDetached && e.compareDocumentPosition(t) === i ? t === D || t.ownerDocument === U && F(U, t) ? -1 : e === D || e.ownerDocument === U && F(U, e) ? 1 : C ? et(C, t) - et(C, e) : 0 : 4 & i ? -1 : 1)
            } : function (t, e) {
                if (t === e) return R = !0, 0;
                var i, n = 0, r = t.parentNode, a = e.parentNode, s = [t], l = [e];
                if (!r || !a) return t === D ? -1 : e === D ? 1 : r ? -1 : a ? 1 : C ? et(C, t) - et(C, e) : 0;
                if (r === a) return o(t, e);
                for (i = t; i = i.parentNode;) s.unshift(i);
                for (i = e; i = i.parentNode;) l.unshift(i);
                for (; s[n] === l[n];) n++;
                return n ? o(s[n], l[n]) : s[n] === U ? -1 : l[n] === U ? 1 : 0
            }, D) : D
        }, e.matches = function (t, i) {
            return e(t, null, null, i)
        }, e.matchesSelector = function (t, i) {
            if ((t.ownerDocument || t) !== D && O(t), i = i.replace(ht, "='$1']"), w.matchesSelector && N && !q[i + " "] && (!k || !k.test(i)) && (!z || !z.test(i))) try {
                var n = B.call(t, i);
                if (n || w.disconnectedMatch || t.document && 11 !== t.document.nodeType) return n
            } catch (t) {
            }
            return e(i, D, null, [t]).length > 0
        }, e.contains = function (t, e) {
            return (t.ownerDocument || t) !== D && O(t), F(t, e)
        }, e.attr = function (t, e) {
            (t.ownerDocument || t) !== D && O(t);
            var i = M.attrHandle[e.toLowerCase()],
                n = i && Y.call(M.attrHandle, e.toLowerCase()) ? i(t, e, !N) : void 0;
            return void 0 !== n ? n : w.attributes || !N ? t.getAttribute(e) : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
        }, e.escape = function (t) {
            return (t + "").replace(bt, wt)
        }, e.error = function (t) {
            throw new Error("Syntax error, unrecognized expression: " + t)
        }, e.uniqueSort = function (t) {
            var e, i = [], n = 0, r = 0;
            if (R = !w.detectDuplicates, C = !w.sortStable && t.slice(0), t.sort(X), R) {
                for (; e = t[r++];) e === t[r] && (n = i.push(r));
                for (; n--;) t.splice(i[n], 1)
            }
            return C = null, t
        }, T = e.getText = function (t) {
            var e, i = "", n = 0, r = t.nodeType;
            if (r) {
                if (1 === r || 9 === r || 11 === r) {
                    if ("string" == typeof t.textContent) return t.textContent;
                    for (t = t.firstChild; t; t = t.nextSibling) i += T(t)
                } else if (3 === r || 4 === r) return t.nodeValue
            } else for (; e = t[n++];) i += T(e);
            return i
        }, (M = e.selectors = {
            cacheLength: 50,
            createPseudo: n,
            match: dt,
            attrHandle: {},
            find: {},
            relative: {
                ">": {dir: "parentNode", first: !0},
                " ": {dir: "parentNode"},
                "+": {dir: "previousSibling", first: !0},
                "~": {dir: "previousSibling"}
            },
            preFilter: {
                ATTR: function (t) {
                    return t[1] = t[1].replace(xt, _t), t[3] = (t[3] || t[4] || t[5] || "").replace(xt, _t), "~=" === t[2] && (t[3] = " " + t[3] + " "), t.slice(0, 4)
                }, CHILD: function (t) {
                    return t[1] = t[1].toLowerCase(), "nth" === t[1].slice(0, 3) ? (t[3] || e.error(t[0]), t[4] = +(t[4] ? t[5] + (t[6] || 1) : 2 * ("even" === t[3] || "odd" === t[3])), t[5] = +(t[7] + t[8] || "odd" === t[3])) : t[3] && e.error(t[0]), t
                }, PSEUDO: function (t) {
                    var e, i = !t[6] && t[2];
                    return dt.CHILD.test(t[0]) ? null : (t[3] ? t[2] = t[4] || t[5] || "" : i && ut.test(i) && (e = E(i, !0)) && (e = i.indexOf(")", i.length - e) - i.length) && (t[0] = t[0].slice(0, e), t[2] = i.slice(0, e)), t.slice(0, 3))
                }
            },
            filter: {
                TAG: function (t) {
                    var e = t.replace(xt, _t).toLowerCase();
                    return "*" === t ? function () {
                        return !0
                    } : function (t) {
                        return t.nodeName && t.nodeName.toLowerCase() === e
                    }
                }, CLASS: function (t) {
                    var e = V[t + " "];
                    return e || (e = new RegExp("(^|" + nt + ")" + t + "(" + nt + "|$)")) && V(t, function (t) {
                        return e.test("string" == typeof t.className && t.className || void 0 !== t.getAttribute && t.getAttribute("class") || "")
                    })
                }, ATTR: function (t, i, n) {
                    return function (r) {
                        var a = e.attr(r, t);
                        return null == a ? "!=" === i : !i || (a += "", "=" === i ? a === n : "!=" === i ? a !== n : "^=" === i ? n && 0 === a.indexOf(n) : "*=" === i ? n && a.indexOf(n) > -1 : "$=" === i ? n && a.slice(-n.length) === n : "~=" === i ? (" " + a.replace($, " ") + " ").indexOf(n) > -1 : "|=" === i && (a === n || a.slice(0, n.length + 1) === n + "-"))
                    }
                }, CHILD: function (t, e, i, n, r) {
                    var a = "nth" !== t.slice(0, 3), o = "last" !== t.slice(-4), s = "of-type" === e;
                    return 1 === n && 0 === r ? function (t) {
                        return !!t.parentNode
                    } : function (e, i, l) {
                        var c, h, u, p, d, f, m = a !== o ? "nextSibling" : "previousSibling", g = e.parentNode,
                            v = s && e.nodeName.toLowerCase(), y = !l && !s, x = !1;
                        if (g) {
                            if (a) {
                                for (; m;) {
                                    for (p = e; p = p[m];) if (s ? p.nodeName.toLowerCase() === v : 1 === p.nodeType) return !1;
                                    f = m = "only" === t && !f && "nextSibling"
                                }
                                return !0
                            }
                            if (f = [o ? g.firstChild : g.lastChild], o && y) {
                                for (x = (d = (c = (h = (u = (p = g)[H] || (p[H] = {}))[p.uniqueID] || (u[p.uniqueID] = {}))[t] || [])[0] === G && c[1]) && c[2], p = d && g.childNodes[d]; p = ++d && p && p[m] || (x = d = 0) || f.pop();) if (1 === p.nodeType && ++x && p === e) {
                                    h[t] = [G, d, x];
                                    break
                                }
                            } else if (y && (x = d = (c = (h = (u = (p = e)[H] || (p[H] = {}))[p.uniqueID] || (u[p.uniqueID] = {}))[t] || [])[0] === G && c[1]), !1 === x) for (; (p = ++d && p && p[m] || (x = d = 0) || f.pop()) && ((s ? p.nodeName.toLowerCase() !== v : 1 !== p.nodeType) || !++x || (y && ((h = (u = p[H] || (p[H] = {}))[p.uniqueID] || (u[p.uniqueID] = {}))[t] = [G, x]), p !== e));) ;
                            return (x -= r) === n || x % n == 0 && x / n >= 0
                        }
                    }
                }, PSEUDO: function (t, i) {
                    var r, a = M.pseudos[t] || M.setFilters[t.toLowerCase()] || e.error("unsupported pseudo: " + t);
                    return a[H] ? a(i) : a.length > 1 ? (r = [t, t, "", i], M.setFilters.hasOwnProperty(t.toLowerCase()) ? n(function (t, e) {
                        for (var n, r = a(t, i), o = r.length; o--;) t[n = et(t, r[o])] = !(e[n] = r[o])
                    }) : function (t) {
                        return a(t, 0, r)
                    }) : a
                }
            },
            pseudos: {
                not: n(function (t) {
                    var e = [], i = [], r = A(t.replace(st, "$1"));
                    return r[H] ? n(function (t, e, i, n) {
                        for (var a, o = r(t, null, n, []), s = t.length; s--;) (a = o[s]) && (t[s] = !(e[s] = a))
                    }) : function (t, n, a) {
                        return e[0] = t, r(e, null, a, i), e[0] = null, !i.pop()
                    }
                }), has: n(function (t) {
                    return function (i) {
                        return e(t, i).length > 0
                    }
                }), contains: n(function (t) {
                    return t = t.replace(xt, _t), function (e) {
                        return (e.textContent || e.innerText || T(e)).indexOf(t) > -1
                    }
                }), lang: n(function (t) {
                    return pt.test(t || "") || e.error("unsupported lang: " + t), t = t.replace(xt, _t).toLowerCase(), function (e) {
                        var i;
                        do {
                            if (i = N ? e.lang : e.getAttribute("xml:lang") || e.getAttribute("lang")) return (i = i.toLowerCase()) === t || 0 === i.indexOf(t + "-")
                        } while ((e = e.parentNode) && 1 === e.nodeType);
                        return !1
                    }
                }), target: function (e) {
                    var i = t.location && t.location.hash;
                    return i && i.slice(1) === e.id
                }, root: function (t) {
                    return t === I
                }, focus: function (t) {
                    return t === D.activeElement && (!D.hasFocus || D.hasFocus()) && !!(t.type || t.href || ~t.tabIndex)
                }, enabled: c(!1), disabled: c(!0), checked: function (t) {
                    var e = t.nodeName.toLowerCase();
                    return "input" === e && !!t.checked || "option" === e && !!t.selected
                }, selected: function (t) {
                    return t.parentNode && t.parentNode.selectedIndex, !0 === t.selected
                }, empty: function (t) {
                    for (t = t.firstChild; t; t = t.nextSibling) if (t.nodeType < 6) return !1;
                    return !0
                }, parent: function (t) {
                    return !M.pseudos.empty(t)
                }, header: function (t) {
                    return mt.test(t.nodeName)
                }, input: function (t) {
                    return ft.test(t.nodeName)
                }, button: function (t) {
                    var e = t.nodeName.toLowerCase();
                    return "input" === e && "button" === t.type || "button" === e
                }, text: function (t) {
                    var e;
                    return "input" === t.nodeName.toLowerCase() && "text" === t.type && (null == (e = t.getAttribute("type")) || "text" === e.toLowerCase())
                }, first: h(function () {
                    return [0]
                }), last: h(function (t, e) {
                    return [e - 1]
                }), eq: h(function (t, e, i) {
                    return [i < 0 ? i + e : i]
                }), even: h(function (t, e) {
                    for (var i = 0; i < e; i += 2) t.push(i);
                    return t
                }), odd: h(function (t, e) {
                    for (var i = 1; i < e; i += 2) t.push(i);
                    return t
                }), lt: h(function (t, e, i) {
                    for (var n = i < 0 ? i + e : i; --n >= 0;) t.push(n);
                    return t
                }), gt: h(function (t, e, i) {
                    for (var n = i < 0 ? i + e : i; ++n < e;) t.push(n);
                    return t
                })
            }
        }).pseudos.nth = M.pseudos.eq;
        for (b in {radio: !0, checkbox: !0, file: !0, password: !0, image: !0}) M.pseudos[b] = s(b);
        for (b in {submit: !0, reset: !0}) M.pseudos[b] = l(b);
        return p.prototype = M.filters = M.pseudos, M.setFilters = new p, E = e.tokenize = function (t, i) {
            var n, r, a, o, s, l, c, h = W[t + " "];
            if (h) return i ? 0 : h.slice(0);
            for (s = t, l = [], c = M.preFilter; s;) {
                n && !(r = lt.exec(s)) || (r && (s = s.slice(r[0].length) || s), l.push(a = [])), n = !1, (r = ct.exec(s)) && (n = r.shift(), a.push({
                    value: n,
                    type: r[0].replace(st, " ")
                }), s = s.slice(n.length));
                for (o in M.filter) !(r = dt[o].exec(s)) || c[o] && !(r = c[o](r)) || (n = r.shift(), a.push({
                    value: n,
                    type: o,
                    matches: r
                }), s = s.slice(n.length));
                if (!n) break
            }
            return i ? s.length : s ? e.error(t) : W(t, l).slice(0)
        }, A = e.compile = function (t, e) {
            var i, n = [], r = [], a = q[t + " "];
            if (!a) {
                for (e || (e = E(t)), i = e.length; i--;) (a = x(e[i]))[H] ? n.push(a) : r.push(a);
                (a = q(t, _(r, n))).selector = t
            }
            return a
        }, P = e.select = function (t, e, i, n) {
            var r, a, o, s, l, c = "function" == typeof t && t, h = !n && E(t = c.selector || t);
            if (i = i || [], 1 === h.length) {
                if ((a = h[0] = h[0].slice(0)).length > 2 && "ID" === (o = a[0]).type && 9 === e.nodeType && N && M.relative[a[1].type]) {
                    if (!(e = (M.find.ID(o.matches[0].replace(xt, _t), e) || [])[0])) return i;
                    c && (e = e.parentNode), t = t.slice(a.shift().value.length)
                }
                for (r = dt.needsContext.test(t) ? 0 : a.length; r-- && (o = a[r], !M.relative[s = o.type]);) if ((l = M.find[s]) && (n = l(o.matches[0].replace(xt, _t), yt.test(a[0].type) && u(e.parentNode) || e))) {
                    if (a.splice(r, 1), !(t = n.length && d(a))) return K.apply(i, n), i;
                    break
                }
            }
            return (c || A(t, h))(n, e, !N, i, !e || yt.test(t) && u(e.parentNode) || e), i
        }, w.sortStable = H.split("").sort(X).join("") === H, w.detectDuplicates = !!R, O(), w.sortDetached = r(function (t) {
            return 1 & t.compareDocumentPosition(D.createElement("fieldset"))
        }), r(function (t) {
            return t.innerHTML = "<a href='#'></a>", "#" === t.firstChild.getAttribute("href")
        }) || a("type|href|height|width", function (t, e, i) {
            if (!i) return t.getAttribute(e, "type" === e.toLowerCase() ? 1 : 2)
        }), w.attributes && r(function (t) {
            return t.innerHTML = "<input/>", t.firstChild.setAttribute("value", ""), "" === t.firstChild.getAttribute("value")
        }) || a("value", function (t, e, i) {
            if (!i && "input" === t.nodeName.toLowerCase()) return t.defaultValue
        }), r(function (t) {
            return null == t.getAttribute("disabled")
        }) || a(it, function (t, e, i) {
            var n;
            if (!i) return !0 === t[e] ? e.toLowerCase() : (n = t.getAttributeNode(e)) && n.specified ? n.value : null
        }), e
    }(t);
    wt.find = Tt, wt.expr = Tt.selectors, wt.expr[":"] = wt.expr.pseudos, wt.uniqueSort = wt.unique = Tt.uniqueSort, wt.text = Tt.getText, wt.isXMLDoc = Tt.isXML, wt.contains = Tt.contains, wt.escapeSelector = Tt.escape;
    var St = function (t, e, i) {
        for (var n = [], r = void 0 !== i; (t = t[e]) && 9 !== t.nodeType;) if (1 === t.nodeType) {
            if (r && wt(t).is(i)) break;
            n.push(t)
        }
        return n
    }, Et = function (t, e) {
        for (var i = []; t; t = t.nextSibling) 1 === t.nodeType && t !== e && i.push(t);
        return i
    }, At = wt.expr.match.needsContext, Pt = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
    wt.filter = function (t, e, i) {
        var n = e[0];
        return i && (t = ":not(" + t + ")"), 1 === e.length && 1 === n.nodeType ? wt.find.matchesSelector(n, t) ? [n] : [] : wt.find.matches(t, wt.grep(e, function (t) {
            return 1 === t.nodeType
        }))
    }, wt.fn.extend({
        find: function (t) {
            var e, i, n = this.length, r = this;
            if ("string" != typeof t) return this.pushStack(wt(t).filter(function () {
                for (e = 0; e < n; e++) if (wt.contains(r[e], this)) return !0
            }));
            for (i = this.pushStack([]), e = 0; e < n; e++) wt.find(t, r[e], i);
            return n > 1 ? wt.uniqueSort(i) : i
        }, filter: function (t) {
            return this.pushStack(o(this, t || [], !1))
        }, not: function (t) {
            return this.pushStack(o(this, t || [], !0))
        }, is: function (t) {
            return !!o(this, "string" == typeof t && At.test(t) ? wt(t) : t || [], !1).length
        }
    });
    var Lt, Ct = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
    (wt.fn.init = function (t, e, i) {
        var n, r;
        if (!t) return this;
        if (i = i || Lt, "string" == typeof t) {
            if (!(n = "<" === t[0] && ">" === t[t.length - 1] && t.length >= 3 ? [null, t, null] : Ct.exec(t)) || !n[1] && e) return !e || e.jquery ? (e || i).find(t) : this.constructor(e).find(t);
            if (n[1]) {
                if (e = e instanceof wt ? e[0] : e, wt.merge(this, wt.parseHTML(n[1], e && e.nodeType ? e.ownerDocument || e : ot, !0)), Pt.test(n[1]) && wt.isPlainObject(e)) for (n in e) yt(this[n]) ? this[n](e[n]) : this.attr(n, e[n]);
                return this
            }
            return (r = ot.getElementById(n[2])) && (this[0] = r, this.length = 1), this
        }
        return t.nodeType ? (this[0] = t, this.length = 1, this) : yt(t) ? void 0 !== i.ready ? i.ready(t) : t(wt) : wt.makeArray(t, this)
    }).prototype = wt.fn, Lt = wt(ot);
    var Rt = /^(?:parents|prev(?:Until|All))/, Ot = {children: !0, contents: !0, next: !0, prev: !0};
    wt.fn.extend({
        has: function (t) {
            var e = wt(t, this), i = e.length;
            return this.filter(function () {
                for (var t = 0; t < i; t++) if (wt.contains(this, e[t])) return !0
            })
        }, closest: function (t, e) {
            var i, n = 0, r = this.length, a = [], o = "string" != typeof t && wt(t);
            if (!At.test(t)) for (; n < r; n++) for (i = this[n]; i && i !== e; i = i.parentNode) if (i.nodeType < 11 && (o ? o.index(i) > -1 : 1 === i.nodeType && wt.find.matchesSelector(i, t))) {
                a.push(i);
                break
            }
            return this.pushStack(a.length > 1 ? wt.uniqueSort(a) : a)
        }, index: function (t) {
            return t ? "string" == typeof t ? ut.call(wt(t), this[0]) : ut.call(this, t.jquery ? t[0] : t) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
        }, add: function (t, e) {
            return this.pushStack(wt.uniqueSort(wt.merge(this.get(), wt(t, e))))
        }, addBack: function (t) {
            return this.add(null == t ? this.prevObject : this.prevObject.filter(t))
        }
    }), wt.each({
        parent: function (t) {
            var e = t.parentNode;
            return e && 11 !== e.nodeType ? e : null
        }, parents: function (t) {
            return St(t, "parentNode")
        }, parentsUntil: function (t, e, i) {
            return St(t, "parentNode", i)
        }, next: function (t) {
            return s(t, "nextSibling")
        }, prev: function (t) {
            return s(t, "previousSibling")
        }, nextAll: function (t) {
            return St(t, "nextSibling")
        }, prevAll: function (t) {
            return St(t, "previousSibling")
        }, nextUntil: function (t, e, i) {
            return St(t, "nextSibling", i)
        }, prevUntil: function (t, e, i) {
            return St(t, "previousSibling", i)
        }, siblings: function (t) {
            return Et((t.parentNode || {}).firstChild, t)
        }, children: function (t) {
            return Et(t.firstChild)
        }, contents: function (t) {
            return a(t, "iframe") ? t.contentDocument : (a(t, "template") && (t = t.content || t), wt.merge([], t.childNodes))
        }
    }, function (t, e) {
        wt.fn[t] = function (i, n) {
            var r = wt.map(this, e, i);
            return "Until" !== t.slice(-5) && (n = i), n && "string" == typeof n && (r = wt.filter(n, r)), this.length > 1 && (Ot[t] || wt.uniqueSort(r), Rt.test(t) && r.reverse()), this.pushStack(r)
        }
    });
    var Dt = /[^\x20\t\r\n\f]+/g;
    wt.Callbacks = function (t) {
        t = "string" == typeof t ? l(t) : wt.extend({}, t);
        var e, i, r, a, o = [], s = [], c = -1, h = function () {
            for (a = a || t.once, r = e = !0; s.length; c = -1) for (i = s.shift(); ++c < o.length;) !1 === o[c].apply(i[0], i[1]) && t.stopOnFalse && (c = o.length, i = !1);
            t.memory || (i = !1), e = !1, a && (o = i ? [] : "")
        }, u = {
            add: function () {
                return o && (i && !e && (c = o.length - 1, s.push(i)), function e(i) {
                    wt.each(i, function (i, r) {
                        yt(r) ? t.unique && u.has(r) || o.push(r) : r && r.length && "string" !== n(r) && e(r)
                    })
                }(arguments), i && !e && h()), this
            }, remove: function () {
                return wt.each(arguments, function (t, e) {
                    for (var i; (i = wt.inArray(e, o, i)) > -1;) o.splice(i, 1), i <= c && c--
                }), this
            }, has: function (t) {
                return t ? wt.inArray(t, o) > -1 : o.length > 0
            }, empty: function () {
                return o && (o = []), this
            }, disable: function () {
                return a = s = [], o = i = "", this
            }, disabled: function () {
                return !o
            }, lock: function () {
                return a = s = [], i || e || (o = i = ""), this
            }, locked: function () {
                return !!a
            }, fireWith: function (t, i) {
                return a || (i = [t, (i = i || []).slice ? i.slice() : i], s.push(i), e || h()), this
            }, fire: function () {
                return u.fireWith(this, arguments), this
            }, fired: function () {
                return !!r
            }
        };
        return u
    }, wt.extend({
        Deferred: function (e) {
            var i = [["notify", "progress", wt.Callbacks("memory"), wt.Callbacks("memory"), 2], ["resolve", "done", wt.Callbacks("once memory"), wt.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", wt.Callbacks("once memory"), wt.Callbacks("once memory"), 1, "rejected"]],
                n = "pending", r = {
                    state: function () {
                        return n
                    }, always: function () {
                        return a.done(arguments).fail(arguments), this
                    }, catch: function (t) {
                        return r.then(null, t)
                    }, pipe: function () {
                        var t = arguments;
                        return wt.Deferred(function (e) {
                            wt.each(i, function (i, n) {
                                var r = yt(t[n[4]]) && t[n[4]];
                                a[n[1]](function () {
                                    var t = r && r.apply(this, arguments);
                                    t && yt(t.promise) ? t.promise().progress(e.notify).done(e.resolve).fail(e.reject) : e[n[0] + "With"](this, r ? [t] : arguments)
                                })
                            }), t = null
                        }).promise()
                    }, then: function (e, n, r) {
                        function a(e, i, n, r) {
                            return function () {
                                var s = this, l = arguments, u = function () {
                                    var t, u;
                                    if (!(e < o)) {
                                        if ((t = n.apply(s, l)) === i.promise()) throw new TypeError("Thenable self-resolution");
                                        u = t && ("object" == typeof t || "function" == typeof t) && t.then, yt(u) ? r ? u.call(t, a(o, i, c, r), a(o, i, h, r)) : (o++, u.call(t, a(o, i, c, r), a(o, i, h, r), a(o, i, c, i.notifyWith))) : (n !== c && (s = void 0, l = [t]), (r || i.resolveWith)(s, l))
                                    }
                                }, p = r ? u : function () {
                                    try {
                                        u()
                                    } catch (t) {
                                        wt.Deferred.exceptionHook && wt.Deferred.exceptionHook(t, p.stackTrace), e + 1 >= o && (n !== h && (s = void 0, l = [t]), i.rejectWith(s, l))
                                    }
                                };
                                e ? p() : (wt.Deferred.getStackHook && (p.stackTrace = wt.Deferred.getStackHook()), t.setTimeout(p))
                            }
                        }

                        var o = 0;
                        return wt.Deferred(function (t) {
                            i[0][3].add(a(0, t, yt(r) ? r : c, t.notifyWith)), i[1][3].add(a(0, t, yt(e) ? e : c)), i[2][3].add(a(0, t, yt(n) ? n : h))
                        }).promise()
                    }, promise: function (t) {
                        return null != t ? wt.extend(t, r) : r
                    }
                }, a = {};
            return wt.each(i, function (t, e) {
                var o = e[2], s = e[5];
                r[e[1]] = o.add, s && o.add(function () {
                    n = s
                }, i[3 - t][2].disable, i[3 - t][3].disable, i[0][2].lock, i[0][3].lock), o.add(e[3].fire), a[e[0]] = function () {
                    return a[e[0] + "With"](this === a ? void 0 : this, arguments), this
                }, a[e[0] + "With"] = o.fireWith
            }), r.promise(a), e && e.call(a, a), a
        }, when: function (t) {
            var e = arguments.length, i = e, n = Array(i), r = lt.call(arguments), a = wt.Deferred(), o = function (t) {
                return function (i) {
                    n[t] = this, r[t] = arguments.length > 1 ? lt.call(arguments) : i, --e || a.resolveWith(n, r)
                }
            };
            if (e <= 1 && ($(t, a.done(o(i)).resolve, a.reject, !e), "pending" === a.state() || yt(r[i] && r[i].then))) return a.then();
            for (; i--;) $(r[i], o(i), a.reject);
            return a.promise()
        }
    });
    var It = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
    wt.Deferred.exceptionHook = function (e, i) {
        t.console && t.console.warn && e && It.test(e.name) && t.console.warn("jQuery.Deferred exception: " + e.message, e.stack, i)
    }, wt.readyException = function (e) {
        t.setTimeout(function () {
            throw e
        })
    };
    var Nt = wt.Deferred();
    wt.fn.ready = function (t) {
        return Nt.then(t).catch(function (t) {
            wt.readyException(t)
        }), this
    }, wt.extend({
        isReady: !1, readyWait: 1, ready: function (t) {
            (!0 === t ? --wt.readyWait : wt.isReady) || (wt.isReady = !0, !0 !== t && --wt.readyWait > 0 || Nt.resolveWith(ot, [wt]))
        }
    }), wt.ready.then = Nt.then, "complete" === ot.readyState || "loading" !== ot.readyState && !ot.documentElement.doScroll ? t.setTimeout(wt.ready) : (ot.addEventListener("DOMContentLoaded", u), t.addEventListener("load", u));
    var zt = function (t, e, i, r, a, o, s) {
        var l = 0, c = t.length, h = null == i;
        if ("object" === n(i)) {
            a = !0;
            for (l in i) zt(t, e, l, i[l], !0, o, s)
        } else if (void 0 !== r && (a = !0, yt(r) || (s = !0), h && (s ? (e.call(t, r), e = null) : (h = e, e = function (t, e, i) {
            return h.call(wt(t), i)
        })), e)) for (; l < c; l++) e(t[l], i, s ? r : r.call(t[l], l, e(t[l], i)));
        return a ? t : h ? e.call(t) : c ? e(t[0], i) : o
    }, kt = /^-ms-/, Bt = /-([a-z])/g, Ft = function (t) {
        return 1 === t.nodeType || 9 === t.nodeType || !+t.nodeType
    };
    f.uid = 1, f.prototype = {
        cache: function (t) {
            var e = t[this.expando];
            return e || (e = {}, Ft(t) && (t.nodeType ? t[this.expando] = e : Object.defineProperty(t, this.expando, {
                value: e,
                configurable: !0
            }))), e
        }, set: function (t, e, i) {
            var n, r = this.cache(t);
            if ("string" == typeof e) r[d(e)] = i; else for (n in e) r[d(n)] = e[n];
            return r
        }, get: function (t, e) {
            return void 0 === e ? this.cache(t) : t[this.expando] && t[this.expando][d(e)]
        }, access: function (t, e, i) {
            return void 0 === e || e && "string" == typeof e && void 0 === i ? this.get(t, e) : (this.set(t, e, i), void 0 !== i ? i : e)
        }, remove: function (t, e) {
            var i, n = t[this.expando];
            if (void 0 !== n) {
                if (void 0 !== e) {
                    i = (e = Array.isArray(e) ? e.map(d) : (e = d(e)) in n ? [e] : e.match(Dt) || []).length;
                    for (; i--;) delete n[e[i]]
                }
                (void 0 === e || wt.isEmptyObject(n)) && (t.nodeType ? t[this.expando] = void 0 : delete t[this.expando])
            }
        }, hasData: function (t) {
            var e = t[this.expando];
            return void 0 !== e && !wt.isEmptyObject(e)
        }
    };
    var Ht = new f, Ut = new f, Gt = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, jt = /[A-Z]/g;
    wt.extend({
        hasData: function (t) {
            return Ut.hasData(t) || Ht.hasData(t)
        }, data: function (t, e, i) {
            return Ut.access(t, e, i)
        }, removeData: function (t, e) {
            Ut.remove(t, e)
        }, _data: function (t, e, i) {
            return Ht.access(t, e, i)
        }, _removeData: function (t, e) {
            Ht.remove(t, e)
        }
    }), wt.fn.extend({
        data: function (t, e) {
            var i, n, r, a = this[0], o = a && a.attributes;
            if (void 0 === t) {
                if (this.length && (r = Ut.get(a), 1 === a.nodeType && !Ht.get(a, "hasDataAttrs"))) {
                    for (i = o.length; i--;) o[i] && 0 === (n = o[i].name).indexOf("data-") && (n = d(n.slice(5)), g(a, n, r[n]));
                    Ht.set(a, "hasDataAttrs", !0)
                }
                return r
            }
            return "object" == typeof t ? this.each(function () {
                Ut.set(this, t)
            }) : zt(this, function (e) {
                var i;
                if (a && void 0 === e) {
                    if (void 0 !== (i = Ut.get(a, t))) return i;
                    if (void 0 !== (i = g(a, t))) return i
                } else this.each(function () {
                    Ut.set(this, t, e)
                })
            }, null, e, arguments.length > 1, null, !0)
        }, removeData: function (t) {
            return this.each(function () {
                Ut.remove(this, t)
            })
        }
    }), wt.extend({
        queue: function (t, e, i) {
            var n;
            if (t) return e = (e || "fx") + "queue", n = Ht.get(t, e), i && (!n || Array.isArray(i) ? n = Ht.access(t, e, wt.makeArray(i)) : n.push(i)), n || []
        }, dequeue: function (t, e) {
            e = e || "fx";
            var i = wt.queue(t, e), n = i.length, r = i.shift(), a = wt._queueHooks(t, e), o = function () {
                wt.dequeue(t, e)
            };
            "inprogress" === r && (r = i.shift(), n--), r && ("fx" === e && i.unshift("inprogress"), delete a.stop, r.call(t, o, a)), !n && a && a.empty.fire()
        }, _queueHooks: function (t, e) {
            var i = e + "queueHooks";
            return Ht.get(t, i) || Ht.access(t, i, {
                empty: wt.Callbacks("once memory").add(function () {
                    Ht.remove(t, [e + "queue", i])
                })
            })
        }
    }), wt.fn.extend({
        queue: function (t, e) {
            var i = 2;
            return "string" != typeof t && (e = t, t = "fx", i--), arguments.length < i ? wt.queue(this[0], t) : void 0 === e ? this : this.each(function () {
                var i = wt.queue(this, t, e);
                wt._queueHooks(this, t), "fx" === t && "inprogress" !== i[0] && wt.dequeue(this, t)
            })
        }, dequeue: function (t) {
            return this.each(function () {
                wt.dequeue(this, t)
            })
        }, clearQueue: function (t) {
            return this.queue(t || "fx", [])
        }, promise: function (t, e) {
            var i, n = 1, r = wt.Deferred(), a = this, o = this.length, s = function () {
                --n || r.resolveWith(a, [a])
            };
            for ("string" != typeof t && (e = t, t = void 0), t = t || "fx"; o--;) (i = Ht.get(a[o], t + "queueHooks")) && i.empty && (n++, i.empty.add(s));
            return s(), r.promise(e)
        }
    });
    var Vt = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, Wt = new RegExp("^(?:([+-])=|)(" + Vt + ")([a-z%]*)$", "i"),
        qt = ["Top", "Right", "Bottom", "Left"], Xt = function (t, e) {
            return "none" === (t = e || t).style.display || "" === t.style.display && wt.contains(t.ownerDocument, t) && "none" === wt.css(t, "display")
        }, Yt = function (t, e, i, n) {
            var r, a, o = {};
            for (a in e) o[a] = t.style[a], t.style[a] = e[a];
            r = i.apply(t, n || []);
            for (a in e) t.style[a] = o[a];
            return r
        }, Jt = {};
    wt.fn.extend({
        show: function () {
            return x(this, !0)
        }, hide: function () {
            return x(this)
        }, toggle: function (t) {
            return "boolean" == typeof t ? t ? this.show() : this.hide() : this.each(function () {
                Xt(this) ? wt(this).show() : wt(this).hide()
            })
        }
    });
    var Zt = /^(?:checkbox|radio)$/i, $t = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, Qt = /^$|^module$|\/(?:java|ecma)script/i,
        Kt = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
    Kt.optgroup = Kt.option, Kt.tbody = Kt.tfoot = Kt.colgroup = Kt.caption = Kt.thead, Kt.th = Kt.td;
    var te = /<|&#?\w+;/;
    !function () {
        var t = ot.createDocumentFragment().appendChild(ot.createElement("div")), e = ot.createElement("input");
        e.setAttribute("type", "radio"), e.setAttribute("checked", "checked"), e.setAttribute("name", "t"), t.appendChild(e), vt.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked, t.innerHTML = "<textarea>x</textarea>", vt.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue
    }();
    var ee = ot.documentElement, ie = /^key/, ne = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
        re = /^([^.]*)(?:\.(.+)|)/;
    wt.event = {
        global: {}, add: function (t, e, i, n, r) {
            var a, o, s, l, c, h, u, p, d, f, m, g = Ht.get(t);
            if (g) for (i.handler && (i = (a = i).handler, r = a.selector), r && wt.find.matchesSelector(ee, r), i.guid || (i.guid = wt.guid++), (l = g.events) || (l = g.events = {}), (o = g.handle) || (o = g.handle = function (e) {
                return void 0 !== wt && wt.event.triggered !== e.type ? wt.event.dispatch.apply(t, arguments) : void 0
            }), c = (e = (e || "").match(Dt) || [""]).length; c--;) d = m = (s = re.exec(e[c]) || [])[1], f = (s[2] || "").split(".").sort(), d && (u = wt.event.special[d] || {}, d = (r ? u.delegateType : u.bindType) || d, u = wt.event.special[d] || {}, h = wt.extend({
                type: d,
                origType: m,
                data: n,
                handler: i,
                guid: i.guid,
                selector: r,
                needsContext: r && wt.expr.match.needsContext.test(r),
                namespace: f.join(".")
            }, a), (p = l[d]) || ((p = l[d] = []).delegateCount = 0, u.setup && !1 !== u.setup.call(t, n, f, o) || t.addEventListener && t.addEventListener(d, o)), u.add && (u.add.call(t, h), h.handler.guid || (h.handler.guid = i.guid)), r ? p.splice(p.delegateCount++, 0, h) : p.push(h), wt.event.global[d] = !0)
        }, remove: function (t, e, i, n, r) {
            var a, o, s, l, c, h, u, p, d, f, m, g = Ht.hasData(t) && Ht.get(t);
            if (g && (l = g.events)) {
                for (c = (e = (e || "").match(Dt) || [""]).length; c--;) if (s = re.exec(e[c]) || [], d = m = s[1], f = (s[2] || "").split(".").sort(), d) {
                    for (u = wt.event.special[d] || {}, p = l[d = (n ? u.delegateType : u.bindType) || d] || [], s = s[2] && new RegExp("(^|\\.)" + f.join("\\.(?:.*\\.|)") + "(\\.|$)"), o = a = p.length; a--;) h = p[a], !r && m !== h.origType || i && i.guid !== h.guid || s && !s.test(h.namespace) || n && n !== h.selector && ("**" !== n || !h.selector) || (p.splice(a, 1), h.selector && p.delegateCount--, u.remove && u.remove.call(t, h));
                    o && !p.length && (u.teardown && !1 !== u.teardown.call(t, f, g.handle) || wt.removeEvent(t, d, g.handle), delete l[d])
                } else for (d in l) wt.event.remove(t, d + e[c], i, n, !0);
                wt.isEmptyObject(l) && Ht.remove(t, "handle events")
            }
        }, dispatch: function (t) {
            var e = wt.event.fix(t), i, n, r, a, o, s, l = new Array(arguments.length),
                c = (Ht.get(this, "events") || {})[e.type] || [], h = wt.event.special[e.type] || {};
            for (l[0] = e, i = 1; i < arguments.length; i++) l[i] = arguments[i];
            if (e.delegateTarget = this, !h.preDispatch || !1 !== h.preDispatch.call(this, e)) {
                for (s = wt.event.handlers.call(this, e, c), i = 0; (a = s[i++]) && !e.isPropagationStopped();) for (e.currentTarget = a.elem, n = 0; (o = a.handlers[n++]) && !e.isImmediatePropagationStopped();) e.rnamespace && !e.rnamespace.test(o.namespace) || (e.handleObj = o, e.data = o.data, void 0 !== (r = ((wt.event.special[o.origType] || {}).handle || o.handler).apply(a.elem, l)) && !1 === (e.result = r) && (e.preventDefault(), e.stopPropagation()));
                return h.postDispatch && h.postDispatch.call(this, e), e.result
            }
        }, handlers: function (t, e) {
            var i, n, r, a, o, s = [], l = e.delegateCount, c = t.target;
            if (l && c.nodeType && !("click" === t.type && t.button >= 1)) for (; c !== this; c = c.parentNode || this) if (1 === c.nodeType && ("click" !== t.type || !0 !== c.disabled)) {
                for (a = [], o = {}, i = 0; i < l; i++) void 0 === o[r = (n = e[i]).selector + " "] && (o[r] = n.needsContext ? wt(r, this).index(c) > -1 : wt.find(r, this, null, [c]).length), o[r] && a.push(n);
                a.length && s.push({elem: c, handlers: a})
            }
            return c = this, l < e.length && s.push({elem: c, handlers: e.slice(l)}), s
        }, addProp: function (t, e) {
            Object.defineProperty(wt.Event.prototype, t, {
                enumerable: !0, configurable: !0, get: yt(e) ? function () {
                    if (this.originalEvent) return e(this.originalEvent)
                } : function () {
                    if (this.originalEvent) return this.originalEvent[t]
                }, set: function (e) {
                    Object.defineProperty(this, t, {enumerable: !0, configurable: !0, writable: !0, value: e})
                }
            })
        }, fix: function (t) {
            return t[wt.expando] ? t : new wt.Event(t)
        }, special: {
            load: {noBubble: !0}, focus: {
                trigger: function () {
                    if (this !== S() && this.focus) return this.focus(), !1
                }, delegateType: "focusin"
            }, blur: {
                trigger: function () {
                    if (this === S() && this.blur) return this.blur(), !1
                }, delegateType: "focusout"
            }, click: {
                trigger: function () {
                    if ("checkbox" === this.type && this.click && a(this, "input")) return this.click(), !1
                }, _default: function (t) {
                    return a(t.target, "a")
                }
            }, beforeunload: {
                postDispatch: function (t) {
                    void 0 !== t.result && t.originalEvent && (t.originalEvent.returnValue = t.result)
                }
            }
        }
    }, wt.removeEvent = function (t, e, i) {
        t.removeEventListener && t.removeEventListener(e, i)
    }, wt.Event = function (t, e) {
        if (!(this instanceof wt.Event)) return new wt.Event(t, e);
        t && t.type ? (this.originalEvent = t, this.type = t.type, this.isDefaultPrevented = t.defaultPrevented || void 0 === t.defaultPrevented && !1 === t.returnValue ? M : T, this.target = t.target && 3 === t.target.nodeType ? t.target.parentNode : t.target, this.currentTarget = t.currentTarget, this.relatedTarget = t.relatedTarget) : this.type = t, e && wt.extend(this, e), this.timeStamp = t && t.timeStamp || Date.now(), this[wt.expando] = !0
    }, wt.Event.prototype = {
        constructor: wt.Event,
        isDefaultPrevented: T,
        isPropagationStopped: T,
        isImmediatePropagationStopped: T,
        isSimulated: !1,
        preventDefault: function () {
            var t = this.originalEvent;
            this.isDefaultPrevented = M, t && !this.isSimulated && t.preventDefault()
        },
        stopPropagation: function () {
            var t = this.originalEvent;
            this.isPropagationStopped = M, t && !this.isSimulated && t.stopPropagation()
        },
        stopImmediatePropagation: function () {
            var t = this.originalEvent;
            this.isImmediatePropagationStopped = M, t && !this.isSimulated && t.stopImmediatePropagation(), this.stopPropagation()
        }
    }, wt.each({
        altKey: !0,
        bubbles: !0,
        cancelable: !0,
        changedTouches: !0,
        ctrlKey: !0,
        detail: !0,
        eventPhase: !0,
        metaKey: !0,
        pageX: !0,
        pageY: !0,
        shiftKey: !0,
        view: !0,
        char: !0,
        charCode: !0,
        key: !0,
        keyCode: !0,
        button: !0,
        buttons: !0,
        clientX: !0,
        clientY: !0,
        offsetX: !0,
        offsetY: !0,
        pointerId: !0,
        pointerType: !0,
        screenX: !0,
        screenY: !0,
        targetTouches: !0,
        toElement: !0,
        touches: !0,
        which: function (t) {
            var e = t.button;
            return null == t.which && ie.test(t.type) ? null != t.charCode ? t.charCode : t.keyCode : !t.which && void 0 !== e && ne.test(t.type) ? 1 & e ? 1 : 2 & e ? 3 : 4 & e ? 2 : 0 : t.which
        }
    }, wt.event.addProp), wt.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function (t, e) {
        wt.event.special[t] = {
            delegateType: e, bindType: e, handle: function (t) {
                var i, n = this, r = t.relatedTarget, a = t.handleObj;
                return r && (r === n || wt.contains(n, r)) || (t.type = a.origType, i = a.handler.apply(this, arguments), t.type = e), i
            }
        }
    }), wt.fn.extend({
        on: function (t, e, i, n) {
            return E(this, t, e, i, n)
        }, one: function (t, e, i, n) {
            return E(this, t, e, i, n, 1)
        }, off: function (t, e, i) {
            var n, r;
            if (t && t.preventDefault && t.handleObj) return n = t.handleObj, wt(t.delegateTarget).off(n.namespace ? n.origType + "." + n.namespace : n.origType, n.selector, n.handler), this;
            if ("object" == typeof t) {
                for (r in t) this.off(r, e, t[r]);
                return this
            }
            return !1 !== e && "function" != typeof e || (i = e, e = void 0), !1 === i && (i = T), this.each(function () {
                wt.event.remove(this, t, i, e)
            })
        }
    });
    var ae = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,
        oe = /<script|<style|<link/i, se = /checked\s*(?:[^=]|=\s*.checked.)/i,
        le = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
    wt.extend({
        htmlPrefilter: function (t) {
            return t.replace(/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, "<$1></$2>")
        }, clone: function (t, e, i) {
            var n, r, a, o, s = t.cloneNode(!0), l = wt.contains(t.ownerDocument, t);
            if (!(vt.noCloneChecked || 1 !== t.nodeType && 11 !== t.nodeType || wt.isXMLDoc(t))) for (o = _(s), n = 0, r = (a = _(t)).length; n < r; n++) R(a[n], o[n]);
            if (e) if (i) for (a = a || _(t), o = o || _(s), n = 0, r = a.length; n < r; n++) C(a[n], o[n]); else C(t, s);
            return (o = _(s, "script")).length > 0 && b(o, !l && _(t, "script")), s
        }, cleanData: function (t) {
            for (var e, i, n, r = wt.event.special, a = 0; void 0 !== (i = t[a]); a++) if (Ft(i)) {
                if (e = i[Ht.expando]) {
                    if (e.events) for (n in e.events) r[n] ? wt.event.remove(i, n) : wt.removeEvent(i, n, e.handle);
                    i[Ht.expando] = void 0
                }
                i[Ut.expando] && (i[Ut.expando] = void 0)
            }
        }
    }), wt.fn.extend({
        detach: function (t) {
            return D(this, t, !0)
        }, remove: function (t) {
            return D(this, t)
        }, text: function (t) {
            return zt(this, function (t) {
                return void 0 === t ? wt.text(this) : this.empty().each(function () {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = t)
                })
            }, null, t, arguments.length)
        }, append: function () {
            return O(this, arguments, function (t) {
                1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || A(this, t).appendChild(t)
            })
        }, prepend: function () {
            return O(this, arguments, function (t) {
                if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                    var e = A(this, t);
                    e.insertBefore(t, e.firstChild)
                }
            })
        }, before: function () {
            return O(this, arguments, function (t) {
                this.parentNode && this.parentNode.insertBefore(t, this)
            })
        }, after: function () {
            return O(this, arguments, function (t) {
                this.parentNode && this.parentNode.insertBefore(t, this.nextSibling)
            })
        }, empty: function () {
            for (var t, e = 0; null != (t = this[e]); e++) 1 === t.nodeType && (wt.cleanData(_(t, !1)), t.textContent = "");
            return this
        }, clone: function (t, e) {
            return t = null != t && t, e = null == e ? t : e, this.map(function () {
                return wt.clone(this, t, e)
            })
        }, html: function (t) {
            return zt(this, function (t) {
                var e = this[0] || {}, i = 0, n = this.length;
                if (void 0 === t && 1 === e.nodeType) return e.innerHTML;
                if ("string" == typeof t && !oe.test(t) && !Kt[($t.exec(t) || ["", ""])[1].toLowerCase()]) {
                    t = wt.htmlPrefilter(t);
                    try {
                        for (; i < n; i++) 1 === (e = this[i] || {}).nodeType && (wt.cleanData(_(e, !1)), e.innerHTML = t);
                        e = 0
                    } catch (t) {
                    }
                }
                e && this.empty().append(t)
            }, null, t, arguments.length)
        }, replaceWith: function () {
            var t = [];
            return O(this, arguments, function (e) {
                var i = this.parentNode;
                wt.inArray(this, t) < 0 && (wt.cleanData(_(this)), i && i.replaceChild(e, this))
            }, t)
        }
    }), wt.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function (t, e) {
        wt.fn[t] = function (t) {
            for (var i, n = [], r = wt(t), a = r.length - 1, o = 0; o <= a; o++) i = o === a ? this : this.clone(!0), wt(r[o])[e](i), ht.apply(n, i.get());
            return this.pushStack(n)
        }
    });
    var ce = new RegExp("^(" + Vt + ")(?!px)[a-z%]+$", "i"), he = function (e) {
        var i = e.ownerDocument.defaultView;
        return i && i.opener || (i = t), i.getComputedStyle(e)
    }, ue = new RegExp(qt.join("|"), "i");
    !function () {
        function e() {
            if (c) {
                l.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", c.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", ee.appendChild(l).appendChild(c);
                var e = t.getComputedStyle(c);
                n = "1%" !== e.top, s = 12 === i(e.marginLeft), c.style.right = "60%", o = 36 === i(e.right), r = 36 === i(e.width), c.style.position = "absolute", a = 36 === c.offsetWidth || "absolute", ee.removeChild(l), c = null
            }
        }

        function i(t) {
            return Math.round(parseFloat(t))
        }

        var n, r, a, o, s, l = ot.createElement("div"), c = ot.createElement("div");
        c.style && (c.style.backgroundClip = "content-box", c.cloneNode(!0).style.backgroundClip = "", vt.clearCloneStyle = "content-box" === c.style.backgroundClip, wt.extend(vt, {
            boxSizingReliable: function () {
                return e(), r
            }, pixelBoxStyles: function () {
                return e(), o
            }, pixelPosition: function () {
                return e(), n
            }, reliableMarginLeft: function () {
                return e(), s
            }, scrollboxSize: function () {
                return e(), a
            }
        }))
    }();
    var pe = /^(none|table(?!-c[ea]).+)/, de = /^--/,
        fe = {position: "absolute", visibility: "hidden", display: "block"},
        me = {letterSpacing: "0", fontWeight: "400"}, ge = ["Webkit", "Moz", "ms"], ve = ot.createElement("div").style;
    wt.extend({
        cssHooks: {
            opacity: {
                get: function (t, e) {
                    if (e) {
                        var i = I(t, "opacity");
                        return "" === i ? "1" : i
                    }
                }
            }
        },
        cssNumber: {
            animationIterationCount: !0,
            columnCount: !0,
            fillOpacity: !0,
            flexGrow: !0,
            flexShrink: !0,
            fontWeight: !0,
            lineHeight: !0,
            opacity: !0,
            order: !0,
            orphans: !0,
            widows: !0,
            zIndex: !0,
            zoom: !0
        },
        cssProps: {},
        style: function (t, e, i, n) {
            if (t && 3 !== t.nodeType && 8 !== t.nodeType && t.style) {
                var r, a, o, s = d(e), l = de.test(e), c = t.style;
                if (l || (e = k(s)), o = wt.cssHooks[e] || wt.cssHooks[s], void 0 === i) return o && "get" in o && void 0 !== (r = o.get(t, !1, n)) ? r : c[e];
                "string" == (a = typeof i) && (r = Wt.exec(i)) && r[1] && (i = v(t, e, r), a = "number"), null != i && i === i && ("number" === a && (i += r && r[3] || (wt.cssNumber[s] ? "" : "px")), vt.clearCloneStyle || "" !== i || 0 !== e.indexOf("background") || (c[e] = "inherit"), o && "set" in o && void 0 === (i = o.set(t, i, n)) || (l ? c.setProperty(e, i) : c[e] = i))
            }
        },
        css: function (t, e, i, n) {
            var r, a, o, s = d(e);
            return de.test(e) || (e = k(s)), (o = wt.cssHooks[e] || wt.cssHooks[s]) && "get" in o && (r = o.get(t, !0, i)), void 0 === r && (r = I(t, e, n)), "normal" === r && e in me && (r = me[e]), "" === i || i ? (a = parseFloat(r), !0 === i || isFinite(a) ? a || 0 : r) : r
        }
    }), wt.each(["height", "width"], function (t, e) {
        wt.cssHooks[e] = {
            get: function (t, i, n) {
                if (i) return !pe.test(wt.css(t, "display")) || t.getClientRects().length && t.getBoundingClientRect().width ? H(t, e, n) : Yt(t, fe, function () {
                    return H(t, e, n)
                })
            }, set: function (t, i, n) {
                var r, a = he(t), o = "border-box" === wt.css(t, "boxSizing", !1, a), s = n && F(t, e, n, o, a);
                return o && vt.scrollboxSize() === a.position && (s -= Math.ceil(t["offset" + e[0].toUpperCase() + e.slice(1)] - parseFloat(a[e]) - F(t, e, "border", !1, a) - .5)), s && (r = Wt.exec(i)) && "px" !== (r[3] || "px") && (t.style[e] = i, i = wt.css(t, e)), B(t, i, s)
            }
        }
    }), wt.cssHooks.marginLeft = N(vt.reliableMarginLeft, function (t, e) {
        if (e) return (parseFloat(I(t, "marginLeft")) || t.getBoundingClientRect().left - Yt(t, {marginLeft: 0}, function () {
            return t.getBoundingClientRect().left
        })) + "px"
    }), wt.each({margin: "", padding: "", border: "Width"}, function (t, e) {
        wt.cssHooks[t + e] = {
            expand: function (i) {
                for (var n = 0, r = {}, a = "string" == typeof i ? i.split(" ") : [i]; n < 4; n++) r[t + qt[n] + e] = a[n] || a[n - 2] || a[0];
                return r
            }
        }, "margin" !== t && (wt.cssHooks[t + e].set = B)
    }), wt.fn.extend({
        css: function (t, e) {
            return zt(this, function (t, e, i) {
                var n, r, a = {}, o = 0;
                if (Array.isArray(e)) {
                    for (n = he(t), r = e.length; o < r; o++) a[e[o]] = wt.css(t, e[o], !1, n);
                    return a
                }
                return void 0 !== i ? wt.style(t, e, i) : wt.css(t, e)
            }, t, e, arguments.length > 1)
        }
    }), wt.Tween = U, U.prototype = {
        constructor: U, init: function (t, e, i, n, r, a) {
            this.elem = t, this.prop = i, this.easing = r || wt.easing._default, this.options = e, this.start = this.now = this.cur(), this.end = n, this.unit = a || (wt.cssNumber[i] ? "" : "px")
        }, cur: function () {
            var t = U.propHooks[this.prop];
            return t && t.get ? t.get(this) : U.propHooks._default.get(this)
        }, run: function (t) {
            var e, i = U.propHooks[this.prop];
            return this.options.duration ? this.pos = e = wt.easing[this.easing](t, this.options.duration * t, 0, 1, this.options.duration) : this.pos = e = t, this.now = (this.end - this.start) * e + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), i && i.set ? i.set(this) : U.propHooks._default.set(this), this
        }
    }, U.prototype.init.prototype = U.prototype, U.propHooks = {
        _default: {
            get: function (t) {
                var e;
                return 1 !== t.elem.nodeType || null != t.elem[t.prop] && null == t.elem.style[t.prop] ? t.elem[t.prop] : (e = wt.css(t.elem, t.prop, "")) && "auto" !== e ? e : 0
            }, set: function (t) {
                wt.fx.step[t.prop] ? wt.fx.step[t.prop](t) : 1 !== t.elem.nodeType || null == t.elem.style[wt.cssProps[t.prop]] && !wt.cssHooks[t.prop] ? t.elem[t.prop] = t.now : wt.style(t.elem, t.prop, t.now + t.unit)
            }
        }
    }, U.propHooks.scrollTop = U.propHooks.scrollLeft = {
        set: function (t) {
            t.elem.nodeType && t.elem.parentNode && (t.elem[t.prop] = t.now)
        }
    }, wt.easing = {
        linear: function (t) {
            return t
        }, swing: function (t) {
            return .5 - Math.cos(t * Math.PI) / 2
        }, _default: "swing"
    }, wt.fx = U.prototype.init, wt.fx.step = {};
    var ye, xe, _e = /^(?:toggle|show|hide)$/, be = /queueHooks$/;
    wt.Animation = wt.extend(Y, {
        tweeners: {
            "*": [function (t, e) {
                var i = this.createTween(t, e);
                return v(i.elem, t, Wt.exec(e), i), i
            }]
        }, tweener: function (t, e) {
            yt(t) ? (e = t, t = ["*"]) : t = t.match(Dt);
            for (var i, n = 0, r = t.length; n < r; n++) i = t[n], Y.tweeners[i] = Y.tweeners[i] || [], Y.tweeners[i].unshift(e)
        }, prefilters: [q], prefilter: function (t, e) {
            e ? Y.prefilters.unshift(t) : Y.prefilters.push(t)
        }
    }), wt.speed = function (t, e, i) {
        var n = t && "object" == typeof t ? wt.extend({}, t) : {
            complete: i || !i && e || yt(t) && t,
            duration: t,
            easing: i && e || e && !yt(e) && e
        };
        return wt.fx.off ? n.duration = 0 : "number" != typeof n.duration && (n.duration in wt.fx.speeds ? n.duration = wt.fx.speeds[n.duration] : n.duration = wt.fx.speeds._default), null != n.queue && !0 !== n.queue || (n.queue = "fx"), n.old = n.complete, n.complete = function () {
            yt(n.old) && n.old.call(this), n.queue && wt.dequeue(this, n.queue)
        }, n
    }, wt.fn.extend({
        fadeTo: function (t, e, i, n) {
            return this.filter(Xt).css("opacity", 0).show().end().animate({opacity: e}, t, i, n)
        }, animate: function (t, e, i, n) {
            var r = wt.isEmptyObject(t), a = wt.speed(e, i, n), o = function () {
                var e = Y(this, wt.extend({}, t), a);
                (r || Ht.get(this, "finish")) && e.stop(!0)
            };
            return o.finish = o, r || !1 === a.queue ? this.each(o) : this.queue(a.queue, o)
        }, stop: function (t, e, i) {
            var n = function (t) {
                var e = t.stop;
                delete t.stop, e(i)
            };
            return "string" != typeof t && (i = e, e = t, t = void 0), e && !1 !== t && this.queue(t || "fx", []), this.each(function () {
                var e = !0, r = null != t && t + "queueHooks", a = wt.timers, o = Ht.get(this);
                if (r) o[r] && o[r].stop && n(o[r]); else for (r in o) o[r] && o[r].stop && be.test(r) && n(o[r]);
                for (r = a.length; r--;) a[r].elem !== this || null != t && a[r].queue !== t || (a[r].anim.stop(i), e = !1, a.splice(r, 1));
                !e && i || wt.dequeue(this, t)
            })
        }, finish: function (t) {
            return !1 !== t && (t = t || "fx"), this.each(function () {
                var e, i = Ht.get(this), n = i[t + "queue"], r = i[t + "queueHooks"], a = wt.timers,
                    o = n ? n.length : 0;
                for (i.finish = !0, wt.queue(this, t, []), r && r.stop && r.stop.call(this, !0), e = a.length; e--;) a[e].elem === this && a[e].queue === t && (a[e].anim.stop(!0), a.splice(e, 1));
                for (e = 0; e < o; e++) n[e] && n[e].finish && n[e].finish.call(this);
                delete i.finish
            })
        }
    }), wt.each(["toggle", "show", "hide"], function (t, e) {
        var i = wt.fn[e];
        wt.fn[e] = function (t, n, r) {
            return null == t || "boolean" == typeof t ? i.apply(this, arguments) : this.animate(V(e, !0), t, n, r)
        }
    }), wt.each({
        slideDown: V("show"),
        slideUp: V("hide"),
        slideToggle: V("toggle"),
        fadeIn: {opacity: "show"},
        fadeOut: {opacity: "hide"},
        fadeToggle: {opacity: "toggle"}
    }, function (t, e) {
        wt.fn[t] = function (t, i, n) {
            return this.animate(e, t, i, n)
        }
    }), wt.timers = [], wt.fx.tick = function () {
        var t, e = 0, i = wt.timers;
        for (ye = Date.now(); e < i.length; e++) (t = i[e])() || i[e] !== t || i.splice(e--, 1);
        i.length || wt.fx.stop(), ye = void 0
    }, wt.fx.timer = function (t) {
        wt.timers.push(t), wt.fx.start()
    }, wt.fx.interval = 13, wt.fx.start = function () {
        xe || (xe = !0, G())
    }, wt.fx.stop = function () {
        xe = null
    }, wt.fx.speeds = {slow: 600, fast: 200, _default: 400}, wt.fn.delay = function (e, i) {
        return e = wt.fx ? wt.fx.speeds[e] || e : e, i = i || "fx", this.queue(i, function (i, n) {
            var r = t.setTimeout(i, e);
            n.stop = function () {
                t.clearTimeout(r)
            }
        })
    }, function () {
        var t = ot.createElement("input"), e = ot.createElement("select").appendChild(ot.createElement("option"));
        t.type = "checkbox", vt.checkOn = "" !== t.value, vt.optSelected = e.selected, (t = ot.createElement("input")).value = "t", t.type = "radio", vt.radioValue = "t" === t.value
    }();
    var we, Me = wt.expr.attrHandle;
    wt.fn.extend({
        attr: function (t, e) {
            return zt(this, wt.attr, t, e, arguments.length > 1)
        }, removeAttr: function (t) {
            return this.each(function () {
                wt.removeAttr(this, t)
            })
        }
    }), wt.extend({
        attr: function (t, e, i) {
            var n, r, a = t.nodeType;
            if (3 !== a && 8 !== a && 2 !== a) return void 0 === t.getAttribute ? wt.prop(t, e, i) : (1 === a && wt.isXMLDoc(t) || (r = wt.attrHooks[e.toLowerCase()] || (wt.expr.match.bool.test(e) ? we : void 0)), void 0 !== i ? null === i ? void wt.removeAttr(t, e) : r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : (t.setAttribute(e, i + ""), i) : r && "get" in r && null !== (n = r.get(t, e)) ? n : null == (n = wt.find.attr(t, e)) ? void 0 : n)
        }, attrHooks: {
            type: {
                set: function (t, e) {
                    if (!vt.radioValue && "radio" === e && a(t, "input")) {
                        var i = t.value;
                        return t.setAttribute("type", e), i && (t.value = i), e
                    }
                }
            }
        }, removeAttr: function (t, e) {
            var i, n = 0, r = e && e.match(Dt);
            if (r && 1 === t.nodeType) for (; i = r[n++];) t.removeAttribute(i)
        }
    }), we = {
        set: function (t, e, i) {
            return !1 === e ? wt.removeAttr(t, i) : t.setAttribute(i, i), i
        }
    }, wt.each(wt.expr.match.bool.source.match(/\w+/g), function (t, e) {
        var i = Me[e] || wt.find.attr;
        Me[e] = function (t, e, n) {
            var r, a, o = e.toLowerCase();
            return n || (a = Me[o], Me[o] = r, r = null != i(t, e, n) ? o : null, Me[o] = a), r
        }
    });
    var Te = /^(?:input|select|textarea|button)$/i, Se = /^(?:a|area)$/i;
    wt.fn.extend({
        prop: function (t, e) {
            return zt(this, wt.prop, t, e, arguments.length > 1)
        }, removeProp: function (t) {
            return this.each(function () {
                delete this[wt.propFix[t] || t]
            })
        }
    }), wt.extend({
        prop: function (t, e, i) {
            var n, r, a = t.nodeType;
            if (3 !== a && 8 !== a && 2 !== a) return 1 === a && wt.isXMLDoc(t) || (e = wt.propFix[e] || e, r = wt.propHooks[e]), void 0 !== i ? r && "set" in r && void 0 !== (n = r.set(t, i, e)) ? n : t[e] = i : r && "get" in r && null !== (n = r.get(t, e)) ? n : t[e]
        }, propHooks: {
            tabIndex: {
                get: function (t) {
                    var e = wt.find.attr(t, "tabindex");
                    return e ? parseInt(e, 10) : Te.test(t.nodeName) || Se.test(t.nodeName) && t.href ? 0 : -1
                }
            }
        }, propFix: {for: "htmlFor", class: "className"}
    }), vt.optSelected || (wt.propHooks.selected = {
        get: function (t) {
            var e = t.parentNode;
            return e && e.parentNode && e.parentNode.selectedIndex, null
        }, set: function (t) {
            var e = t.parentNode;
            e && (e.selectedIndex, e.parentNode && e.parentNode.selectedIndex)
        }
    }), wt.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
        wt.propFix[this.toLowerCase()] = this
    }), wt.fn.extend({
        addClass: function (t) {
            var e, i, n, r, a, o, s, l = 0;
            if (yt(t)) return this.each(function (e) {
                wt(this).addClass(t.call(this, e, Z(this)))
            });
            if ((e = Q(t)).length) for (; i = this[l++];) if (r = Z(i), n = 1 === i.nodeType && " " + J(r) + " ") {
                for (o = 0; a = e[o++];) n.indexOf(" " + a + " ") < 0 && (n += a + " ");
                r !== (s = J(n)) && i.setAttribute("class", s)
            }
            return this
        }, removeClass: function (t) {
            var e, i, n, r, a, o, s, l = 0;
            if (yt(t)) return this.each(function (e) {
                wt(this).removeClass(t.call(this, e, Z(this)))
            });
            if (!arguments.length) return this.attr("class", "");
            if ((e = Q(t)).length) for (; i = this[l++];) if (r = Z(i), n = 1 === i.nodeType && " " + J(r) + " ") {
                for (o = 0; a = e[o++];) for (; n.indexOf(" " + a + " ") > -1;) n = n.replace(" " + a + " ", " ");
                r !== (s = J(n)) && i.setAttribute("class", s)
            }
            return this
        }, toggleClass: function (t, e) {
            var i = typeof t, n = "string" === i || Array.isArray(t);
            return "boolean" == typeof e && n ? e ? this.addClass(t) : this.removeClass(t) : yt(t) ? this.each(function (i) {
                wt(this).toggleClass(t.call(this, i, Z(this), e), e)
            }) : this.each(function () {
                var e, r, a, o;
                if (n) for (r = 0, a = wt(this), o = Q(t); e = o[r++];) a.hasClass(e) ? a.removeClass(e) : a.addClass(e); else void 0 !== t && "boolean" !== i || ((e = Z(this)) && Ht.set(this, "__className__", e), this.setAttribute && this.setAttribute("class", e || !1 === t ? "" : Ht.get(this, "__className__") || ""))
            })
        }, hasClass: function (t) {
            var e, i, n = 0;
            for (e = " " + t + " "; i = this[n++];) if (1 === i.nodeType && (" " + J(Z(i)) + " ").indexOf(e) > -1) return !0;
            return !1
        }
    });
    var Ee = /\r/g;
    wt.fn.extend({
        val: function (t) {
            var e, i, n, r = this[0];
            return arguments.length ? (n = yt(t), this.each(function (i) {
                var r;
                1 === this.nodeType && (null == (r = n ? t.call(this, i, wt(this).val()) : t) ? r = "" : "number" == typeof r ? r += "" : Array.isArray(r) && (r = wt.map(r, function (t) {
                    return null == t ? "" : t + ""
                })), (e = wt.valHooks[this.type] || wt.valHooks[this.nodeName.toLowerCase()]) && "set" in e && void 0 !== e.set(this, r, "value") || (this.value = r))
            })) : r ? (e = wt.valHooks[r.type] || wt.valHooks[r.nodeName.toLowerCase()]) && "get" in e && void 0 !== (i = e.get(r, "value")) ? i : "string" == typeof (i = r.value) ? i.replace(/\r/g, "") : null == i ? "" : i : void 0
        }
    }), wt.extend({
        valHooks: {
            option: {
                get: function (t) {
                    var e = wt.find.attr(t, "value");
                    return null != e ? e : J(wt.text(t))
                }
            }, select: {
                get: function (t) {
                    var e, i, n, r = t.options, o = t.selectedIndex, s = "select-one" === t.type, l = s ? null : [],
                        c = s ? o + 1 : r.length;
                    for (n = o < 0 ? c : s ? o : 0; n < c; n++) if (((i = r[n]).selected || n === o) && !i.disabled && (!i.parentNode.disabled || !a(i.parentNode, "optgroup"))) {
                        if (e = wt(i).val(), s) return e;
                        l.push(e)
                    }
                    return l
                }, set: function (t, e) {
                    for (var i, n, r = t.options, a = wt.makeArray(e), o = r.length; o--;) ((n = r[o]).selected = wt.inArray(wt.valHooks.option.get(n), a) > -1) && (i = !0);
                    return i || (t.selectedIndex = -1), a
                }
            }
        }
    }), wt.each(["radio", "checkbox"], function () {
        wt.valHooks[this] = {
            set: function (t, e) {
                if (Array.isArray(e)) return t.checked = wt.inArray(wt(t).val(), e) > -1
            }
        }, vt.checkOn || (wt.valHooks[this].get = function (t) {
            return null === t.getAttribute("value") ? "on" : t.value
        })
    }), vt.focusin = "onfocusin" in t;
    var Ae = /^(?:focusinfocus|focusoutblur)$/, Pe = function (t) {
        t.stopPropagation()
    };
    wt.extend(wt.event, {
        trigger: function (e, i, n, r) {
            var a, o, s, l, c, h, u, p, d = [n || ot], f = ft.call(e, "type") ? e.type : e,
                m = ft.call(e, "namespace") ? e.namespace.split(".") : [];
            if (o = p = s = n = n || ot, 3 !== n.nodeType && 8 !== n.nodeType && !Ae.test(f + wt.event.triggered) && (f.indexOf(".") > -1 && (f = (m = f.split(".")).shift(), m.sort()), c = f.indexOf(":") < 0 && "on" + f, e = e[wt.expando] ? e : new wt.Event(f, "object" == typeof e && e), e.isTrigger = r ? 2 : 3, e.namespace = m.join("."), e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + m.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, e.result = void 0, e.target || (e.target = n), i = null == i ? [e] : wt.makeArray(i, [e]), u = wt.event.special[f] || {}, r || !u.trigger || !1 !== u.trigger.apply(n, i))) {
                if (!r && !u.noBubble && !xt(n)) {
                    for (l = u.delegateType || f, Ae.test(l + f) || (o = o.parentNode); o; o = o.parentNode) d.push(o), s = o;
                    s === (n.ownerDocument || ot) && d.push(s.defaultView || s.parentWindow || t)
                }
                for (a = 0; (o = d[a++]) && !e.isPropagationStopped();) p = o, e.type = a > 1 ? l : u.bindType || f, (h = (Ht.get(o, "events") || {})[e.type] && Ht.get(o, "handle")) && h.apply(o, i), (h = c && o[c]) && h.apply && Ft(o) && (e.result = h.apply(o, i), !1 === e.result && e.preventDefault());
                return e.type = f, r || e.isDefaultPrevented() || u._default && !1 !== u._default.apply(d.pop(), i) || !Ft(n) || c && yt(n[f]) && !xt(n) && ((s = n[c]) && (n[c] = null), wt.event.triggered = f, e.isPropagationStopped() && p.addEventListener(f, Pe), n[f](), e.isPropagationStopped() && p.removeEventListener(f, Pe), wt.event.triggered = void 0, s && (n[c] = s)), e.result
            }
        }, simulate: function (t, e, i) {
            var n = wt.extend(new wt.Event, i, {type: t, isSimulated: !0});
            wt.event.trigger(n, null, e)
        }
    }), wt.fn.extend({
        trigger: function (t, e) {
            return this.each(function () {
                wt.event.trigger(t, e, this)
            })
        }, triggerHandler: function (t, e) {
            var i = this[0];
            if (i) return wt.event.trigger(t, e, i, !0)
        }
    }),
    vt.focusin || wt.each({focus: "focusin", blur: "focusout"}, function (t, e) {
        var i = function (t) {
            wt.event.simulate(e, t.target, wt.event.fix(t))
        };
        wt.event.special[e] = {
            setup: function () {
                var n = this.ownerDocument || this, r = Ht.access(n, e);
                r || n.addEventListener(t, i, !0), Ht.access(n, e, (r || 0) + 1)
            }, teardown: function () {
                var n = this.ownerDocument || this, r = Ht.access(n, e) - 1;
                r ? Ht.access(n, e, r) : (n.removeEventListener(t, i, !0), Ht.remove(n, e))
            }
        }
    });
    var Le = t.location, Ce = Date.now(), Re = /\?/;
    wt.parseXML = function (e) {
        var i;
        if (!e || "string" != typeof e) return null;
        try {
            i = (new t.DOMParser).parseFromString(e, "text/xml")
        } catch (t) {
            i = void 0
        }
        return i && !i.getElementsByTagName("parsererror").length || wt.error("Invalid XML: " + e), i
    };
    var Oe = /\[\]$/, De = /\r?\n/g, Ie = /^(?:submit|button|image|reset|file)$/i,
        Ne = /^(?:input|select|textarea|keygen)/i;
    wt.param = function (t, e) {
        var i, n = [], r = function (t, e) {
            var i = yt(e) ? e() : e;
            n[n.length] = encodeURIComponent(t) + "=" + encodeURIComponent(null == i ? "" : i)
        };
        if (Array.isArray(t) || t.jquery && !wt.isPlainObject(t)) wt.each(t, function () {
            r(this.name, this.value)
        }); else for (i in t) K(i, t[i], e, r);
        return n.join("&")
    }, wt.fn.extend({
        serialize: function () {
            return wt.param(this.serializeArray())
        }, serializeArray: function () {
            return this.map(function () {
                var t = wt.prop(this, "elements");
                return t ? wt.makeArray(t) : this
            }).filter(function () {
                var t = this.type;
                return this.name && !wt(this).is(":disabled") && Ne.test(this.nodeName) && !Ie.test(t) && (this.checked || !Zt.test(t))
            }).map(function (t, e) {
                var i = wt(this).val();
                return null == i ? null : Array.isArray(i) ? wt.map(i, function (t) {
                    return {name: e.name, value: t.replace(/\r?\n/g, "\r\n")}
                }) : {name: e.name, value: i.replace(/\r?\n/g, "\r\n")}
            }).get()
        }
    });
    var ze = /%20/g, ke = /#.*$/, Be = /([?&])_=[^&]*/, Fe = /^(.*?):[ \t]*([^\r\n]*)$/gm,
        He = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Ue = /^(?:GET|HEAD)$/, Ge = /^\/\//, je = {},
        Ve = {}, We = "*/".concat("*"), qe = ot.createElement("a");
    qe.href = Le.href, wt.extend({
        active: 0,
        lastModified: {},
        etag: {},
        ajaxSettings: {
            url: Le.href,
            type: "GET",
            isLocal: He.test(Le.protocol),
            global: !0,
            processData: !0,
            async: !0,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            accepts: {
                "*": We,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },
            contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/},
            responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
            converters: {"* text": String, "text html": !0, "text json": JSON.parse, "text xml": wt.parseXML},
            flatOptions: {url: !0, context: !0}
        },
        ajaxSetup: function (t, e) {
            return e ? it(it(t, wt.ajaxSettings), e) : it(wt.ajaxSettings, t)
        },
        ajaxPrefilter: tt(je),
        ajaxTransport: tt(Ve),
        ajax: function (e, i) {
            function n(e, i, n, s) {
                var c, p, d, _, b, w = i;
                h || (h = !0, l && t.clearTimeout(l), r = void 0, o = s || "", M.readyState = e > 0 ? 4 : 0, c = e >= 200 && e < 300 || 304 === e, n && (_ = nt(f, M, n)), _ = rt(f, _, M, c), c ? (f.ifModified && ((b = M.getResponseHeader("Last-Modified")) && (wt.lastModified[a] = b), (b = M.getResponseHeader("etag")) && (wt.etag[a] = b)), 204 === e || "HEAD" === f.type ? w = "nocontent" : 304 === e ? w = "notmodified" : (w = _.state, p = _.data, c = !(d = _.error))) : (d = w, !e && w || (w = "error", e < 0 && (e = 0))), M.status = e, M.statusText = (i || w) + "", c ? v.resolveWith(m, [p, w, M]) : v.rejectWith(m, [M, w, d]), M.statusCode(x), x = void 0, u && g.trigger(c ? "ajaxSuccess" : "ajaxError", [M, f, c ? p : d]), y.fireWith(m, [M, w]), u && (g.trigger("ajaxComplete", [M, f]), --wt.active || wt.event.trigger("ajaxStop")))
            }

            "object" == typeof e && (i = e, e = void 0), i = i || {};
            var r, a, o, s, l, c, h, u, p, d, f = wt.ajaxSetup({}, i), m = f.context || f,
                g = f.context && (m.nodeType || m.jquery) ? wt(m) : wt.event, v = wt.Deferred(),
                y = wt.Callbacks("once memory"), x = f.statusCode || {}, _ = {}, b = {}, w = "canceled", M = {
                    readyState: 0, getResponseHeader: function (t) {
                        var e;
                        if (h) {
                            if (!s) for (s = {}; e = Fe.exec(o);) s[e[1].toLowerCase()] = e[2];
                            e = s[t.toLowerCase()]
                        }
                        return null == e ? null : e
                    }, getAllResponseHeaders: function () {
                        return h ? o : null
                    }, setRequestHeader: function (t, e) {
                        return null == h && (t = b[t.toLowerCase()] = b[t.toLowerCase()] || t, _[t] = e), this
                    }, overrideMimeType: function (t) {
                        return null == h && (f.mimeType = t), this
                    }, statusCode: function (t) {
                        var e;
                        if (t) if (h) M.always(t[M.status]); else for (e in t) x[e] = [x[e], t[e]];
                        return this
                    }, abort: function (t) {
                        var e = t || w;
                        return r && r.abort(e), n(0, e), this
                    }
                };
            if (v.promise(M), f.url = ((e || f.url || Le.href) + "").replace(/^\/\//, Le.protocol + "//"), f.type = i.method || i.type || f.method || f.type, f.dataTypes = (f.dataType || "*").toLowerCase().match(Dt) || [""], null == f.crossDomain) {
                c = ot.createElement("a");
                try {
                    c.href = f.url, c.href = c.href, f.crossDomain = qe.protocol + "//" + qe.host != c.protocol + "//" + c.host
                } catch (t) {
                    f.crossDomain = !0
                }
            }
            if (f.data && f.processData && "string" != typeof f.data && (f.data = wt.param(f.data, f.traditional)), et(je, f, i, M), h) return M;
            (u = wt.event && f.global) && 0 == wt.active++ && wt.event.trigger("ajaxStart"), f.type = f.type.toUpperCase(), f.hasContent = !Ue.test(f.type), a = f.url.replace(/#.*$/, ""), f.hasContent ? f.data && f.processData && 0 === (f.contentType || "").indexOf("application/x-www-form-urlencoded") && (f.data = f.data.replace(/%20/g, "+")) : (d = f.url.slice(a.length), f.data && (f.processData || "string" == typeof f.data) && (a += (Re.test(a) ? "&" : "?") + f.data, delete f.data), !1 === f.cache && (a = a.replace(/([?&])_=[^&]*/, "$1"), d = (Re.test(a) ? "&" : "?") + "_=" + Ce++ + d), f.url = a + d), f.ifModified && (wt.lastModified[a] && M.setRequestHeader("If-Modified-Since", wt.lastModified[a]), wt.etag[a] && M.setRequestHeader("If-None-Match", wt.etag[a])), (f.data && f.hasContent && !1 !== f.contentType || i.contentType) && M.setRequestHeader("Content-Type", f.contentType), M.setRequestHeader("Accept", f.dataTypes[0] && f.accepts[f.dataTypes[0]] ? f.accepts[f.dataTypes[0]] + ("*" !== f.dataTypes[0] ? ", " + We + "; q=0.01" : "") : f.accepts["*"]);
            for (p in f.headers) M.setRequestHeader(p, f.headers[p]);
            if (f.beforeSend && (!1 === f.beforeSend.call(m, M, f) || h)) return M.abort();
            if (w = "abort", y.add(f.complete), M.done(f.success), M.fail(f.error), r = et(Ve, f, i, M)) {
                if (M.readyState = 1, u && g.trigger("ajaxSend", [M, f]), h) return M;
                f.async && f.timeout > 0 && (l = t.setTimeout(function () {
                    M.abort("timeout")
                }, f.timeout));
                try {
                    h = !1, r.send(_, n)
                } catch (t) {
                    if (h) throw t;
                    n(-1, t)
                }
            } else n(-1, "No Transport");
            return M
        },
        getJSON: function (t, e, i) {
            return wt.get(t, e, i, "json")
        },
        getScript: function (t, e) {
            return wt.get(t, void 0, e, "script")
        }
    }), wt.each(["get", "post"], function (t, e) {
        wt[e] = function (t, i, n, r) {
            return yt(i) && (r = r || n, n = i, i = void 0), wt.ajax(wt.extend({
                url: t,
                type: e,
                dataType: r,
                data: i,
                success: n
            }, wt.isPlainObject(t) && t))
        }
    }), wt._evalUrl = function (t) {
        return wt.ajax({url: t, type: "GET", dataType: "script", cache: !0, async: !1, global: !1, throws: !0})
    }, wt.fn.extend({
        wrapAll: function (t) {
            var e;
            return this[0] && (yt(t) && (t = t.call(this[0])), e = wt(t, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && e.insertBefore(this[0]), e.map(function () {
                for (var t = this; t.firstElementChild;) t = t.firstElementChild;
                return t
            }).append(this)), this
        }, wrapInner: function (t) {
            return yt(t) ? this.each(function (e) {
                wt(this).wrapInner(t.call(this, e))
            }) : this.each(function () {
                var e = wt(this), i = e.contents();
                i.length ? i.wrapAll(t) : e.append(t)
            })
        }, wrap: function (t) {
            var e = yt(t);
            return this.each(function (i) {
                wt(this).wrapAll(e ? t.call(this, i) : t)
            })
        }, unwrap: function (t) {
            return this.parent(t).not("body").each(function () {
                wt(this).replaceWith(this.childNodes)
            }), this
        }
    }), wt.expr.pseudos.hidden = function (t) {
        return !wt.expr.pseudos.visible(t)
    }, wt.expr.pseudos.visible = function (t) {
        return !!(t.offsetWidth || t.offsetHeight || t.getClientRects().length)
    }, wt.ajaxSettings.xhr = function () {
        try {
            return new t.XMLHttpRequest
        } catch (t) {
        }
    };
    var Xe = {0: 200, 1223: 204}, Ye = wt.ajaxSettings.xhr();
    vt.cors = !!Ye && "withCredentials" in Ye, vt.ajax = Ye = !!Ye, wt.ajaxTransport(function (e) {
        var i, n;
        if (vt.cors || Ye && !e.crossDomain) return {
            send: function (r, a) {
                var o, s = e.xhr();
                if (s.open(e.type, e.url, e.async, e.username, e.password), e.xhrFields) for (o in e.xhrFields) s[o] = e.xhrFields[o];
                e.mimeType && s.overrideMimeType && s.overrideMimeType(e.mimeType), e.crossDomain || r["X-Requested-With"] || (r["X-Requested-With"] = "XMLHttpRequest");
                for (o in r) s.setRequestHeader(o, r[o]);
                i = function (t) {
                    return function () {
                        i && (i = n = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abort" === t ? s.abort() : "error" === t ? "number" != typeof s.status ? a(0, "error") : a(s.status, s.statusText) : a(Xe[s.status] || s.status, s.statusText, "text" !== (s.responseType || "text") || "string" != typeof s.responseText ? {binary: s.response} : {text: s.responseText}, s.getAllResponseHeaders()))
                    }
                }, s.onload = i(), n = s.onerror = s.ontimeout = i("error"), void 0 !== s.onabort ? s.onabort = n : s.onreadystatechange = function () {
                    4 === s.readyState && t.setTimeout(function () {
                        i && n()
                    })
                }, i = i("abort");
                try {
                    s.send(e.hasContent && e.data || null)
                } catch (t) {
                    if (i) throw t
                }
            }, abort: function () {
                i && i()
            }
        }
    }), wt.ajaxPrefilter(function (t) {
        t.crossDomain && (t.contents.script = !1)
    }), wt.ajaxSetup({
        accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
        contents: {script: /\b(?:java|ecma)script\b/},
        converters: {
            "text script": function (t) {
                return wt.globalEval(t), t
            }
        }
    }), wt.ajaxPrefilter("script", function (t) {
        void 0 === t.cache && (t.cache = !1), t.crossDomain && (t.type = "GET")
    }), wt.ajaxTransport("script", function (t) {
        if (t.crossDomain) {
            var e, i;
            return {
                send: function (n, r) {
                    e = wt("<script>").prop({charset: t.scriptCharset, src: t.url}).on("load error", i = function (t) {
                        e.remove(), i = null, t && r("error" === t.type ? 404 : 200, t.type)
                    }), ot.head.appendChild(e[0])
                }, abort: function () {
                    i && i()
                }
            }
        }
    });
    var Je = [], Ze = /(=)\?(?=&|$)|\?\?/;
    wt.ajaxSetup({
        jsonp: "callback", jsonpCallback: function () {
            var t = Je.pop() || wt.expando + "_" + Ce++;
            return this[t] = !0, t
        }
    }), wt.ajaxPrefilter("json jsonp", function (e, i, n) {
        var r, a, o,
            s = !1 !== e.jsonp && (Ze.test(e.url) ? "url" : "string" == typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ze.test(e.data) && "data");
        if (s || "jsonp" === e.dataTypes[0]) return r = e.jsonpCallback = yt(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback, s ? e[s] = e[s].replace(Ze, "$1" + r) : !1 !== e.jsonp && (e.url += (Re.test(e.url) ? "&" : "?") + e.jsonp + "=" + r), e.converters["script json"] = function () {
            return o || wt.error(r + " was not called"), o[0]
        }, e.dataTypes[0] = "json", a = t[r], t[r] = function () {
            o = arguments
        }, n.always(function () {
            void 0 === a ? wt(t).removeProp(r) : t[r] = a, e[r] && (e.jsonpCallback = i.jsonpCallback, Je.push(r)), o && yt(a) && a(o[0]), o = a = void 0
        }), "script"
    }), vt.createHTMLDocument = function () {
        var t = ot.implementation.createHTMLDocument("").body;
        return t.innerHTML = "<form></form><form></form>", 2 === t.childNodes.length
    }(), wt.parseHTML = function (t, e, i) {
        if ("string" != typeof t) return [];
        "boolean" == typeof e && (i = e, e = !1);
        var n, r, a;
        return e || (vt.createHTMLDocument ? ((n = (e = ot.implementation.createHTMLDocument("")).createElement("base")).href = ot.location.href, e.head.appendChild(n)) : e = ot), r = Pt.exec(t), a = !i && [], r ? [e.createElement(r[1])] : (r = w([t], e, a), a && a.length && wt(a).remove(), wt.merge([], r.childNodes))
    }, wt.fn.load = function (t, e, i) {
        var n, r, a, o = this, s = t.indexOf(" ");
        return s > -1 && (n = J(t.slice(s)), t = t.slice(0, s)), yt(e) ? (i = e, e = void 0) : e && "object" == typeof e && (r = "POST"), o.length > 0 && wt.ajax({
            url: t,
            type: r || "GET",
            dataType: "html",
            data: e
        }).done(function (t) {
            a = arguments, o.html(n ? wt("<div>").append(wt.parseHTML(t)).find(n) : t)
        }).always(i && function (t, e) {
            o.each(function () {
                i.apply(this, a || [t.responseText, e, t])
            })
        }), this
    }, wt.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (t, e) {
        wt.fn[e] = function (t) {
            return this.on(e, t)
        }
    }), wt.expr.pseudos.animated = function (t) {
        return wt.grep(wt.timers, function (e) {
            return t === e.elem
        }).length
    }, wt.offset = {
        setOffset: function (t, e, i) {
            var n, r, a, o, s, l, c, h = wt.css(t, "position"), u = wt(t), p = {};
            "static" === h && (t.style.position = "relative"), s = u.offset(), a = wt.css(t, "top"), l = wt.css(t, "left"), (c = ("absolute" === h || "fixed" === h) && (a + l).indexOf("auto") > -1) ? (o = (n = u.position()).top, r = n.left) : (o = parseFloat(a) || 0, r = parseFloat(l) || 0), yt(e) && (e = e.call(t, i, wt.extend({}, s))), null != e.top && (p.top = e.top - s.top + o), null != e.left && (p.left = e.left - s.left + r), "using" in e ? e.using.call(t, p) : u.css(p)
        }
    }, wt.fn.extend({
        offset: function (t) {
            if (arguments.length) return void 0 === t ? this : this.each(function (e) {
                wt.offset.setOffset(this, t, e)
            });
            var e, i, n = this[0];
            return n ? n.getClientRects().length ? (e = n.getBoundingClientRect(), i = n.ownerDocument.defaultView, {
                top: e.top + i.pageYOffset,
                left: e.left + i.pageXOffset
            }) : {top: 0, left: 0} : void 0
        }, position: function () {
            if (this[0]) {
                var t, e, i, n = this[0], r = {top: 0, left: 0};
                if ("fixed" === wt.css(n, "position")) e = n.getBoundingClientRect(); else {
                    for (e = this.offset(), i = n.ownerDocument, t = n.offsetParent || i.documentElement; t && (t === i.body || t === i.documentElement) && "static" === wt.css(t, "position");) t = t.parentNode;
                    t && t !== n && 1 === t.nodeType && ((r = wt(t).offset()).top += wt.css(t, "borderTopWidth", !0), r.left += wt.css(t, "borderLeftWidth", !0))
                }
                return {
                    top: e.top - r.top - wt.css(n, "marginTop", !0),
                    left: e.left - r.left - wt.css(n, "marginLeft", !0)
                }
            }
        }, offsetParent: function () {
            return this.map(function () {
                for (var t = this.offsetParent; t && "static" === wt.css(t, "position");) t = t.offsetParent;
                return t || ee
            })
        }
    }), wt.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (t, e) {
        var i = "pageYOffset" === e;
        wt.fn[t] = function (n) {
            return zt(this, function (t, n, r) {
                var a;
                if (xt(t) ? a = t : 9 === t.nodeType && (a = t.defaultView), void 0 === r) return a ? a[e] : t[n];
                a ? a.scrollTo(i ? a.pageXOffset : r, i ? r : a.pageYOffset) : t[n] = r
            }, t, n, arguments.length)
        }
    }), wt.each(["top", "left"], function (t, e) {
        wt.cssHooks[e] = N(vt.pixelPosition, function (t, i) {
            if (i) return i = I(t, e), ce.test(i) ? wt(t).position()[e] + "px" : i
        })
    }), wt.each({Height: "height", Width: "width"}, function (t, e) {
        wt.each({padding: "inner" + t, content: e, "": "outer" + t}, function (i, n) {
            wt.fn[n] = function (r, a) {
                var o = arguments.length && (i || "boolean" != typeof r),
                    s = i || (!0 === r || !0 === a ? "margin" : "border");
                return zt(this, function (e, i, r) {
                    var a;
                    return xt(e) ? 0 === n.indexOf("outer") ? e["inner" + t] : e.document.documentElement["client" + t] : 9 === e.nodeType ? (a = e.documentElement, Math.max(e.body["scroll" + t], a["scroll" + t], e.body["offset" + t], a["offset" + t], a["client" + t])) : void 0 === r ? wt.css(e, i, s) : wt.style(e, i, r, s)
                }, e, o ? r : void 0, o)
            }
        })
    }), wt.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (t, e) {
        wt.fn[e] = function (t, i) {
            return arguments.length > 0 ? this.on(e, null, t, i) : this.trigger(e)
        }
    }), wt.fn.extend({
        hover: function (t, e) {
            return this.mouseenter(t).mouseleave(e || t)
        }
    }), wt.fn.extend({
        bind: function (t, e, i) {
            return this.on(t, null, e, i)
        }, unbind: function (t, e) {
            return this.off(t, null, e)
        }, delegate: function (t, e, i, n) {
            return this.on(e, t, i, n)
        }, undelegate: function (t, e, i) {
            return 1 === arguments.length ? this.off(t, "**") : this.off(e, t || "**", i)
        }
    }), wt.proxy = function (t, e) {
        var i, n, r;
        if ("string" == typeof e && (i = t[e], e = t, t = i), yt(t)) return n = lt.call(arguments, 2), r = function () {
            return t.apply(e || this, n.concat(lt.call(arguments)))
        }, r.guid = t.guid = t.guid || wt.guid++, r
    }, wt.holdReady = function (t) {
        t ? wt.readyWait++ : wt.ready(!0)
    }, wt.isArray = Array.isArray, wt.parseJSON = JSON.parse, wt.nodeName = a, wt.isFunction = yt, wt.isWindow = xt, wt.camelCase = d, wt.type = n, wt.now = Date.now, wt.isNumeric = function (t) {
        var e = wt.type(t);
        return ("number" === e || "string" === e) && !isNaN(t - parseFloat(t))
    }, "function" == typeof define && define.amd && define("jquery", [], function () {
        return wt
    });
    var $e = t.jQuery, Qe = t.$;
    return wt.noConflict = function (e) {
        return t.$ === wt && (t.$ = Qe), e && t.jQuery === wt && (t.jQuery = $e), wt
    }, e || (t.jQuery = t.$ = wt), wt
}), function (t) {
    "function" == typeof define && define.amd ? define(["jquery"], t) : "object" == typeof exports ? module.exports = t : t(jQuery)
}(function (t) {
    function e(e) {
        var o = e || window.event, s = l.call(arguments, 1), c = 0, u = 0, p = 0, d = 0, f = 0, m = 0;
        if (e = t.event.fix(o), e.type = "mousewheel", "detail" in o && (p = -1 * o.detail), "wheelDelta" in o && (p = o.wheelDelta), "wheelDeltaY" in o && (p = o.wheelDeltaY), "wheelDeltaX" in o && (u = -1 * o.wheelDeltaX), "axis" in o && o.axis === o.HORIZONTAL_AXIS && (u = -1 * p, p = 0), c = 0 === p ? u : p, "deltaY" in o && (p = -1 * o.deltaY, c = p), "deltaX" in o && (u = o.deltaX, 0 === p && (c = -1 * u)), 0 !== p || 0 !== u) {
            if (1 === o.deltaMode) {
                var g = t.data(this, "mousewheel-line-height");
                c *= g, p *= g, u *= g
            } else if (2 === o.deltaMode) {
                var v = t.data(this, "mousewheel-page-height");
                c *= v, p *= v, u *= v
            }
            if (d = Math.max(Math.abs(p), Math.abs(u)), (!a || a > d) && (a = d, n(o, d) && (a /= 40)), n(o, d) && (c /= 40, u /= 40, p /= 40), c = Math[c >= 1 ? "floor" : "ceil"](c / a), u = Math[u >= 1 ? "floor" : "ceil"](u / a), p = Math[p >= 1 ? "floor" : "ceil"](p / a), h.settings.normalizeOffset && this.getBoundingClientRect) {
                var y = this.getBoundingClientRect();
                f = e.clientX - y.left, m = e.clientY - y.top
            }
            return e.deltaX = u, e.deltaY = p, e.deltaFactor = a, e.offsetX = f, e.offsetY = m, e.deltaMode = 0, s.unshift(e, c, u, p), r && clearTimeout(r), r = setTimeout(i, 200), (t.event.dispatch || t.event.handle).apply(this, s)
        }
    }

    function i() {
        a = null
    }

    function n(t, e) {
        return h.settings.adjustOldDeltas && "mousewheel" === t.type && e % 120 == 0
    }

    var r, a, o = ["wheel", "mousewheel", "DOMMouseScroll", "MozMousePixelScroll"],
        s = "onwheel" in document || document.documentMode >= 9 ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"],
        l = Array.prototype.slice;
    if (t.event.fixHooks) for (var c = o.length; c;) t.event.fixHooks[o[--c]] = t.event.mouseHooks;
    var h = t.event.special.mousewheel = {
        version: "3.1.12", setup: function () {
            if (this.addEventListener) for (var i = s.length; i;) this.addEventListener(s[--i], e, !1); else this.onmousewheel = e;
            t.data(this, "mousewheel-line-height", h.getLineHeight(this)), t.data(this, "mousewheel-page-height", h.getPageHeight(this))
        }, teardown: function () {
            if (this.removeEventListener) for (var i = s.length; i;) this.removeEventListener(s[--i], e, !1); else this.onmousewheel = null;
            t.removeData(this, "mousewheel-line-height"), t.removeData(this, "mousewheel-page-height")
        }, getLineHeight: function (e) {
            var i = t(e), n = i["offsetParent" in t.fn ? "offsetParent" : "parent"]();
            return n.length || (n = t("body")), parseInt(n.css("fontSize"), 10) || parseInt(i.css("fontSize"), 10) || 16
        }, getPageHeight: function (e) {
            return t(e).height()
        }, settings: {adjustOldDeltas: !0, normalizeOffset: !0}
    };
    t.fn.extend({
        mousewheel: function (t) {
            return t ? this.bind("mousewheel", t) : this.trigger("mousewheel")
        }, unmousewheel: function (t) {
            return this.unbind("mousewheel", t)
        }
    })
}), function () {
    "use strict";

    function t() {
        this.positions = [], this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [], this.counters = [], this.geometry = new a.BufferGeometry, this.widthCallback = null, this.matrixWorld = new a.Matrix4
    }

    function e(t, e, i, n, r) {
        var a;
        if (t = t.subarray || t.slice ? t : t.buffer, i = i.subarray || i.slice ? i : i.buffer, t = e ? t.subarray ? t.subarray(e, r && e + r) : t.slice(e, r && e + r) : t, i.set) i.set(t, n); else for (a = 0; a < t.length; a++) i[a + n] = t[a];
        return i
    }

    function i(t) {
        a.ShaderMaterial.call(this, {
            uniforms: Object.assign({}, a.UniformsLib.fog, {
                lineWidth: {value: 1},
                map: {value: null},
                useMap: {value: 0},
                alphaMap: {value: null},
                useAlphaMap: {value: 0},
                color: {value: new a.Color(16777215)},
                opacity: {value: 1},
                resolution: {value: new a.Vector2(1, 1)},
                sizeAttenuation: {value: 1},
                near: {value: 1},
                far: {value: 1},
                dashArray: {value: 0},
                dashOffset: {value: 0},
                dashRatio: {value: .5},
                useDash: {value: 0},
                visibility: {value: 1},
                alphaTest: {value: 0},
                repeat: {value: new a.Vector2(1, 1)},
                offset: {value: new a.Vector2(1, 1)}
            }), vertexShader: a.ShaderChunk.meshline_vert, fragmentShader: a.ShaderChunk.meshline_frag
        }), this.type = "MeshLineMaterial", Object.defineProperties(this, {
            lineWidth: {
                enumerable: !0, get: function () {
                    return this.uniforms.lineWidth.value
                }, set: function (t) {
                    this.uniforms.lineWidth.value = t
                }
            }, map: {
                enumerable: !0, get: function () {
                    return this.uniforms.map.value
                }, set: function (t) {
                    this.uniforms.map.value = t
                }
            }, useMap: {
                enumerable: !0, get: function () {
                    return this.uniforms.useMap.value
                }, set: function (t) {
                    this.uniforms.useMap.value = t
                }
            }, alphaMap: {
                enumerable: !0, get: function () {
                    return this.uniforms.alphaMap.value
                }, set: function (t) {
                    this.uniforms.alphaMap.value = t
                }
            }, useAlphaMap: {
                enumerable: !0, get: function () {
                    return this.uniforms.useAlphaMap.value
                }, set: function (t) {
                    this.uniforms.useAlphaMap.value = t
                }
            }, color: {
                enumerable: !0, get: function () {
                    return this.uniforms.color.value
                }, set: function (t) {
                    this.uniforms.color.value = t
                }
            }, opacity: {
                enumerable: !0, get: function () {
                    return this.uniforms.opacity.value
                }, set: function (t) {
                    this.uniforms.opacity.value = t
                }
            }, resolution: {
                enumerable: !0, get: function () {
                    return this.uniforms.resolution.value
                }, set: function (t) {
                    this.uniforms.resolution.value.copy(t)
                }
            }, sizeAttenuation: {
                enumerable: !0, get: function () {
                    return this.uniforms.sizeAttenuation.value
                }, set: function (t) {
                    this.uniforms.sizeAttenuation.value = t
                }
            }, near: {
                enumerable: !0, get: function () {
                    return this.uniforms.near.value
                }, set: function (t) {
                    this.uniforms.near.value = t
                }
            }, far: {
                enumerable: !0, get: function () {
                    return this.uniforms.far.value
                }, set: function (t) {
                    this.uniforms.far.value = t
                }
            }, dashArray: {
                enumerable: !0, get: function () {
                    return this.uniforms.dashArray.value
                }, set: function (t) {
                    this.uniforms.dashArray.value = t, this.useDash = 0 !== t ? 1 : 0
                }
            }, dashOffset: {
                enumerable: !0, get: function () {
                    return this.uniforms.dashOffset.value
                }, set: function (t) {
                    this.uniforms.dashOffset.value = t
                }
            }, dashRatio: {
                enumerable: !0, get: function () {
                    return this.uniforms.dashRatio.value
                }, set: function (t) {
                    this.uniforms.dashRatio.value = t
                }
            }, useDash: {
                enumerable: !0, get: function () {
                    return this.uniforms.useDash.value
                }, set: function (t) {
                    this.uniforms.useDash.value = t
                }
            }, visibility: {
                enumerable: !0, get: function () {
                    return this.uniforms.visibility.value
                }, set: function (t) {
                    this.uniforms.visibility.value = t
                }
            }, alphaTest: {
                enumerable: !0, get: function () {
                    return this.uniforms.alphaTest.value
                }, set: function (t) {
                    this.uniforms.alphaTest.value = t
                }
            }, repeat: {
                enumerable: !0, get: function () {
                    return this.uniforms.repeat.value
                }, set: function (t) {
                    this.uniforms.repeat.value.copy(t)
                }
            }, offset: {
                enumerable: !0, get: function () {
                    return this.uniforms.offset.value
                }, set: function (t) {
                    this.uniforms.offset.value.copy(t)
                }
            }
        }), this.setValues(t)
    }

    var n = this, r = "undefined" != typeof require, a = n.THREE || r && require("three");
    if (!a) throw new Error("MeshLine requires three.js");
    t.prototype.setMatrixWorld = function (t) {
        this.matrixWorld = t
    }, t.prototype.setGeometry = function (t, e) {
        if (this.widthCallback = e, this.positions = [], this.counters = [], t instanceof a.Geometry) for (var i = 0; i < t.vertices.length; i++) {
            var n = t.vertices[i], e = i / t.vertices.length;
            this.positions.push(n.x, n.y, n.z), this.positions.push(n.x, n.y, n.z), this.counters.push(e), this.counters.push(e)
        }
        if (a.BufferGeometry, t instanceof Float32Array || t instanceof Array) for (var i = 0; i < t.length; i += 3) {
            var e = i / t.length;
            this.positions.push(t[i], t[i + 1], t[i + 2]), this.positions.push(t[i], t[i + 1], t[i + 2]), this.counters.push(e), this.counters.push(e)
        }
        this.process()
    }, t.prototype.raycast = function () {
        var t = new a.Matrix4, e = new a.Ray, i = new a.Sphere;
        return function n(r, o) {
            var s = r.linePrecision, l = s * s, c = this.geometry;
            if (null === c.boundingSphere && c.computeBoundingSphere(), i.copy(c.boundingSphere), i.applyMatrix4(this.matrixWorld), r.ray.intersectSphere(i) !== !1) {
                t.getInverse(this.matrixWorld), e.copy(r.ray).applyMatrix4(t);
                var h = new a.Vector3, u = new a.Vector3, p = new a.Vector3, d = new a.Vector3,
                    f = this instanceof a.LineSegments ? 2 : 1;
                if (c instanceof a.BufferGeometry) {
                    var m = c.index, g = c.attributes;
                    if (null !== m) for (var v = m.array, y = g.position.array, x = 0, _ = v.length - 1; x < _; x += f) {
                        var b = v[x], w = v[x + 1];
                        h.fromArray(y, 3 * b), u.fromArray(y, 3 * w);
                        var M = e.distanceSqToSegment(h, u, d, p);
                        if (!(M > l)) {
                            d.applyMatrix4(this.matrixWorld);
                            var T = r.ray.origin.distanceTo(d);
                            T < r.near || T > r.far || o.push({
                                distance: T,
                                point: p.clone().applyMatrix4(this.matrixWorld),
                                index: x,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    } else for (var y = g.position.array, x = 0, _ = y.length / 3 - 1; x < _; x += f) {
                        h.fromArray(y, 3 * x), u.fromArray(y, 3 * x + 3);
                        var M = e.distanceSqToSegment(h, u, d, p);
                        if (!(M > l)) {
                            d.applyMatrix4(this.matrixWorld);
                            var T = r.ray.origin.distanceTo(d);
                            T < r.near || T > r.far || o.push({
                                distance: T,
                                point: p.clone().applyMatrix4(this.matrixWorld),
                                index: x,
                                face: null,
                                faceIndex: null,
                                object: this
                            })
                        }
                    }
                } else if (c instanceof a.Geometry) for (var S = c.vertices, E = S.length, x = 0; x < E - 1; x += f) {
                    var M = e.distanceSqToSegment(S[x], S[x + 1], d, p);
                    if (!(M > l)) {
                        d.applyMatrix4(this.matrixWorld);
                        var T = r.ray.origin.distanceTo(d);
                        T < r.near || T > r.far || o.push({
                            distance: T,
                            point: p.clone().applyMatrix4(this.matrixWorld),
                            index: x,
                            face: null,
                            faceIndex: null,
                            object: this
                        })
                    }
                }
            }
        }
    }(), t.prototype.compareV3 = function (t, e) {
        var i = 6 * t, n = 6 * e;
        return this.positions[i] === this.positions[n] && this.positions[i + 1] === this.positions[n + 1] && this.positions[i + 2] === this.positions[n + 2]
    }, t.prototype.copyV3 = function (t) {
        var e = 6 * t;
        return [this.positions[e], this.positions[e + 1], this.positions[e + 2]]
    }, t.prototype.process = function () {
        var t = this.positions.length / 6;
        this.previous = [], this.next = [], this.side = [], this.width = [], this.indices_array = [], this.uvs = [];
        for (var e = 0; e < t; e++) this.side.push(1), this.side.push(-1);
        for (var i, e = 0; e < t; e++) i = this.widthCallback ? this.widthCallback(e / (t - 1)) : 1, this.width.push(i), this.width.push(i);
        for (var e = 0; e < t; e++) this.uvs.push(e / (t - 1), 0), this.uvs.push(e / (t - 1), 1);
        var n;
        n = this.compareV3(0, t - 1) ? this.copyV3(t - 2) : this.copyV3(0), this.previous.push(n[0], n[1], n[2]), this.previous.push(n[0], n[1], n[2]);
        for (var e = 0; e < t - 1; e++) n = this.copyV3(e), this.previous.push(n[0], n[1], n[2]), this.previous.push(n[0], n[1], n[2]);
        for (var e = 1; e < t; e++) n = this.copyV3(e), this.next.push(n[0], n[1], n[2]), this.next.push(n[0], n[1], n[2]);
        n = this.compareV3(t - 1, 0) ? this.copyV3(1) : this.copyV3(t - 1), this.next.push(n[0], n[1], n[2]), this.next.push(n[0], n[1], n[2]);
        for (var e = 0; e < t - 1; e++) {
            var r = 2 * e;
            this.indices_array.push(r, r + 1, r + 2), this.indices_array.push(r + 2, r + 1, r + 3)
        }
        this.attributes ? (this.attributes.position.copyArray(new Float32Array(this.positions)), this.attributes.position.needsUpdate = !0, this.attributes.previous.copyArray(new Float32Array(this.previous)), this.attributes.previous.needsUpdate = !0, this.attributes.next.copyArray(new Float32Array(this.next)), this.attributes.next.needsUpdate = !0, this.attributes.side.copyArray(new Float32Array(this.side)), this.attributes.side.needsUpdate = !0, this.attributes.width.copyArray(new Float32Array(this.width)), this.attributes.width.needsUpdate = !0, this.attributes.uv.copyArray(new Float32Array(this.uvs)), this.attributes.uv.needsUpdate = !0, this.attributes.index.copyArray(new Uint16Array(this.indices_array)), this.attributes.index.needsUpdate = !0) : this.attributes = {
            position: new a.BufferAttribute(new Float32Array(this.positions), 3),
            previous: new a.BufferAttribute(new Float32Array(this.previous), 3),
            next: new a.BufferAttribute(new Float32Array(this.next), 3),
            side: new a.BufferAttribute(new Float32Array(this.side), 1),
            width: new a.BufferAttribute(new Float32Array(this.width), 1),
            uv: new a.BufferAttribute(new Float32Array(this.uvs), 2),
            index: new a.BufferAttribute(new Uint16Array(this.indices_array), 1),
            counters: new a.BufferAttribute(new Float32Array(this.counters), 1)
        }, this.geometry.addAttribute("position", this.attributes.position), this.geometry.addAttribute("previous", this.attributes.previous), this.geometry.addAttribute("next", this.attributes.next), this.geometry.addAttribute("side", this.attributes.side), this.geometry.addAttribute("width", this.attributes.width), this.geometry.addAttribute("uv", this.attributes.uv), this.geometry.addAttribute("counters", this.attributes.counters), this.geometry.setIndex(this.attributes.index)
    }, t.prototype.advance = function (t) {
        var i = this.attributes.position.array, n = this.attributes.previous.array, r = this.attributes.next.array,
            a = i.length;
        e(i, 0, n, 0, a), e(i, 6, i, 0, a - 6), i[a - 6] = t.x, i[a - 5] = t.y, i[a - 4] = t.z, i[a - 3] = t.x, i[a - 2] = t.y, i[a - 1] = t.z, e(i, 6, r, 0, a - 6), r[a - 6] = t.x, r[a - 5] = t.y, r[a - 4] = t.z, r[a - 3] = t.x, r[a - 2] = t.y, r[a - 1] = t.z, this.attributes.position.needsUpdate = !0, this.attributes.previous.needsUpdate = !0, this.attributes.next.needsUpdate = !0
    }, a.ShaderChunk.meshline_vert = ["", a.ShaderChunk.logdepthbuf_pars_vertex, a.ShaderChunk.fog_pars_vertex, "", "attribute vec3 previous;", "attribute vec3 next;", "attribute float side;", "attribute float width;", "attribute float counters;", "", "uniform vec2 resolution;", "uniform float lineWidth;", "uniform vec3 color;", "uniform float opacity;", "uniform float near;", "uniform float far;", "uniform float sizeAttenuation;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying float vCounters;", "", "vec2 fix( vec4 i, float aspect ) {", "", "    vec2 res = i.xy / i.w;", "    res.x *= aspect;", "\t vCounters = counters;", "    return res;", "", "}", "", "void main() {", "", "    float aspect = resolution.x / resolution.y;", "    float pixelWidthRatio = 1. / (resolution.x * projectionMatrix[0][0]);", "", "    vColor = vec4( color, opacity );", "    vUV = uv;", "", "    mat4 m = projectionMatrix * modelViewMatrix;", "    vec4 finalPosition = m * vec4( position, 1.0 );", "    vec4 prevPos = m * vec4( previous, 1.0 );", "    vec4 nextPos = m * vec4( next, 1.0 );", "", "    vec2 currentP = fix( finalPosition, aspect );", "    vec2 prevP = fix( prevPos, aspect );", "    vec2 nextP = fix( nextPos, aspect );", "", "    float pixelWidth = finalPosition.w * pixelWidthRatio;", "    float w = 1.8 * pixelWidth * lineWidth * width;", "", "    if( sizeAttenuation == 1. ) {", "        w = 1.8 * lineWidth * width;", "    }", "", "    vec2 dir;", "    if( nextP == currentP ) dir = normalize( currentP - prevP );", "    else if( prevP == currentP ) dir = normalize( nextP - currentP );", "    else {", "        vec2 dir1 = normalize( currentP - prevP );", "        vec2 dir2 = normalize( nextP - currentP );", "        dir = normalize( dir1 + dir2 );", "", "        vec2 perp = vec2( -dir1.y, dir1.x );", "        vec2 miter = vec2( -dir.y, dir.x );", "        //w = clamp( w / dot( miter, perp ), 0., 4. * lineWidth * width );", "", "    }", "", "    //vec2 normal = ( cross( vec3( dir, 0. ), vec3( 0., 0., 1. ) ) ).xy;", "    vec2 normal = vec2( -dir.y, dir.x );", "    normal.x /= aspect;", "    normal *= .5 * w;", "", "    vec4 offset = vec4( normal * side, 0.0, 1.0 );", "    finalPosition.xy += offset.xy;", "", "    gl_Position = finalPosition;", "", a.ShaderChunk.logdepthbuf_vertex, a.ShaderChunk.fog_vertex && "    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );", a.ShaderChunk.fog_vertex, "}"].join("\r\n"), a.ShaderChunk.meshline_frag = ["", a.ShaderChunk.fog_pars_fragment, a.ShaderChunk.logdepthbuf_pars_fragment, "", "uniform sampler2D map;", "uniform sampler2D alphaMap;", "uniform float useMap;", "uniform float useAlphaMap;", "uniform float useDash;", "uniform float dashArray;", "uniform float dashOffset;", "uniform float dashRatio;", "uniform float visibility;", "uniform float alphaTest;", "uniform vec2 repeat;", "uniform vec2 offset;", "", "varying vec2 vUV;", "varying vec4 vColor;", "varying float vCounters;", "", "void main() {", "", a.ShaderChunk.logdepthbuf_fragment, "", "    vec4 c = vColor;", "    if( useMap == 1. ) c *= texture2D( map, vUV * repeat + offset );", "    if( useAlphaMap == 1. ) c.a *= texture2D( alphaMap, vUV * repeat + offset ).a;", "    if( c.a < alphaTest ) discard;", "    if( useDash == 1. ){", "        c.a *= ceil(mod(vCounters + dashOffset, dashArray) - (dashArray * dashRatio));", "    }", "    gl_FragColor = c;", "    gl_FragColor.a *= step(vCounters, visibility);", "", a.ShaderChunk.fog_fragment, "}"].join("\r\n"), i.prototype = Object.create(a.ShaderMaterial.prototype), i.prototype.constructor = i, i.prototype.isMeshLineMaterial = !0, i.prototype.copy = function (t) {
        return a.ShaderMaterial.prototype.copy.call(this, t), this.lineWidth = t.lineWidth, this.map = t.map, this.useMap = t.useMap, this.alphaMap = t.alphaMap, this.useAlphaMap = t.useAlphaMap, this.color.copy(t.color), this.opacity = t.opacity, this.resolution.copy(t.resolution), this.sizeAttenuation = t.sizeAttenuation, this.near = t.near, this.far = t.far, this.dashArray.copy(t.dashArray), this.dashOffset.copy(t.dashOffset), this.dashRatio.copy(t.dashRatio), this.useDash = t.useDash, this.visibility = t.visibility, this.alphaTest = t.alphaTest, this.repeat.copy(t.repeat), this.offset.copy(t.offset), this
    }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = {
        MeshLine: t,
        MeshLineMaterial: i
    }), exports.MeshLine = t, exports.MeshLineMaterial = i) : (n.MeshLine = t, n.MeshLineMaterial = i)
}.call(this);/*!
 * VERSION: 2.1.2
 * DATE: 2019-03-01
 * UPDATES AND DOCS AT: http://greensock.com
 *
 * Includes all of the following: TweenLite, TweenMax, TimelineLite, TimelineMax, EasePack, CSSPlugin, RoundPropsPlugin, BezierPlugin, AttrPlugin, DirectionalRotationPlugin
 *
 * @license Copyright (c) 2008-2019, GreenSock. All rights reserved.
 * This work is subject to the terms at http://greensock.com/standard-license or for
 * Club GreenSock members, the software agreement that was issued with your membership.
 *
 * @author: Jack Doyle, jack@greensock.com
 **/
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function () {
    "use strict";
    _gsScope._gsDefine("TweenMax", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
        var n = function (t) {
            var e, i = [], n = t.length;
            for (e = 0; e !== n; i.push(t[e++])) ;
            return i
        }, r = function (t, e, i) {
            var n, r, a = t.cycle;
            for (n in a) r = a[n], t[n] = "function" == typeof r ? r(i, e[i], e) : r[i % r.length];
            delete t.cycle
        }, a = function (t) {
            if ("function" == typeof t) return t;
            var e = "object" == typeof t ? t : {each: t}, i = e.ease, n = e.from || 0, r = e.base || 0, a = {},
                o = isNaN(n), s = e.axis, l = {center: .5, end: 1}[n] || 0;
            return function (t, c, h) {
                var u, p, d, f, m, g, v, y, x, _ = (h || e).length, b = a[_];
                if (!b) {
                    if (!(x = "auto" === e.grid ? 0 : (e.grid || [1 / 0])[0])) {
                        for (v = -(1 / 0); v < (v = h[x++].getBoundingClientRect().left) && _ > x;) ;
                        x--
                    }
                    for (b = a[_] = [], u = o ? Math.min(x, _) * l - .5 : n % x, p = o ? _ * l / x - .5 : n / x | 0, v = 0, y = 1 / 0, g = 0; _ > g; g++) d = g % x - u, f = p - (g / x | 0), b[g] = m = s ? Math.abs("y" === s ? f : d) : Math.sqrt(d * d + f * f), m > v && (v = m), y > m && (y = m);
                    b.max = v - y, b.min = y, b.v = _ = e.amount || e.each * (x > _ ? _ : s ? "y" === s ? _ / x : x : Math.max(x, _ / x)) || 0, b.b = 0 > _ ? r - _ : r
                }
                return _ = (b[t] - b.min) / b.max, b.b + (i ? i.getRatio(_) : _) * b.v
            }
        }, o = function (t, e, n) {
            i.call(this, t, e, n), this._cycle = 0, this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._repeat && this._uncache(!0), this.render = o.prototype.render
        }, s = 1e-8, l = i._internals, c = l.isSelector, h = l.isArray, u = o.prototype = i.to({}, .1, {}), p = [];
        o.version = "2.1.2", u.constructor = o, u.kill()._gc = !1, o.killTweensOf = o.killDelayedCallsTo = i.killTweensOf, o.getTweensOf = i.getTweensOf, o.lagSmoothing = i.lagSmoothing, o.ticker = i.ticker, o.render = i.render, o.distribute = a, u.invalidate = function () {
            return this._yoyo = this.vars.yoyo === !0 || !!this.vars.yoyoEase, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._yoyoEase = null, this._uncache(!0), i.prototype.invalidate.call(this)
        }, u.updateTo = function (t, e) {
            var n, r = this, a = r.ratio, o = r.vars.immediateRender || t.immediateRender;
            e && r._startTime < r._timeline._time && (r._startTime = r._timeline._time, r._uncache(!1), r._gc ? r._enabled(!0, !1) : r._timeline.insert(r, r._startTime - r._delay));
            for (n in t) r.vars[n] = t[n];
            if (r._initted || o) if (e) r._initted = !1, o && r.render(0, !0, !0); else if (r._gc && r._enabled(!0, !1), r._notifyPluginsOfEnabled && r._firstPT && i._onPluginEvent("_onDisable", r), r._time / r._duration > .998) {
                var s = r._totalTime;
                r.render(0, !0, !1), r._initted = !1, r.render(s, !0, !1)
            } else if (r._initted = !1, r._init(), r._time > 0 || o) for (var l, c = 1 / (1 - a), h = r._firstPT; h;) l = h.s + h.c, h.c *= c, h.s = l - h.c, h = h._next;
            return r
        }, u.render = function (t, e, n) {
            this._initted || 0 === this._duration && this.vars.repeat && this.invalidate();
            var r, a, o, c, h, u, p, d, f, m = this, g = m._dirty ? m.totalDuration() : m._totalDuration, v = m._time,
                y = m._totalTime, x = m._cycle, _ = m._duration, b = m._rawPrevTime;
            if (t >= g - s && t >= 0 ? (m._totalTime = g, m._cycle = m._repeat, m._yoyo && 0 != (1 & m._cycle) ? (m._time = 0, m.ratio = m._ease._calcEnd ? m._ease.getRatio(0) : 0) : (m._time = _, m.ratio = m._ease._calcEnd ? m._ease.getRatio(1) : 1), m._reversed || (r = !0, a = "onComplete", n = n || m._timeline.autoRemoveChildren), 0 === _ && (m._initted || !m.vars.lazy || n) && (m._startTime === m._timeline._duration && (t = 0), (0 > b || 0 >= t && t >= -s || b === s && "isPause" !== m.data) && b !== t && (n = !0, b > s && (a = "onReverseComplete")), m._rawPrevTime = d = !e || t || b === t ? t : s)) : s > t ? (m._totalTime = m._time = m._cycle = 0, m.ratio = m._ease._calcEnd ? m._ease.getRatio(0) : 0, (0 !== y || 0 === _ && b > 0) && (a = "onReverseComplete", r = m._reversed), t > -s ? t = 0 : 0 > t && (m._active = !1, 0 === _ && (m._initted || !m.vars.lazy || n) && (b >= 0 && (n = !0), m._rawPrevTime = d = !e || t || b === t ? t : s)), m._initted || (n = !0)) : (m._totalTime = m._time = t, 0 !== m._repeat && (c = _ + m._repeatDelay, m._cycle = m._totalTime / c >> 0, 0 !== m._cycle && m._cycle === m._totalTime / c && t >= y && m._cycle--, m._time = m._totalTime - m._cycle * c, m._yoyo && 0 != (1 & m._cycle) && (m._time = _ - m._time, (f = m._yoyoEase || m.vars.yoyoEase) && (m._yoyoEase || (f !== !0 || m._initted ? m._yoyoEase = f = f === !0 ? m._ease : f instanceof Ease ? f : Ease.map[f] : (f = m.vars.ease, m._yoyoEase = f = f ? f instanceof Ease ? f : "function" == typeof f ? new Ease(f, m.vars.easeParams) : Ease.map[f] || i.defaultEase : i.defaultEase)), m.ratio = f ? 1 - f.getRatio((_ - m._time) / _) : 0)), m._time > _ ? m._time = _ : m._time < 0 && (m._time = 0)), m._easeType && !f ? (h = m._time / _, u = m._easeType, p = m._easePower, (1 === u || 3 === u && h >= .5) && (h = 1 - h), 3 === u && (h *= 2), 1 === p ? h *= h : 2 === p ? h *= h * h : 3 === p ? h *= h * h * h : 4 === p && (h *= h * h * h * h), m.ratio = 1 === u ? 1 - h : 2 === u ? h : m._time / _ < .5 ? h / 2 : 1 - h / 2) : f || (m.ratio = m._ease.getRatio(m._time / _))), v === m._time && !n && x === m._cycle) return void (y !== m._totalTime && m._onUpdate && (e || m._callback("onUpdate")));
            if (!m._initted) {
                if (m._init(), !m._initted || m._gc) return;
                if (!n && m._firstPT && (m.vars.lazy !== !1 && m._duration || m.vars.lazy && !m._duration)) return m._time = v, m._totalTime = y, m._rawPrevTime = b, m._cycle = x, l.lazyTweens.push(m), void (m._lazy = [t, e]);
                !m._time || r || f ? r && this._ease._calcEnd && !f && (m.ratio = m._ease.getRatio(0 === m._time ? 0 : 1)) : m.ratio = m._ease.getRatio(m._time / _)
            }
            for (m._lazy !== !1 && (m._lazy = !1), m._active || !m._paused && m._time !== v && t >= 0 && (m._active = !0), 0 === y && (2 === m._initted && t > 0 && m._init(), m._startAt && (t >= 0 ? m._startAt.render(t, !0, n) : a || (a = "_dummyGS")), m.vars.onStart && (0 !== m._totalTime || 0 === _) && (e || m._callback("onStart"))), o = m._firstPT; o;) o.f ? o.t[o.p](o.c * m.ratio + o.s) : o.t[o.p] = o.c * m.ratio + o.s, o = o._next;
            m._onUpdate && (0 > t && m._startAt && m._startTime && m._startAt.render(t, !0, n), e || (m._totalTime !== y || a) && m._callback("onUpdate")), m._cycle !== x && (e || m._gc || m.vars.onRepeat && m._callback("onRepeat")), a && (!m._gc || n) && (0 > t && m._startAt && !m._onUpdate && m._startTime && m._startAt.render(t, !0, n), r && (m._timeline.autoRemoveChildren && m._enabled(!1, !1), m._active = !1), !e && m.vars[a] && m._callback(a), 0 === _ && m._rawPrevTime === s && d !== s && (m._rawPrevTime = 0))
        }, o.to = function (t, e, i) {
            return new o(t, e, i)
        }, o.from = function (t, e, i) {
            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new o(t, e, i)
        }, o.fromTo = function (t, e, i, n) {
            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new o(t, e, n)
        }, o.staggerTo = o.allTo = function (t, e, s, l, u, d, f) {
            var m, g, v, y, x = [], _ = a(s.stagger || l), b = s.cycle, w = (s.startAt || p).cycle;
            for (h(t) || ("string" == typeof t && (t = i.selector(t) || t), c(t) && (t = n(t))), t = t || [], m = t.length - 1, v = 0; m >= v; v++) {
                g = {};
                for (y in s) g[y] = s[y];
                if (b && (r(g, t, v), null != g.duration && (e = g.duration, delete g.duration)), w) {
                    w = g.startAt = {};
                    for (y in s.startAt) w[y] = s.startAt[y];
                    r(g.startAt, t, v)
                }
                g.delay = _(v, t[v], t) + (g.delay || 0), v === m && u && (g.onComplete = function () {
                    s.onComplete && s.onComplete.apply(s.onCompleteScope || this, arguments), u.apply(f || s.callbackScope || this, d || p)
                }), x[v] = new o(t[v], e, g)
            }
            return x
        }, o.staggerFrom = o.allFrom = function (t, e, i, n, r, a, s) {
            return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, o.staggerTo(t, e, i, n, r, a, s)
        }, o.staggerFromTo = o.allFromTo = function (t, e, i, n, r, a, s, l) {
            return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, o.staggerTo(t, e, n, r, a, s, l)
        }, o.delayedCall = function (t, e, i, n, r) {
            return new o(e, 0, {
                delay: t,
                onComplete: e,
                onCompleteParams: i,
                callbackScope: n,
                onReverseComplete: e,
                onReverseCompleteParams: i,
                immediateRender: !1,
                useFrames: r,
                overwrite: 0
            })
        }, o.set = function (t, e) {
            return new o(t, 0, e)
        }, o.isTweening = function (t) {
            return i.getTweensOf(t, !0).length > 0
        };
        var d = function (t, e) {
            for (var n = [], r = 0, a = t._first; a;) a instanceof i ? n[r++] = a : (e && (n[r++] = a), n = n.concat(d(a, e)), r = n.length), a = a._next;
            return n
        }, f = o.getAllTweens = function (e) {
            return d(t._rootTimeline, e).concat(d(t._rootFramesTimeline, e))
        };
        o.killAll = function (t, i, n, r) {
            null == i && (i = !0), null == n && (n = !0);
            var a, o, s, l = f(0 != r), c = l.length, h = i && n && r;
            for (s = 0; c > s; s++) o = l[s], (h || o instanceof e || (a = o.target === o.vars.onComplete) && n || i && !a) && (t ? o.totalTime(o._reversed ? 0 : o.totalDuration()) : o._enabled(!1, !1))
        }, o.killChildTweensOf = function (t, e) {
            if (null != t) {
                var r, a, s, u, p, d = l.tweenLookup;
                if ("string" == typeof t && (t = i.selector(t) || t), c(t) && (t = n(t)), h(t)) for (u = t.length; --u > -1;) o.killChildTweensOf(t[u], e); else {
                    r = [];
                    for (s in d) for (a = d[s].target.parentNode; a;) a === t && (r = r.concat(d[s].tweens)), a = a.parentNode;
                    for (p = r.length, u = 0; p > u; u++) e && r[u].totalTime(r[u].totalDuration()), r[u]._enabled(!1, !1)
                }
            }
        };
        var m = function (t, i, n, r) {
            i = i !== !1, n = n !== !1, r = r !== !1;
            for (var a, o, s = f(r), l = i && n && r, c = s.length; --c > -1;) o = s[c], (l || o instanceof e || (a = o.target === o.vars.onComplete) && n || i && !a) && o.paused(t)
        };
        return o.pauseAll = function (t, e, i) {
            m(!0, t, e, i)
        }, o.resumeAll = function (t, e, i) {
            m(!1, t, e, i)
        }, o.globalTimeScale = function (e) {
            var n = t._rootTimeline, r = i.ticker.time;
            return arguments.length ? (e = e || s, n._startTime = r - (r - n._startTime) * n._timeScale / e, n = t._rootFramesTimeline, r = i.ticker.frame, n._startTime = r - (r - n._startTime) * n._timeScale / e, n._timeScale = t._rootTimeline._timeScale = e, e) : n._timeScale
        }, u.progress = function (t, e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration()
        }, u.totalProgress = function (t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration()
        }, u.time = function (t, e) {
            if (!arguments.length) return this._time;
            this._dirty && this.totalDuration();
            var i = this._duration, n = this._cycle, r = n * (i + this._repeatDelay);
            return t > i && (t = i), this.totalTime(this._yoyo && 1 & n ? i - t + r : this._repeat ? t + r : t, e)
        }, u.duration = function (e) {
            return arguments.length ? t.prototype.duration.call(this, e) : this._duration
        }, u.totalDuration = function (t) {
            return arguments.length ? -1 === this._repeat ? this : this.duration((t - this._repeat * this._repeatDelay) / (this._repeat + 1)) : (this._dirty && (this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat, this._dirty = !1), this._totalDuration)
        }, u.repeat = function (t) {
            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, u.repeatDelay = function (t) {
            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, u.yoyo = function (t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, o
    }, !0), _gsScope._gsDefine("TimelineLite", ["core.Animation", "core.SimpleTimeline", "TweenLite"], function (t, e, i) {
        var n = function (t) {
                e.call(this, t);
                var i, n, r = this, a = r.vars;
                r._labels = {}, r.autoRemoveChildren = !!a.autoRemoveChildren, r.smoothChildTiming = !!a.smoothChildTiming, r._sortChildren = !0, r._onUpdate = a.onUpdate;
                for (n in a) i = a[n], l(i) && -1 !== i.join("").indexOf("{self}") && (a[n] = r._swapSelfInParams(i));
                l(a.tweens) && r.add(a.tweens, 0, a.align, a.stagger)
            }, r = 1e-8, a = i._internals, o = n._internals = {}, s = a.isSelector, l = a.isArray, c = a.lazyTweens,
            h = a.lazyRender, u = _gsScope._gsDefine.globals, p = function (t) {
                var e, i = {};
                for (e in t) i[e] = t[e];
                return i
            }, d = function (t, e, i) {
                var n, r, a = t.cycle;
                for (n in a) r = a[n], t[n] = "function" == typeof r ? r(i, e[i], e) : r[i % r.length];
                delete t.cycle
            }, f = o.pauseCallback = function () {
            }, m = function (t) {
                var e, i = [], n = t.length;
                for (e = 0; e !== n; i.push(t[e++])) ;
                return i
            }, g = function (t, e, i, n) {
                var r = "immediateRender";
                return r in e || (e[r] = !(i && i[r] === !1 || n)), e
            }, v = function (t) {
                if ("function" == typeof t) return t;
                var e = "object" == typeof t ? t : {each: t}, i = e.ease, n = e.from || 0, r = e.base || 0, a = {},
                    o = isNaN(n), s = e.axis, l = {center: .5, end: 1}[n] || 0;
                return function (t, c, h) {
                    var u, p, d, f, m, g, v, y, x, _ = (h || e).length, b = a[_];
                    if (!b) {
                        if (!(x = "auto" === e.grid ? 0 : (e.grid || [1 / 0])[0])) {
                            for (v = -(1 / 0); v < (v = h[x++].getBoundingClientRect().left) && _ > x;) ;
                            x--
                        }
                        for (b = a[_] = [], u = o ? Math.min(x, _) * l - .5 : n % x, p = o ? _ * l / x - .5 : n / x | 0, v = 0, y = 1 / 0, g = 0; _ > g; g++) d = g % x - u, f = p - (g / x | 0), b[g] = m = s ? Math.abs("y" === s ? f : d) : Math.sqrt(d * d + f * f), m > v && (v = m), y > m && (y = m);
                        b.max = v - y, b.min = y, b.v = _ = e.amount || e.each * (x > _ ? _ : s ? "y" === s ? _ / x : x : Math.max(x, _ / x)) || 0, b.b = 0 > _ ? r - _ : r
                    }
                    return _ = (b[t] - b.min) / b.max, b.b + (i ? i.getRatio(_) : _) * b.v
                }
            }, y = n.prototype = new e;
        return n.version = "2.1.2", n.distribute = v, y.constructor = n, y.kill()._gc = y._forcingPlayhead = y._hasPause = !1, y.to = function (t, e, n, r) {
            var a = n.repeat && u.TweenMax || i;
            return e ? this.add(new a(t, e, n), r) : this.set(t, n, r)
        }, y.from = function (t, e, n, r) {
            return this.add((n.repeat && u.TweenMax || i).from(t, e, g(this, n)), r)
        }, y.fromTo = function (t, e, n, r, a) {
            var o = r.repeat && u.TweenMax || i;
            return r = g(this, r, n), e ? this.add(o.fromTo(t, e, n, r), a) : this.set(t, r, a)
        }, y.staggerTo = function (t, e, r, a, o, l, c, h) {
            var u, f, g = new n({
                onComplete: l,
                onCompleteParams: c,
                callbackScope: h,
                smoothChildTiming: this.smoothChildTiming
            }), y = v(r.stagger || a), x = r.startAt, _ = r.cycle;
            for ("string" == typeof t && (t = i.selector(t) || t), t = t || [], s(t) && (t = m(t)), f = 0; f < t.length; f++) u = p(r), x && (u.startAt = p(x), x.cycle && d(u.startAt, t, f)), _ && (d(u, t, f), null != u.duration && (e = u.duration, delete u.duration)), g.to(t[f], e, u, y(f, t[f], t));
            return this.add(g, o)
        }, y.staggerFrom = function (t, e, i, n, r, a, o, s) {
            return i.runBackwards = !0, this.staggerTo(t, e, g(this, i), n, r, a, o, s)
        }, y.staggerFromTo = function (t, e, i, n, r, a, o, s, l) {
            return n.startAt = i, this.staggerTo(t, e, g(this, n, i), r, a, o, s, l)
        }, y.call = function (t, e, n, r) {
            return this.add(i.delayedCall(0, t, e, n), r)
        }, y.set = function (t, e, n) {
            return this.add(new i(t, 0, g(this, e, null, !0)), n)
        }, n.exportRoot = function (t, e) {
            t = t || {}, null == t.smoothChildTiming && (t.smoothChildTiming = !0);
            var r, a, o, s, l = new n(t), c = l._timeline;
            for (null == e && (e = !0), c._remove(l, !0), l._startTime = 0, l._rawPrevTime = l._time = l._totalTime = c._time, o = c._first; o;) s = o._next, e && o instanceof i && o.target === o.vars.onComplete || (a = o._startTime - o._delay, 0 > a && (r = 1), l.add(o, a)), o = s;
            return c.add(l, 0), r && l.totalDuration(), l
        }, y.add = function (r, a, o, s) {
            var c, h, u, p, d, f, m = this;
            if ("number" != typeof a && (a = m._parseTimeOrLabel(a, 0, !0, r)), !(r instanceof t)) {
                if (r instanceof Array || r && r.push && l(r)) {
                    for (o = o || "normal", s = s || 0, c = a, h = r.length, u = 0; h > u; u++) l(p = r[u]) && (p = new n({tweens: p})), m.add(p, c), "string" != typeof p && "function" != typeof p && ("sequence" === o ? c = p._startTime + p.totalDuration() / p._timeScale : "start" === o && (p._startTime -= p.delay())), c += s;
                    return m._uncache(!0)
                }
                if ("string" == typeof r) return m.addLabel(r, a);
                if ("function" != typeof r) throw"Cannot add " + r + " into the timeline; it is not a tween, timeline, function, or string.";
                r = i.delayedCall(0, r)
            }
            if (e.prototype.add.call(m, r, a), (r._time || !r._duration && r._initted) && (c = (m.rawTime() - r._startTime) * r._timeScale, (!r._duration || Math.abs(Math.max(0, Math.min(r.totalDuration(), c))) - r._totalTime > 1e-5) && r.render(c, !1, !1)), (m._gc || m._time === m._duration) && !m._paused && m._duration < m.duration()) for (d = m, f = d.rawTime() > r._startTime; d._timeline;) f && d._timeline.smoothChildTiming ? d.totalTime(d._totalTime, !0) : d._gc && d._enabled(!0, !1), d = d._timeline;
            return m
        }, y.remove = function (e) {
            if (e instanceof t) {
                this._remove(e, !1);
                var i = e._timeline = e.vars.useFrames ? t._rootFramesTimeline : t._rootTimeline;
                return e._startTime = (e._paused ? e._pauseTime : i._time) - (e._reversed ? e.totalDuration() - e._totalTime : e._totalTime) / e._timeScale, this
            }
            if (e instanceof Array || e && e.push && l(e)) {
                for (var n = e.length; --n > -1;) this.remove(e[n]);
                return this
            }
            return "string" == typeof e ? this.removeLabel(e) : this.kill(null, e)
        }, y._remove = function (t, i) {
            return e.prototype._remove.call(this, t, i), this._last ? this._time > this.duration() && (this._time = this._duration, this._totalTime = this._totalDuration) : this._time = this._totalTime = this._duration = this._totalDuration = 0, this
        }, y.append = function (t, e) {
            return this.add(t, this._parseTimeOrLabel(null, e, !0, t))
        }, y.insert = y.insertMultiple = function (t, e, i, n) {
            return this.add(t, e || 0, i, n)
        }, y.appendMultiple = function (t, e, i, n) {
            return this.add(t, this._parseTimeOrLabel(null, e, !0, t), i, n)
        }, y.addLabel = function (t, e) {
            return this._labels[t] = this._parseTimeOrLabel(e), this
        }, y.addPause = function (t, e, n, r) {
            var a = i.delayedCall(0, f, n, r || this);
            return a.vars.onComplete = a.vars.onReverseComplete = e, a.data = "isPause", this._hasPause = !0, this.add(a, t)
        }, y.removeLabel = function (t) {
            return delete this._labels[t], this
        }, y.getLabelTime = function (t) {
            return null != this._labels[t] ? this._labels[t] : -1
        }, y._parseTimeOrLabel = function (e, i, n, r) {
            var a, o;
            if (r instanceof t && r.timeline === this) this.remove(r); else if (r && (r instanceof Array || r.push && l(r))) for (o = r.length; --o > -1;) r[o] instanceof t && r[o].timeline === this && this.remove(r[o]);
            if (a = "number" != typeof e || i ? this.duration() > 99999999999 ? this.recent().endTime(!1) : this._duration : 0, "string" == typeof i) return this._parseTimeOrLabel(i, n && "number" == typeof e && null == this._labels[i] ? e - a : 0, n);
            if (i = i || 0, "string" != typeof e || !isNaN(e) && null == this._labels[e]) null == e && (e = a); else {
                if (-1 === (o = e.indexOf("="))) return null == this._labels[e] ? n ? this._labels[e] = a + i : i : this._labels[e] + i;
                i = parseInt(e.charAt(o - 1) + "1", 10) * Number(e.substr(o + 1)), e = o > 1 ? this._parseTimeOrLabel(e.substr(0, o - 1), 0, n) : a
            }
            return Number(e) + i
        }, y.seek = function (t, e) {
            return this.totalTime("number" == typeof t ? t : this._parseTimeOrLabel(t), e !== !1)
        }, y.stop = function () {
            return this.paused(!0)
        }, y.gotoAndPlay = function (t, e) {
            return this.play(t, e)
        }, y.gotoAndStop = function (t, e) {
            return this.pause(t, e)
        }, y.render = function (t, e, i) {
            this._gc && this._enabled(!0, !1);
            var n, a, o, s, l, u, p, d, f = this, m = f._time, g = f._dirty ? f.totalDuration() : f._totalDuration,
                v = f._startTime, y = f._timeScale, x = f._paused;
            if (m !== f._time && (t += f._time - m), t >= g - r && t >= 0) f._totalTime = f._time = g, f._reversed || f._hasPausedChild() || (a = !0, s = "onComplete", l = !!f._timeline.autoRemoveChildren, 0 === f._duration && (0 >= t && t >= -r || f._rawPrevTime < 0 || f._rawPrevTime === r) && f._rawPrevTime !== t && f._first && (l = !0, f._rawPrevTime > r && (s = "onReverseComplete"))), f._rawPrevTime = f._duration || !e || t || f._rawPrevTime === t ? t : r, t = g + 1e-4; else if (r > t) if (f._totalTime = f._time = 0, t > -r && (t = 0), (0 !== m || 0 === f._duration && f._rawPrevTime !== r && (f._rawPrevTime > 0 || 0 > t && f._rawPrevTime >= 0)) && (s = "onReverseComplete", a = f._reversed), 0 > t) f._active = !1, f._timeline.autoRemoveChildren && f._reversed ? (l = a = !0, s = "onReverseComplete") : f._rawPrevTime >= 0 && f._first && (l = !0), f._rawPrevTime = t; else {
                if (f._rawPrevTime = f._duration || !e || t || f._rawPrevTime === t ? t : r, 0 === t && a) for (n = f._first; n && 0 === n._startTime;) n._duration || (a = !1), n = n._next;
                t = 0, f._initted || (l = !0)
            } else {
                if (f._hasPause && !f._forcingPlayhead && !e) {
                    if (t >= m) for (n = f._first; n && n._startTime <= t && !u;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === f._rawPrevTime || (u = n), n = n._next; else for (n = f._last; n && n._startTime >= t && !u;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (u = n), n = n._prev;
                    u && (f._time = f._totalTime = t = u._startTime, d = f._startTime + t / f._timeScale)
                }
                f._totalTime = f._time = f._rawPrevTime = t
            }
            if (f._time !== m && f._first || i || l || u) {
                if (f._initted || (f._initted = !0), f._active || !f._paused && f._time !== m && t > 0 && (f._active = !0), 0 === m && f.vars.onStart && (0 === f._time && f._duration || e || f._callback("onStart")), (p = f._time) >= m) for (n = f._first; n && (o = n._next, p === f._time && (!f._paused || x));) (n._active || n._startTime <= p && !n._paused && !n._gc) && (u === n && (f.pause(), f._pauseTime = d), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = o; else for (n = f._last; n && (o = n._prev, p === f._time && (!f._paused || x));) {
                    if (n._active || n._startTime <= m && !n._paused && !n._gc) {
                        if (u === n) {
                            for (u = n._prev; u && u.endTime() > f._time;) u.render(u._reversed ? u.totalDuration() - (t - u._startTime) * u._timeScale : (t - u._startTime) * u._timeScale, e, i), u = u._prev;
                            u = null, f.pause(), f._pauseTime = d
                        }
                        n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                    }
                    n = o
                }
                f._onUpdate && (e || (c.length && h(), f._callback("onUpdate"))), s && (f._gc || (v === f._startTime || y !== f._timeScale) && (0 === f._time || g >= f.totalDuration()) && (a && (c.length && h(), f._timeline.autoRemoveChildren && f._enabled(!1, !1), f._active = !1), !e && f.vars[s] && f._callback(s)))
            }
        }, y._hasPausedChild = function () {
            for (var t = this._first; t;) {
                if (t._paused || t instanceof n && t._hasPausedChild()) return !0;
                t = t._next
            }
            return !1
        }, y.getChildren = function (t, e, n, r) {
            r = r || -9999999999;
            for (var a = [], o = this._first, s = 0; o;) o._startTime < r || (o instanceof i ? e !== !1 && (a[s++] = o) : (n !== !1 && (a[s++] = o), t !== !1 && (a = a.concat(o.getChildren(!0, e, n)), s = a.length))), o = o._next;
            return a
        }, y.getTweensOf = function (t, e) {
            var n, r, a = this._gc, o = [], s = 0;
            for (a && this._enabled(!0, !0), n = i.getTweensOf(t), r = n.length; --r > -1;) (n[r].timeline === this || e && this._contains(n[r])) && (o[s++] = n[r]);
            return a && this._enabled(!1, !0), o
        }, y.recent = function () {
            return this._recent
        }, y._contains = function (t) {
            for (var e = t.timeline; e;) {
                if (e === this) return !0;
                e = e.timeline
            }
            return !1
        }, y.shiftChildren = function (t, e, i) {
            i = i || 0;
            for (var n, r = this._first, a = this._labels; r;) r._startTime >= i && (r._startTime += t), r = r._next;
            if (e) for (n in a) a[n] >= i && (a[n] += t);
            return this._uncache(!0)
        }, y._kill = function (t, e) {
            if (!t && !e) return this._enabled(!1, !1);
            for (var i = e ? this.getTweensOf(e) : this.getChildren(!0, !0, !1), n = i.length, r = !1; --n > -1;) i[n]._kill(t, e) && (r = !0);
            return r
        }, y.clear = function (t) {
            var e = this.getChildren(!1, !0, !0), i = e.length;
            for (this._time = this._totalTime = 0; --i > -1;) e[i]._enabled(!1, !1);
            return t !== !1 && (this._labels = {}), this._uncache(!0)
        }, y.invalidate = function () {
            for (var e = this._first; e;) e.invalidate(), e = e._next;
            return t.prototype.invalidate.call(this)
        }, y._enabled = function (t, i) {
            if (t === this._gc) for (var n = this._first; n;) n._enabled(t, !0), n = n._next;
            return e.prototype._enabled.call(this, t, i)
        }, y.totalTime = function (e, i, n) {
            this._forcingPlayhead = !0;
            var r = t.prototype.totalTime.apply(this, arguments);
            return this._forcingPlayhead = !1, r
        }, y.duration = function (t) {
            return arguments.length ? (0 !== this.duration() && 0 !== t && this.timeScale(this._duration / t), this) : (this._dirty && this.totalDuration(), this._duration)
        }, y.totalDuration = function (t) {
            if (!arguments.length) {
                if (this._dirty) {
                    for (var e, i, n = 0, r = this, a = r._last, o = 999999999999; a;) e = a._prev, a._dirty && a.totalDuration(), a._startTime > o && r._sortChildren && !a._paused && !r._calculatingDuration ? (r._calculatingDuration = 1, r.add(a, a._startTime - a._delay), r._calculatingDuration = 0) : o = a._startTime, a._startTime < 0 && !a._paused && (n -= a._startTime, r._timeline.smoothChildTiming && (r._startTime += a._startTime / r._timeScale, r._time -= a._startTime, r._totalTime -= a._startTime, r._rawPrevTime -= a._startTime), r.shiftChildren(-a._startTime, !1, -9999999999), o = 0), i = a._startTime + a._totalDuration / a._timeScale, i > n && (n = i), a = e;
                    r._duration = r._totalDuration = n, r._dirty = !1
                }
                return this._totalDuration
            }
            return t && this.totalDuration() ? this.timeScale(this._totalDuration / t) : this
        }, y.paused = function (e) {
            if (e === !1 && this._paused) for (var i = this._first; i;) i._startTime === this._time && "isPause" === i.data && (i._rawPrevTime = 0), i = i._next;
            return t.prototype.paused.apply(this, arguments)
        }, y.usesFrames = function () {
            for (var e = this._timeline; e._timeline;) e = e._timeline;
            return e === t._rootFramesTimeline
        }, y.rawTime = function (t) {
            return t && (this._paused || this._repeat && this.time() > 0 && this.totalProgress() < 1) ? this._totalTime % (this._duration + this._repeatDelay) : this._paused ? this._totalTime : (this._timeline.rawTime(t) - this._startTime) * this._timeScale
        }, n
    }, !0), _gsScope._gsDefine("TimelineMax", ["TimelineLite", "TweenLite", "easing.Ease"], function (t, e, i) {
        var n = function (e) {
                t.call(this, e), this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._cycle = 0, this._yoyo = !!this.vars.yoyo, this._dirty = !0
            }, r = 1e-8, a = e._internals, o = a.lazyTweens, s = a.lazyRender, l = _gsScope._gsDefine.globals,
            c = new i(null, null, 1, 0), h = n.prototype = new t;
        return h.constructor = n, h.kill()._gc = !1, n.version = "2.1.2", h.invalidate = function () {
            return this._yoyo = !!this.vars.yoyo, this._repeat = this.vars.repeat || 0, this._repeatDelay = this.vars.repeatDelay || 0, this._uncache(!0), t.prototype.invalidate.call(this)
        }, h.addCallback = function (t, i, n, r) {
            return this.add(e.delayedCall(0, t, n, r), i)
        }, h.removeCallback = function (t, e) {
            if (t) if (null == e) this._kill(null, t); else for (var i = this.getTweensOf(t, !1), n = i.length, r = this._parseTimeOrLabel(e); --n > -1;) i[n]._startTime === r && i[n]._enabled(!1, !1);
            return this
        }, h.removePause = function (e) {
            return this.removeCallback(t._internals.pauseCallback, e)
        }, h.tweenTo = function (t, i) {
            i = i || {};
            var n, r, a, o = {ease: c, useFrames: this.usesFrames(), immediateRender: !1, lazy: !1},
                s = i.repeat && l.TweenMax || e;
            for (r in i) o[r] = i[r];
            return o.time = this._parseTimeOrLabel(t), n = Math.abs(Number(o.time) - this._time) / this._timeScale || .001, a = new s(this, n, o), o.onStart = function () {
                a.target.paused(!0), a.vars.time === a.target.time() || n !== a.duration() || a.isFromTo || a.duration(Math.abs(a.vars.time - a.target.time()) / a.target._timeScale).render(a.time(), !0, !0), i.onStart && i.onStart.apply(i.onStartScope || i.callbackScope || a, i.onStartParams || [])
            }, a
        }, h.tweenFromTo = function (t, e, i) {
            i = i || {}, t = this._parseTimeOrLabel(t), i.startAt = {
                onComplete: this.seek,
                onCompleteParams: [t],
                callbackScope: this
            }, i.immediateRender = i.immediateRender !== !1;
            var n = this.tweenTo(e, i);
            return n.isFromTo = 1, n.duration(Math.abs(n.vars.time - t) / this._timeScale || .001)
        }, h.render = function (t, e, i) {
            this._gc && this._enabled(!0, !1);
            var n, a, l, c, h, u, p, d, f, m = this, g = m._time, v = m._dirty ? m.totalDuration() : m._totalDuration,
                y = m._duration, x = m._totalTime, _ = m._startTime, b = m._timeScale, w = m._rawPrevTime,
                M = m._paused, T = m._cycle;
            if (g !== m._time && (t += m._time - g), t >= v - r && t >= 0) m._locked || (m._totalTime = v, m._cycle = m._repeat), m._reversed || m._hasPausedChild() || (a = !0, c = "onComplete", h = !!m._timeline.autoRemoveChildren, 0 === m._duration && (0 >= t && t >= -r || 0 > w || w === r) && w !== t && m._first && (h = !0, w > r && (c = "onReverseComplete"))), m._rawPrevTime = m._duration || !e || t || m._rawPrevTime === t ? t : r, m._yoyo && 1 & m._cycle ? m._time = t = 0 : (m._time = y, t = y + 1e-4); else if (r > t) if (m._locked || (m._totalTime = m._cycle = 0), m._time = 0, t > -r && (t = 0), (0 !== g || 0 === y && w !== r && (w > 0 || 0 > t && w >= 0) && !m._locked) && (c = "onReverseComplete", a = m._reversed), 0 > t) m._active = !1, m._timeline.autoRemoveChildren && m._reversed ? (h = a = !0, c = "onReverseComplete") : w >= 0 && m._first && (h = !0), m._rawPrevTime = t; else {
                if (m._rawPrevTime = y || !e || t || m._rawPrevTime === t ? t : r, 0 === t && a) for (n = m._first; n && 0 === n._startTime;) n._duration || (a = !1), n = n._next;
                t = 0, m._initted || (h = !0)
            } else if (0 === y && 0 > w && (h = !0), m._time = m._rawPrevTime = t, m._locked || (m._totalTime = t, 0 !== m._repeat && (u = y + m._repeatDelay, m._cycle = m._totalTime / u >> 0, m._cycle && m._cycle === m._totalTime / u && t >= x && m._cycle--, m._time = m._totalTime - m._cycle * u, m._yoyo && 1 & m._cycle && (m._time = y - m._time), m._time > y ? (m._time = y, t = y + 1e-4) : m._time < 0 ? m._time = t = 0 : t = m._time)), m._hasPause && !m._forcingPlayhead && !e) {
                if ((t = m._time) >= g || m._repeat && T !== m._cycle) for (n = m._first; n && n._startTime <= t && !p;) n._duration || "isPause" !== n.data || n.ratio || 0 === n._startTime && 0 === m._rawPrevTime || (p = n), n = n._next; else for (n = m._last; n && n._startTime >= t && !p;) n._duration || "isPause" === n.data && n._rawPrevTime > 0 && (p = n), n = n._prev;
                p && (f = m._startTime + p._startTime / m._timeScale, p._startTime < y && (m._time = m._rawPrevTime = t = p._startTime, m._totalTime = t + m._cycle * (m._totalDuration + m._repeatDelay)))
            }
            if (m._cycle !== T && !m._locked) {
                var S = m._yoyo && 0 != (1 & T), E = S === (m._yoyo && 0 != (1 & m._cycle)), A = m._totalTime,
                    P = m._cycle, L = m._rawPrevTime, C = m._time;
                if (m._totalTime = T * y, m._cycle < T ? S = !S : m._totalTime += y, m._time = g, m._rawPrevTime = 0 === y ? w - 1e-4 : w, m._cycle = T, m._locked = !0, g = S ? 0 : y, m.render(g, e, 0 === y), e || m._gc || m.vars.onRepeat && (m._cycle = P, m._locked = !1, m._callback("onRepeat")), g !== m._time) return;
                if (E && (m._cycle = T, m._locked = !0, g = S ? y + 1e-4 : -1e-4, m.render(g, !0, !1)), m._locked = !1, m._paused && !M) return;
                m._time = C, m._totalTime = A, m._cycle = P, m._rawPrevTime = L
            }
            if (!(m._time !== g && m._first || i || h || p)) return void (x !== m._totalTime && m._onUpdate && (e || m._callback("onUpdate")));
            if (m._initted || (m._initted = !0), m._active || !m._paused && m._totalTime !== x && t > 0 && (m._active = !0), 0 === x && m.vars.onStart && (0 === m._totalTime && m._totalDuration || e || m._callback("onStart")), (d = m._time) >= g) for (n = m._first; n && (l = n._next, d === m._time && (!m._paused || M));) (n._active || n._startTime <= m._time && !n._paused && !n._gc) && (p === n && (m.pause(), m._pauseTime = f), n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)), n = l; else for (n = m._last; n && (l = n._prev, d === m._time && (!m._paused || M));) {
                if (n._active || n._startTime <= g && !n._paused && !n._gc) {
                    if (p === n) {
                        for (p = n._prev; p && p.endTime() > m._time;) p.render(p._reversed ? p.totalDuration() - (t - p._startTime) * p._timeScale : (t - p._startTime) * p._timeScale, e, i), p = p._prev;
                        p = null, m.pause(), m._pauseTime = f
                    }
                    n._reversed ? n.render((n._dirty ? n.totalDuration() : n._totalDuration) - (t - n._startTime) * n._timeScale, e, i) : n.render((t - n._startTime) * n._timeScale, e, i)
                }
                n = l
            }
            m._onUpdate && (e || (o.length && s(), m._callback("onUpdate"))), c && (m._locked || m._gc || (_ === m._startTime || b !== m._timeScale) && (0 === m._time || v >= m.totalDuration()) && (a && (o.length && s(), m._timeline.autoRemoveChildren && m._enabled(!1, !1), m._active = !1), !e && m.vars[c] && m._callback(c)))
        }, h.getActive = function (t, e, i) {
            var n, r, a = [], o = this.getChildren(t || null == t, e || null == t, !!i), s = 0, l = o.length;
            for (n = 0; l > n; n++) r = o[n], r.isActive() && (a[s++] = r);
            return a
        }, h.getLabelAfter = function (t) {
            t || 0 !== t && (t = this._time);
            var e, i = this.getLabelsArray(), n = i.length;
            for (e = 0; n > e; e++) if (i[e].time > t) return i[e].name;
            return null
        }, h.getLabelBefore = function (t) {
            null == t && (t = this._time);
            for (var e = this.getLabelsArray(), i = e.length; --i > -1;) if (e[i].time < t) return e[i].name;
            return null
        }, h.getLabelsArray = function () {
            var t, e = [], i = 0;
            for (t in this._labels) e[i++] = {time: this._labels[t], name: t};
            return e.sort(function (t, e) {
                return t.time - e.time
            }), e
        }, h.invalidate = function () {
            return this._locked = !1, t.prototype.invalidate.call(this)
        }, h.progress = function (t, e) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && 0 != (1 & this._cycle) ? 1 - t : t) + this._cycle * (this._duration + this._repeatDelay), e) : this._time / this.duration() || 0
        }, h.totalProgress = function (t, e) {
            return arguments.length ? this.totalTime(this.totalDuration() * t, e) : this._totalTime / this.totalDuration() || 0
        }, h.totalDuration = function (e) {
            return arguments.length ? -1 !== this._repeat && e ? this.timeScale(this.totalDuration() / e) : this : (this._dirty && (t.prototype.totalDuration.call(this), this._totalDuration = -1 === this._repeat ? 999999999999 : this._duration * (this._repeat + 1) + this._repeatDelay * this._repeat), this._totalDuration)
        }, h.time = function (t, e) {
            if (!arguments.length) return this._time;
            this._dirty && this.totalDuration();
            var i = this._duration, n = this._cycle, r = n * (i + this._repeatDelay);
            return t > i && (t = i), this.totalTime(this._yoyo && 1 & n ? i - t + r : this._repeat ? t + r : t, e)
        }, h.repeat = function (t) {
            return arguments.length ? (this._repeat = t, this._uncache(!0)) : this._repeat
        }, h.repeatDelay = function (t) {
            return arguments.length ? (this._repeatDelay = t, this._uncache(!0)) : this._repeatDelay
        }, h.yoyo = function (t) {
            return arguments.length ? (this._yoyo = t, this) : this._yoyo
        }, h.currentLabel = function (t) {
            return arguments.length ? this.seek(t, !0) : this.getLabelBefore(this._time + r)
        }, n
    }, !0), function () {
        var t = 180 / Math.PI, e = [], i = [], n = [], r = {}, a = _gsScope._gsDefine.globals,
            o = function (t, e, i, n) {
                i === n && (i = n - (n - e) / 1e6), t === e && (e = t + (i - t) / 1e6), this.a = t, this.b = e, this.c = i, this.d = n, this.da = n - t, this.ca = i - t, this.ba = e - t
            },
            s = ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,",
            l = function (t, e, i, n) {
                var r = {a: t}, a = {}, o = {}, s = {c: n}, l = (t + e) / 2, c = (e + i) / 2, h = (i + n) / 2,
                    u = (l + c) / 2, p = (c + h) / 2, d = (p - u) / 8;
                return r.b = l + (t - l) / 4, a.b = u + d, r.c = a.a = (r.b + a.b) / 2, a.c = o.a = (u + p) / 2, o.b = p - d, s.b = h + (n - h) / 4, o.c = s.a = (o.b + s.b) / 2, [r, a, o, s]
            }, c = function (t, r, a, o, s) {
                var c, h, u, p, d, f, m, g, v, y, x, _, b, w = t.length - 1, M = 0, T = t[0].a;
                for (c = 0; w > c; c++) d = t[M], h = d.a, u = d.d, p = t[M + 1].d, s ? (x = e[c], _ = i[c], b = (_ + x) * r * .25 / (o ? .5 : n[c] || .5), f = u - (u - h) * (o ? .5 * r : 0 !== x ? b / x : 0), m = u + (p - u) * (o ? .5 * r : 0 !== _ ? b / _ : 0), g = u - (f + ((m - f) * (3 * x / (x + _) + .5) / 4 || 0))) : (f = u - (u - h) * r * .5, m = u + (p - u) * r * .5, g = u - (f + m) / 2), f += g, m += g, d.c = v = f, d.b = 0 !== c ? T : T = d.a + .6 * (d.c - d.a), d.da = u - h, d.ca = v - h, d.ba = T - h, a ? (y = l(h, T, v, u), t.splice(M, 1, y[0], y[1], y[2], y[3]), M += 4) : M++, T = m;
                d = t[M], d.b = T, d.c = T + .4 * (d.d - T), d.da = d.d - d.a, d.ca = d.c - d.a, d.ba = T - d.a, a && (y = l(d.a, T, d.c, d.d), t.splice(M, 1, y[0], y[1], y[2], y[3]))
            }, h = function (t, n, r, a) {
                var s, l, c, h, u, p, d = [];
                if (a) for (t = [a].concat(t), l = t.length; --l > -1;) "string" == typeof (p = t[l][n]) && "=" === p.charAt(1) && (t[l][n] = a[n] + Number(p.charAt(0) + p.substr(2)));
                if (0 > (s = t.length - 2)) return d[0] = new o(t[0][n], 0, 0, t[0][n]), d;
                for (l = 0; s > l; l++) c = t[l][n], h = t[l + 1][n], d[l] = new o(c, 0, 0, h), r && (u = t[l + 2][n], e[l] = (e[l] || 0) + (h - c) * (h - c), i[l] = (i[l] || 0) + (u - h) * (u - h));
                return d[l] = new o(t[l][n], 0, 0, t[l + 1][n]), d
            }, u = function (t, a, o, s, l, u) {
                var p, d, f, m, g, v, y, x, _ = {}, b = [], w = u || t[0];
                l = "string" == typeof l ? "," + l + "," : ",x,y,z,left,top,right,bottom,marginTop,marginLeft,marginRight,marginBottom,paddingLeft,paddingTop,paddingRight,paddingBottom,backgroundPosition,backgroundPosition_y,", null == a && (a = 1);
                for (d in t[0]) b.push(d);
                if (t.length > 1) {
                    for (x = t[t.length - 1], y = !0, p = b.length; --p > -1;) if (d = b[p], Math.abs(w[d] - x[d]) > .05) {
                        y = !1;
                        break
                    }
                    y && (t = t.concat(), u && t.unshift(u), t.push(t[1]), u = t[t.length - 3])
                }
                for (e.length = i.length = n.length = 0, p = b.length; --p > -1;) d = b[p], r[d] = -1 !== l.indexOf("," + d + ","), _[d] = h(t, d, r[d], u);
                for (p = e.length; --p > -1;) e[p] = Math.sqrt(e[p]),
                    i[p] = Math.sqrt(i[p]);
                if (!s) {
                    for (p = b.length; --p > -1;) if (r[d]) for (f = _[b[p]], v = f.length - 1, m = 0; v > m; m++) g = f[m + 1].da / i[m] + f[m].da / e[m] || 0, n[m] = (n[m] || 0) + g * g;
                    for (p = n.length; --p > -1;) n[p] = Math.sqrt(n[p])
                }
                for (p = b.length, m = o ? 4 : 1; --p > -1;) d = b[p], f = _[d], c(f, a, o, s, r[d]), y && (f.splice(0, m), f.splice(f.length - m, m));
                return _
            }, p = function (t, e, i) {
                e = e || "soft";
                var n, r, a, s, l, c, h, u, p, d, f, m = {}, g = "cubic" === e ? 3 : 2, v = "soft" === e, y = [];
                if (v && i && (t = [i].concat(t)), null == t || t.length < g + 1) throw"invalid Bezier data";
                for (p in t[0]) y.push(p);
                for (c = y.length; --c > -1;) {
                    for (p = y[c], m[p] = l = [], d = 0, u = t.length, h = 0; u > h; h++) n = null == i ? t[h][p] : "string" == typeof (f = t[h][p]) && "=" === f.charAt(1) ? i[p] + Number(f.charAt(0) + f.substr(2)) : Number(f), v && h > 1 && u - 1 > h && (l[d++] = (n + l[d - 2]) / 2), l[d++] = n;
                    for (u = d - g + 1, d = 0, h = 0; u > h; h += g) n = l[h], r = l[h + 1], a = l[h + 2], s = 2 === g ? 0 : l[h + 3], l[d++] = f = 3 === g ? new o(n, r, a, s) : new o(n, (2 * r + n) / 3, (2 * r + a) / 3, a);
                    l.length = d
                }
                return m
            }, d = function (t, e, i) {
                for (var n, r, a, o, s, l, c, h, u, p, d, f = 1 / i, m = t.length; --m > -1;) for (p = t[m], a = p.a, o = p.d - a, s = p.c - a, l = p.b - a, n = r = 0, h = 1; i >= h; h++) c = f * h, u = 1 - c, n = r - (r = (c * c * o + 3 * u * (c * s + u * l)) * c), d = m * i + h - 1, e[d] = (e[d] || 0) + n * n
            }, f = function (t, e) {
                e = e >> 0 || 6;
                var i, n, r, a, o = [], s = [], l = 0, c = 0, h = e - 1, u = [], p = [];
                for (i in t) d(t[i], o, e);
                for (r = o.length, n = 0; r > n; n++) l += Math.sqrt(o[n]), a = n % e, p[a] = l, a === h && (c += l, a = n / e >> 0, u[a] = p, s[a] = c, l = 0, p = []);
                return {length: c, lengths: s, segments: u}
            }, m = _gsScope._gsDefine.plugin({
                propName: "bezier", priority: -1, version: "1.3.8", API: 2, global: !0, init: function (t, e, i) {
                    this._target = t, e instanceof Array && (e = {values: e}), this._func = {}, this._mod = {}, this._props = [], this._timeRes = null == e.timeResolution ? 6 : parseInt(e.timeResolution, 10);
                    var n, r, a, o, s, l = e.values || [], c = {}, h = l[0], d = e.autoRotate || i.vars.orientToBezier;
                    this._autoRotate = d ? d instanceof Array ? d : [["x", "y", "rotation", d === !0 ? 0 : Number(d) || 0]] : null;
                    for (n in h) this._props.push(n);
                    for (a = this._props.length; --a > -1;) n = this._props[a], this._overwriteProps.push(n), r = this._func[n] = "function" == typeof t[n], c[n] = r ? t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)]() : parseFloat(t[n]), s || c[n] !== l[0][n] && (s = c);
                    if (this._beziers = "cubic" !== e.type && "quadratic" !== e.type && "soft" !== e.type ? u(l, isNaN(e.curviness) ? 1 : e.curviness, !1, "thruBasic" === e.type, e.correlate, s) : p(l, e.type, c), this._segCount = this._beziers[n].length, this._timeRes) {
                        var m = f(this._beziers, this._timeRes);
                        this._length = m.length, this._lengths = m.lengths, this._segments = m.segments, this._l1 = this._li = this._s1 = this._si = 0, this._l2 = this._lengths[0], this._curSeg = this._segments[0], this._s2 = this._curSeg[0], this._prec = 1 / this._curSeg.length
                    }
                    if (d = this._autoRotate) for (this._initialRotations = [], d[0] instanceof Array || (this._autoRotate = d = [d]), a = d.length; --a > -1;) {
                        for (o = 0; 3 > o; o++) n = d[a][o], this._func[n] = "function" == typeof t[n] && t[n.indexOf("set") || "function" != typeof t["get" + n.substr(3)] ? n : "get" + n.substr(3)];
                        n = d[a][2], this._initialRotations[a] = (this._func[n] ? this._func[n].call(this._target) : this._target[n]) || 0, this._overwriteProps.push(n)
                    }
                    return this._startRatio = i.vars.runBackwards ? 1 : 0, !0
                }, set: function (e) {
                    var i, n, r, a, o, s, l, c, h, u, p = this._segCount, d = this._func, f = this._target,
                        m = e !== this._startRatio;
                    if (this._timeRes) {
                        if (h = this._lengths, u = this._curSeg, e *= this._length, r = this._li, e > this._l2 && p - 1 > r) {
                            for (c = p - 1; c > r && (this._l2 = h[++r]) <= e;) ;
                            this._l1 = h[r - 1], this._li = r, this._curSeg = u = this._segments[r], this._s2 = u[this._s1 = this._si = 0]
                        } else if (e < this._l1 && r > 0) {
                            for (; r > 0 && (this._l1 = h[--r]) >= e;) ;
                            0 === r && e < this._l1 ? this._l1 = 0 : r++, this._l2 = h[r], this._li = r, this._curSeg = u = this._segments[r], this._s1 = u[(this._si = u.length - 1) - 1] || 0, this._s2 = u[this._si]
                        }
                        if (i = r, e -= this._l1, r = this._si, e > this._s2 && r < u.length - 1) {
                            for (c = u.length - 1; c > r && (this._s2 = u[++r]) <= e;) ;
                            this._s1 = u[r - 1], this._si = r
                        } else if (e < this._s1 && r > 0) {
                            for (; r > 0 && (this._s1 = u[--r]) >= e;) ;
                            0 === r && e < this._s1 ? this._s1 = 0 : r++, this._s2 = u[r], this._si = r
                        }
                        s = (r + (e - this._s1) / (this._s2 - this._s1)) * this._prec || 0
                    } else i = 0 > e ? 0 : e >= 1 ? p - 1 : p * e >> 0, s = (e - i * (1 / p)) * p;
                    for (n = 1 - s, r = this._props.length; --r > -1;) a = this._props[r], o = this._beziers[a][i], l = (s * s * o.da + 3 * n * (s * o.ca + n * o.ba)) * s + o.a, this._mod[a] && (l = this._mod[a](l, f)), d[a] ? f[a](l) : f[a] = l;
                    if (this._autoRotate) {
                        var g, v, y, x, _, b, w, M = this._autoRotate;
                        for (r = M.length; --r > -1;) a = M[r][2], b = M[r][3] || 0, w = M[r][4] === !0 ? 1 : t, o = this._beziers[M[r][0]], g = this._beziers[M[r][1]], o && g && (o = o[i], g = g[i], v = o.a + (o.b - o.a) * s, x = o.b + (o.c - o.b) * s, v += (x - v) * s, x += (o.c + (o.d - o.c) * s - x) * s, y = g.a + (g.b - g.a) * s, _ = g.b + (g.c - g.b) * s, y += (_ - y) * s, _ += (g.c + (g.d - g.c) * s - _) * s, l = m ? Math.atan2(_ - y, x - v) * w + b : this._initialRotations[r], this._mod[a] && (l = this._mod[a](l, f)), d[a] ? f[a](l) : f[a] = l)
                    }
                }
            }), g = m.prototype;
        m.bezierThrough = u, m.cubicToQuadratic = l, m._autoCSS = !0, m.quadraticToCubic = function (t, e, i) {
            return new o(t, (2 * e + t) / 3, (2 * e + i) / 3, i)
        }, m._cssRegister = function () {
            var t = a.CSSPlugin;
            if (t) {
                var e = t._internals, i = e._parseToProxy, n = e._setPluginRatio, r = e.CSSPropTween;
                e._registerComplexSpecialProp("bezier", {
                    parser: function (t, e, a, o, s, l) {
                        e instanceof Array && (e = {values: e}), l = new m;
                        var c, h, u, p = e.values, d = p.length - 1, f = [], g = {};
                        if (0 > d) return s;
                        for (c = 0; d >= c; c++) u = i(t, p[c], o, s, l, d !== c), f[c] = u.end;
                        for (h in e) g[h] = e[h];
                        return g.values = f, s = new r(t, "bezier", 0, 0, u.pt, 2), s.data = u, s.plugin = l, s.setRatio = n, 0 === g.autoRotate && (g.autoRotate = !0), !g.autoRotate || g.autoRotate instanceof Array || (c = g.autoRotate === !0 ? 0 : Number(g.autoRotate), g.autoRotate = null != u.end.left ? [["left", "top", "rotation", c, !1]] : null != u.end.x && [["x", "y", "rotation", c, !1]]), g.autoRotate && (o._transform || o._enableTransforms(!1), u.autoRotate = o._target._gsTransform, u.proxy.rotation = u.autoRotate.rotation || 0, o._overwriteProps.push("rotation")), l._onInitTween(u.proxy, g, o._tween), s
                    }
                })
            }
        }, g._mod = function (t) {
            for (var e, i = this._overwriteProps, n = i.length; --n > -1;) (e = t[i[n]]) && "function" == typeof e && (this._mod[i[n]] = e)
        }, g._kill = function (t) {
            var e, i, n = this._props;
            for (e in this._beziers) if (e in t) for (delete this._beziers[e], delete this._func[e], i = n.length; --i > -1;) n[i] === e && n.splice(i, 1);
            if (n = this._autoRotate) for (i = n.length; --i > -1;) t[n[i][2]] && n.splice(i, 1);
            return this._super._kill.call(this, t)
        }
    }(), _gsScope._gsDefine("plugins.CSSPlugin", ["plugins.TweenPlugin", "TweenLite"], function (t, e) {
        var i, n, r, a, o = function () {
            t.call(this, "css"), this._overwriteProps.length = 0, this.setRatio = o.prototype.setRatio
        }, s = _gsScope._gsDefine.globals, l = {}, c = o.prototype = new t("css");
        c.constructor = o, o.version = "2.1.0", o.API = 2, o.defaultTransformPerspective = 0, o.defaultSkewType = "compensated", o.defaultSmoothOrigin = !0, c = "px", o.suffixMap = {
            top: c,
            right: c,
            bottom: c,
            left: c,
            width: c,
            height: c,
            fontSize: c,
            padding: c,
            margin: c,
            perspective: c,
            lineHeight: ""
        };
        var h, u, p, d, f, m, g, v, y = /(?:\-|\.|\b)(\d|\.|e\-)+/g,
            x = /(?:\d|\-\d|\.\d|\-\.\d|\+=\d|\-=\d|\+=.\d|\-=\.\d)+/g,
            _ = /(?:\+=|\-=|\-|\b)[\d\-\.]+[a-zA-Z0-9]*(?:%|\b)/gi, b = /(?![+-]?\d*\.?\d+|[+-]|e[+-]\d+)[^0-9]/g,
            w = /(?:\d|\-|\+|=|#|\.)*/g, M = /opacity *= *([^)]*)/i, T = /opacity:([^;]*)/i,
            S = /alpha\(opacity *=.+?\)/i, E = /^(rgb|hsl)/, A = /([A-Z])/g, P = /-([a-z])/gi,
            L = /(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, C = function (t, e) {
                return e.toUpperCase()
            }, R = /(?:Left|Right|Width)/i, O = /(M11|M12|M21|M22)=[\d\-\.e]+/gi,
            D = /progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, I = /,(?=[^\)]*(?:\(|$))/gi, N = /[\s,\(]/i,
            z = Math.PI / 180, k = 180 / Math.PI, B = {}, F = {style: {}}, H = _gsScope.document || {
                createElement: function () {
                    return F
                }
            }, U = function (t, e) {
                return e && H.createElementNS ? H.createElementNS(e, t) : H.createElement(t)
            }, G = U("div"), j = U("img"), V = o._internals = {_specialProps: l},
            W = (_gsScope.navigator || {}).userAgent || "", q = function () {
                var t = W.indexOf("Android"), e = U("a");
                return p = -1 !== W.indexOf("Safari") && -1 === W.indexOf("Chrome") && (-1 === t || parseFloat(W.substr(t + 8, 2)) > 3), f = p && parseFloat(W.substr(W.indexOf("Version/") + 8, 2)) < 6, d = -1 !== W.indexOf("Firefox"), (/MSIE ([0-9]{1,}[\.0-9]{0,})/.exec(W) || /Trident\/.*rv:([0-9]{1,}[\.0-9]{0,})/.exec(W)) && (m = parseFloat(RegExp.$1)), !!e && (e.style.cssText = "top:1px;opacity:.55;", /^0.55/.test(e.style.opacity))
            }(), X = function (t) {
                return M.test("string" == typeof t ? t : (t.currentStyle ? t.currentStyle.filter : t.style.filter) || "") ? parseFloat(RegExp.$1) / 100 : 1
            }, Y = function (t) {
                _gsScope.console && console.log(t)
            }, J = "", Z = "", Q = function (t, e) {
                e = e || G;
                var i, n, r = e.style;
                if (void 0 !== r[t]) return t;
                for (t = t.charAt(0).toUpperCase() + t.substr(1), i = ["O", "Moz", "ms", "Ms", "Webkit"], n = 5; --n > -1 && void 0 === r[i[n] + t];) ;
                return n >= 0 ? (Z = 3 === n ? "ms" : i[n], J = "-" + Z.toLowerCase() + "-", Z + t) : null
            }, $ = "undefined" != typeof window ? window : H.defaultView || {
                getComputedStyle: function () {
                }
            }, K = function (t) {
                return $.getComputedStyle(t)
            }, tt = o.getStyle = function (t, e, i, n, r) {
                var a;
                return q || "opacity" !== e ? (!n && t.style[e] ? a = t.style[e] : (i = i || K(t)) ? a = i[e] || i.getPropertyValue(e) || i.getPropertyValue(e.replace(A, "-$1").toLowerCase()) : t.currentStyle && (a = t.currentStyle[e]), null == r || a && "none" !== a && "auto" !== a && "auto auto" !== a ? a : r) : X(t)
            }, et = V.convertToPixels = function (t, i, n, r, a) {
                if ("px" === r || !r && "lineHeight" !== i) return n;
                if ("auto" === r || !n) return 0;
                var s, l, c, h = R.test(i), u = t, p = G.style, d = 0 > n, f = 1 === n;
                if (d && (n = -n), f && (n *= 100), "lineHeight" !== i || r) if ("%" === r && -1 !== i.indexOf("border")) s = n / 100 * (h ? t.clientWidth : t.clientHeight); else {
                    if (p.cssText = "border:0 solid red;position:" + tt(t, "position") + ";line-height:0;", "%" !== r && u.appendChild && "v" !== r.charAt(0) && "rem" !== r) p[h ? "borderLeftWidth" : "borderTopWidth"] = n + r; else {
                        if (u = t.parentNode || H.body, -1 !== tt(u, "display").indexOf("flex") && (p.position = "absolute"), l = u._gsCache, c = e.ticker.frame, l && h && l.time === c) return l.width * n / 100;
                        p[h ? "width" : "height"] = n + r
                    }
                    u.appendChild(G), s = parseFloat(G[h ? "offsetWidth" : "offsetHeight"]), u.removeChild(G), h && "%" === r && o.cacheWidths !== !1 && (l = u._gsCache = u._gsCache || {}, l.time = c, l.width = s / n * 100), 0 !== s || a || (s = et(t, i, n, r, !0))
                } else l = K(t).lineHeight, t.style.lineHeight = n, s = parseFloat(K(t).lineHeight), t.style.lineHeight = l;
                return f && (s /= 100), d ? -s : s
            }, it = V.calculateOffset = function (t, e, i) {
                if ("absolute" !== tt(t, "position", i)) return 0;
                var n = "left" === e ? "Left" : "Top", r = tt(t, "margin" + n, i);
                return t["offset" + n] - (et(t, e, parseFloat(r), r.replace(w, "")) || 0)
            }, nt = function (t, e) {
                var i, n, r, a = {};
                if (e = e || K(t, null)) if (i = e.length) for (; --i > -1;) r = e[i], (-1 === r.indexOf("-transform") || Ct === r) && (a[r.replace(P, C)] = e.getPropertyValue(r)); else for (i in e) (-1 === i.indexOf("Transform") || Lt === i) && (a[i] = e[i]); else if (e = t.currentStyle || t.style) for (i in e) "string" == typeof i && void 0 === a[i] && (a[i.replace(P, C)] = e[i]);
                return q || (a.opacity = X(t)), n = Vt(t, e, !1), a.rotation = n.rotation, a.skewX = n.skewX, a.scaleX = n.scaleX, a.scaleY = n.scaleY, a.x = n.x, a.y = n.y, Ot && (a.z = n.z, a.rotationX = n.rotationX, a.rotationY = n.rotationY, a.scaleZ = n.scaleZ), a.filters && delete a.filters, a
            }, rt = function (t, e, i, n, r) {
                var a, o, s, l = {}, c = t.style;
                for (o in i) "cssText" !== o && "length" !== o && isNaN(o) && (e[o] !== (a = i[o]) || r && r[o]) && -1 === o.indexOf("Origin") && ("number" == typeof a || "string" == typeof a) && (l[o] = "auto" !== a || "left" !== o && "top" !== o ? "" !== a && "auto" !== a && "none" !== a || "string" != typeof e[o] || "" === e[o].replace(b, "") ? a : 0 : it(t, o), void 0 !== c[o] && (s = new xt(c, o, c[o], s)));
                if (n) for (o in n) "className" !== o && (l[o] = n[o]);
                return {difs: l, firstMPT: s}
            }, at = {width: ["Left", "Right"], height: ["Top", "Bottom"]},
            ot = ["marginLeft", "marginRight", "marginTop", "marginBottom"], st = function (t, e, i) {
                if ("svg" === (t.nodeName + "").toLowerCase()) return (i || K(t))[e] || 0;
                if (t.getCTM && Ut(t)) return t.getBBox()[e] || 0;
                var n = parseFloat("width" === e ? t.offsetWidth : t.offsetHeight), r = at[e], a = r.length;
                for (i = i || K(t, null); --a > -1;) n -= parseFloat(tt(t, "padding" + r[a], i, !0)) || 0, n -= parseFloat(tt(t, "border" + r[a] + "Width", i, !0)) || 0;
                return n
            }, lt = function (t, e) {
                if ("contain" === t || "auto" === t || "auto auto" === t) return t + " ";
                (null == t || "" === t) && (t = "0 0");
                var i, n = t.split(" "), r = -1 !== t.indexOf("left") ? "0%" : -1 !== t.indexOf("right") ? "100%" : n[0],
                    a = -1 !== t.indexOf("top") ? "0%" : -1 !== t.indexOf("bottom") ? "100%" : n[1];
                if (n.length > 3 && !e) {
                    for (n = t.split(", ").join(",").split(","), t = [], i = 0; i < n.length; i++) t.push(lt(n[i]));
                    return t.join(",")
                }
                return null == a ? a = "center" === r ? "50%" : "0" : "center" === a && (a = "50%"), ("center" === r || isNaN(parseFloat(r)) && -1 === (r + "").indexOf("=")) && (r = "50%"), t = r + " " + a + (n.length > 2 ? " " + n[2] : ""), e && (e.oxp = -1 !== r.indexOf("%"), e.oyp = -1 !== a.indexOf("%"), e.oxr = "=" === r.charAt(1), e.oyr = "=" === a.charAt(1), e.ox = parseFloat(r.replace(b, "")), e.oy = parseFloat(a.replace(b, "")), e.v = t), e || t
            }, ct = function (t, e) {
                return "function" == typeof t && (t = t(v, g)), "string" == typeof t && "=" === t.charAt(1) ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) : parseFloat(t) - parseFloat(e) || 0
            }, ht = function (t, e) {
                "function" == typeof t && (t = t(v, g));
                var i = "string" == typeof t && "=" === t.charAt(1);
                return "string" == typeof t && "v" === t.charAt(t.length - 2) && (t = (i ? t.substr(0, 2) : 0) + window["inner" + ("vh" === t.substr(-2) ? "Height" : "Width")] * (parseFloat(i ? t.substr(2) : t) / 100)), null == t ? e : i ? parseInt(t.charAt(0) + "1", 10) * parseFloat(t.substr(2)) + e : parseFloat(t) || 0
            }, ut = function (t, e, i, n) {
                var r, a, o, s, l, c = 1e-6;
                return "function" == typeof t && (t = t(v, g)), null == t ? s = e : "number" == typeof t ? s = t : (r = 360, a = t.split("_"), l = "=" === t.charAt(1), o = (l ? parseInt(t.charAt(0) + "1", 10) * parseFloat(a[0].substr(2)) : parseFloat(a[0])) * (-1 === t.indexOf("rad") ? 1 : k) - (l ? 0 : e), a.length && (n && (n[i] = e + o), -1 !== t.indexOf("short") && (o %= r) !== o % (r / 2) && (o = 0 > o ? o + r : o - r), -1 !== t.indexOf("_cw") && 0 > o ? o = (o + 9999999999 * r) % r - (o / r | 0) * r : -1 !== t.indexOf("ccw") && o > 0 && (o = (o - 9999999999 * r) % r - (o / r | 0) * r)), s = e + o), 1e-6 > s && s > -1e-6 && (s = 0), s
            }, pt = {
                aqua: [0, 255, 255],
                lime: [0, 255, 0],
                silver: [192, 192, 192],
                black: [0, 0, 0],
                maroon: [128, 0, 0],
                teal: [0, 128, 128],
                blue: [0, 0, 255],
                navy: [0, 0, 128],
                white: [255, 255, 255],
                fuchsia: [255, 0, 255],
                olive: [128, 128, 0],
                yellow: [255, 255, 0],
                orange: [255, 165, 0],
                gray: [128, 128, 128],
                purple: [128, 0, 128],
                green: [0, 128, 0],
                red: [255, 0, 0],
                pink: [255, 192, 203],
                cyan: [0, 255, 255],
                transparent: [255, 255, 255, 0]
            }, dt = function (t, e, i) {
                return t = 0 > t ? t + 1 : t > 1 ? t - 1 : t, 255 * (1 > 6 * t ? e + (i - e) * t * 6 : .5 > t ? i : 2 > 3 * t ? e + (i - e) * (2 / 3 - t) * 6 : e) + .5 | 0
            }, ft = o.parseColor = function (t, e) {
                var i, n, r, a, o, s, l, c, h, u, p;
                if (t) if ("number" == typeof t) i = [t >> 16, t >> 8 & 255, 255 & t]; else {
                    if ("," === t.charAt(t.length - 1) && (t = t.substr(0, t.length - 1)), pt[t]) i = pt[t]; else if ("#" === t.charAt(0)) 4 === t.length && (n = t.charAt(1), r = t.charAt(2), a = t.charAt(3), t = "#" + n + n + r + r + a + a), t = parseInt(t.substr(1), 16), i = [t >> 16, t >> 8 & 255, 255 & t]; else if ("hsl" === t.substr(0, 3)) if (i = p = t.match(y), e) {
                        if (-1 !== t.indexOf("=")) return t.match(x)
                    } else o = Number(i[0]) % 360 / 360, s = Number(i[1]) / 100, l = Number(i[2]) / 100, r = .5 >= l ? l * (s + 1) : l + s - l * s, n = 2 * l - r, i.length > 3 && (i[3] = Number(i[3])), i[0] = dt(o + 1 / 3, n, r), i[1] = dt(o, n, r), i[2] = dt(o - 1 / 3, n, r); else i = t.match(y) || pt.transparent;
                    i[0] = Number(i[0]), i[1] = Number(i[1]), i[2] = Number(i[2]), i.length > 3 && (i[3] = Number(i[3]))
                } else i = pt.black;
                return e && !p && (n = i[0] / 255, r = i[1] / 255, a = i[2] / 255, c = Math.max(n, r, a), h = Math.min(n, r, a), l = (c + h) / 2, c === h ? o = s = 0 : (u = c - h, s = l > .5 ? u / (2 - c - h) : u / (c + h), o = c === n ? (r - a) / u + (a > r ? 6 : 0) : c === r ? (a - n) / u + 2 : (n - r) / u + 4, o *= 60), i[0] = o + .5 | 0, i[1] = 100 * s + .5 | 0, i[2] = 100 * l + .5 | 0), i
            }, mt = function (t, e) {
                var i, n, r, a = t.match(gt) || [], o = 0, s = "";
                if (!a.length) return t;
                for (i = 0; i < a.length; i++) n = a[i], r = t.substr(o, t.indexOf(n, o) - o), o += r.length + n.length, n = ft(n, e), 3 === n.length && n.push(1), s += r + (e ? "hsla(" + n[0] + "," + n[1] + "%," + n[2] + "%," + n[3] : "rgba(" + n.join(",")) + ")";
                return s + t.substr(o)
            }, gt = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b";
        for (c in pt) gt += "|" + c + "\\b";
        gt = new RegExp(gt + ")", "gi"), o.colorStringFilter = function (t) {
            var e, i = t[0] + " " + t[1];
            gt.test(i) && (e = -1 !== i.indexOf("hsl(") || -1 !== i.indexOf("hsla("), t[0] = mt(t[0], e), t[1] = mt(t[1], e)), gt.lastIndex = 0
        }, e.defaultStringFilter || (e.defaultStringFilter = o.colorStringFilter);
        var vt = function (t, e, i, n) {
            if (null == t) return function (t) {
                return t
            };
            var r, a = e ? (t.match(gt) || [""])[0] : "", o = t.split(a).join("").match(_) || [],
                s = t.substr(0, t.indexOf(o[0])), l = ")" === t.charAt(t.length - 1) ? ")" : "",
                c = -1 !== t.indexOf(" ") ? " " : ",", h = o.length, u = h > 0 ? o[0].replace(y, "") : "";
            return h ? r = e ? function (t) {
                var e, p, d, f;
                if ("number" == typeof t) t += u; else if (n && I.test(t)) {
                    for (f = t.replace(I, "|").split("|"), d = 0; d < f.length; d++) f[d] = r(f[d]);
                    return f.join(",")
                }
                if (e = (t.match(gt) || [a])[0], p = t.split(e).join("").match(_) || [], d = p.length, h > d--) for (; ++d < h;) p[d] = i ? p[(d - 1) / 2 | 0] : o[d];
                return s + p.join(c) + c + e + l + (-1 !== t.indexOf("inset") ? " inset" : "")
            } : function (t) {
                var e, a, p;
                if ("number" == typeof t) t += u; else if (n && I.test(t)) {
                    for (a = t.replace(I, "|").split("|"), p = 0; p < a.length; p++) a[p] = r(a[p]);
                    return a.join(",")
                }
                if (e = t.match(_) || [], p = e.length, h > p--) for (; ++p < h;) e[p] = i ? e[(p - 1) / 2 | 0] : o[p];
                return s + e.join(c) + l
            } : function (t) {
                return t
            }
        }, yt = function (t) {
            return t = t.split(","), function (e, i, n, r, a, o, s) {
                var l, c = (i + "").split(" ");
                for (s = {}, l = 0; 4 > l; l++) s[t[l]] = c[l] = c[l] || c[(l - 1) / 2 >> 0];
                return r.parse(e, s, a, o)
            }
        }, xt = (V._setPluginRatio = function (t) {
            this.plugin.setRatio(t);
            for (var e, i, n, r, a, o = this.data, s = o.proxy, l = o.firstMPT, c = 1e-6; l;) e = s[l.v], l.r ? e = l.r(e) : 1e-6 > e && e > -1e-6 && (e = 0), l.t[l.p] = e, l = l._next;
            if (o.autoRotate && (o.autoRotate.rotation = o.mod ? o.mod.call(this._tween, s.rotation, this.t, this._tween) : s.rotation), 1 === t || 0 === t) for (l = o.firstMPT, a = 1 === t ? "e" : "b"; l;) {
                if (i = l.t, i.type) {
                    if (1 === i.type) {
                        for (r = i.xs0 + i.s + i.xs1, n = 1; n < i.l; n++) r += i["xn" + n] + i["xs" + (n + 1)];
                        i[a] = r
                    }
                } else i[a] = i.s + i.xs0;
                l = l._next
            }
        }, function (t, e, i, n, r) {
            this.t = t, this.p = e, this.v = i, this.r = r, n && (n._prev = this, this._next = n)
        }), _t = (V._parseToProxy = function (t, e, i, n, r, a) {
            var o, s, l, c, h, u = n, p = {}, d = {}, f = i._transform, m = B;
            for (i._transform = null, B = e, n = h = i.parse(t, e, n, r), B = m, a && (i._transform = f, u && (u._prev = null, u._prev && (u._prev._next = null))); n && n !== u;) {
                if (n.type <= 1 && (s = n.p, d[s] = n.s + n.c, p[s] = n.s, a || (c = new xt(n, "s", s, c, n.r), n.c = 0), 1 === n.type)) for (o = n.l; --o > 0;) l = "xn" + o, s = n.p + "_" + l, d[s] = n.data[l], p[s] = n[l], a || (c = new xt(n, l, s, c, n.rxp[l]));
                n = n._next
            }
            return {proxy: p, end: d, firstMPT: c, pt: h}
        }, V.CSSPropTween = function (t, e, n, r, o, s, l, c, h, u, p) {
            this.t = t, this.p = e, this.s = n, this.c = r, this.n = l || e, t instanceof _t || a.push(this.n), this.r = c ? "function" == typeof c ? c : Math.round : c, this.type = s || 0, h && (this.pr = h, i = !0), this.b = void 0 === u ? n : u, this.e = void 0 === p ? n + r : p, o && (this._next = o, o._prev = this)
        }), bt = function (t, e, i, n, r, a) {
            var o = new _t(t, e, i, n - i, r, -1, a);
            return o.b = i, o.e = o.xs0 = n, o
        }, wt = o.parseComplex = function (t, e, i, n, r, a, s, l, c, u) {
            i = i || a || "", "function" == typeof n && (n = n(v, g)), s = new _t(t, e, 0, 0, s, u ? 2 : 1, null, !1, l, i, n), n += "", r && gt.test(n + i) && (n = [i, n], o.colorStringFilter(n), i = n[0], n = n[1]);
            var p, d, f, m, _, b, w, M, T, S, E, A, P, L = i.split(", ").join(",").split(" "),
                C = n.split(", ").join(",").split(" "), R = L.length, O = h !== !1;
            for ((-1 !== n.indexOf(",") || -1 !== i.indexOf(",")) && (-1 !== (n + i).indexOf("rgb") || -1 !== (n + i).indexOf("hsl") ? (L = L.join(" ").replace(I, ", ").split(" "), C = C.join(" ").replace(I, ", ").split(" ")) : (L = L.join(" ").split(",").join(", ").split(" "), C = C.join(" ").split(",").join(", ").split(" ")), R = L.length), R !== C.length && (L = (a || "").split(" "), R = L.length), s.plugin = c, s.setRatio = u, gt.lastIndex = 0, p = 0; R > p; p++) if (m = L[p], _ = C[p] + "", (M = parseFloat(m)) || 0 === M) s.appendXtra("", M, ct(_, M), _.replace(x, ""), !(!O || -1 === _.indexOf("px")) && Math.round, !0); else if (r && gt.test(m)) A = _.indexOf(")") + 1, A = ")" + (A ? _.substr(A) : ""), P = -1 !== _.indexOf("hsl") && q, S = _, m = ft(m, P), _ = ft(_, P), T = m.length + _.length > 6, T && !q && 0 === _[3] ? (s["xs" + s.l] += s.l ? " transparent" : "transparent", s.e = s.e.split(C[p]).join("transparent")) : (q || (T = !1), P ? s.appendXtra(S.substr(0, S.indexOf("hsl")) + (T ? "hsla(" : "hsl("), m[0], ct(_[0], m[0]), ",", !1, !0).appendXtra("", m[1], ct(_[1], m[1]), "%,", !1).appendXtra("", m[2], ct(_[2], m[2]), T ? "%," : "%" + A, !1) : s.appendXtra(S.substr(0, S.indexOf("rgb")) + (T ? "rgba(" : "rgb("), m[0], _[0] - m[0], ",", Math.round, !0).appendXtra("", m[1], _[1] - m[1], ",", Math.round).appendXtra("", m[2], _[2] - m[2], T ? "," : A, Math.round), T && (m = m.length < 4 ? 1 : m[3], s.appendXtra("", m, (_.length < 4 ? 1 : _[3]) - m, A, !1))), gt.lastIndex = 0; else if (b = m.match(y)) {
                if (!(w = _.match(x)) || w.length !== b.length) return s;
                for (f = 0, d = 0; d < b.length; d++) E = b[d], S = m.indexOf(E, f), s.appendXtra(m.substr(f, S - f), Number(E), ct(w[d], E), "", !(!O || "px" !== m.substr(S + E.length, 2)) && Math.round, 0 === d), f = S + E.length;
                s["xs" + s.l] += m.substr(f)
            } else s["xs" + s.l] += s.l || s["xs" + s.l] ? " " + _ : _;
            if (-1 !== n.indexOf("=") && s.data) {
                for (A = s.xs0 + s.data.s, p = 1; p < s.l; p++) A += s["xs" + p] + s.data["xn" + p];
                s.e = A + s["xs" + p]
            }
            return s.l || (s.type = -1, s.xs0 = s.e), s.xfirst || s
        }, Mt = 9;
        for (c = _t.prototype, c.l = c.pr = 0; --Mt > 0;) c["xn" + Mt] = 0, c["xs" + Mt] = "";
        c.xs0 = "", c._next = c._prev = c.xfirst = c.data = c.plugin = c.setRatio = c.rxp = null, c.appendXtra = function (t, e, i, n, r, a) {
            var o = this, s = o.l;
            return o["xs" + s] += a && (s || o["xs" + s]) ? " " + t : t || "", i || 0 === s || o.plugin ? (o.l++, o.type = o.setRatio ? 2 : 1, o["xs" + o.l] = n || "", s > 0 ? (o.data["xn" + s] = e + i, o.rxp["xn" + s] = r, o["xn" + s] = e, o.plugin || (o.xfirst = new _t(o, "xn" + s, e, i, o.xfirst || o, 0, o.n, r, o.pr), o.xfirst.xs0 = 0), o) : (o.data = {s: e + i}, o.rxp = {}, o.s = e, o.c = i, o.r = r, o)) : (o["xs" + s] += e + (n || ""), o)
        };
        var Tt = function (t, e) {
            e = e || {}, this.p = e.prefix ? Q(t) || t : t, l[t] = l[this.p] = this, this.format = e.formatter || vt(e.defaultValue, e.color, e.collapsible, e.multi), e.parser && (this.parse = e.parser), this.clrs = e.color, this.multi = e.multi, this.keyword = e.keyword, this.dflt = e.defaultValue, this.allowFunc = e.allowFunc, this.pr = e.priority || 0
        }, St = V._registerComplexSpecialProp = function (t, e, i) {
            "object" != typeof e && (e = {parser: i});
            var n, r, a = t.split(","), o = e.defaultValue;
            for (i = i || [o], n = 0; n < a.length; n++) e.prefix = 0 === n && e.prefix, e.defaultValue = i[n] || o, r = new Tt(a[n], e)
        }, Et = V._registerPluginProp = function (t) {
            if (!l[t]) {
                var e = t.charAt(0).toUpperCase() + t.substr(1) + "Plugin";
                St(t, {
                    parser: function (t, i, n, r, a, o, c) {
                        var h = s.com.greensock.plugins[e];
                        return h ? (h._cssRegister(), l[n].parse(t, i, n, r, a, o, c)) : (Y("Error: " + e + " js file not loaded."), a)
                    }
                })
            }
        };
        c = Tt.prototype, c.parseComplex = function (t, e, i, n, r, a) {
            var o, s, l, c, h, u, p = this.keyword;
            if (this.multi && (I.test(i) || I.test(e) ? (s = e.replace(I, "|").split("|"), l = i.replace(I, "|").split("|")) : p && (s = [e], l = [i])), l) {
                for (c = l.length > s.length ? l.length : s.length, o = 0; c > o; o++) e = s[o] = s[o] || this.dflt, i = l[o] = l[o] || this.dflt, p && (h = e.indexOf(p), u = i.indexOf(p), h !== u && (-1 === u ? s[o] = s[o].split(p).join("") : -1 === h && (s[o] += " " + p)));
                e = s.join(", "), i = l.join(", ")
            }
            return wt(t, this.p, e, i, this.clrs, this.dflt, n, this.pr, r, a)
        }, c.parse = function (t, e, i, n, a, o, s) {
            return this.parseComplex(t.style, this.format(tt(t, this.p, r, !1, this.dflt)), this.format(e), a, o)
        }, o.registerSpecialProp = function (t, e, i) {
            St(t, {
                parser: function (t, n, r, a, o, s, l) {
                    var c = new _t(t, r, 0, 0, o, 2, r, !1, i);
                    return c.plugin = s, c.setRatio = e(t, n, a._tween, r), c
                }, priority: i
            })
        }, o.useSVGTransformAttr = !0;
        var At,
            Pt = "scaleX,scaleY,scaleZ,x,y,z,skewX,skewY,rotation,rotationX,rotationY,perspective,xPercent,yPercent".split(","),
            Lt = Q("transform"), Ct = J + "transform", Rt = Q("transformOrigin"), Ot = null !== Q("perspective"),
            Dt = V.Transform = function () {
                this.perspective = parseFloat(o.defaultTransformPerspective) || 0, this.force3D = !(o.defaultForce3D === !1 || !Ot) && (o.defaultForce3D || "auto")
            }, It = _gsScope.SVGElement, Nt = function (t, e, i) {
                var n, r = H.createElementNS("http://www.w3.org/2000/svg", t), a = /([a-z])([A-Z])/g;
                for (n in i) r.setAttributeNS(null, n.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), i[n]);
                return e.appendChild(r), r
            }, zt = H.documentElement || {}, kt = function () {
                var t, e, i, n = m || /Android/i.test(W) && !_gsScope.chrome;
                return H.createElementNS && !n && (t = Nt("svg", zt), e = Nt("rect", t, {
                    width: 100,
                    height: 50,
                    x: 100
                }), i = e.getBoundingClientRect().width, e.style[Rt] = "50% 50%", e.style[Lt] = "scaleX(0.5)", n = i === e.getBoundingClientRect().width && !(d && Ot), zt.removeChild(t)), n
            }(), Bt = function (t, e, i, n, r, a) {
                var s, l, c, h, u, p, d, f, m, g, v, y, x, _, b = t._gsTransform, w = jt(t, !0);
                b && (x = b.xOrigin, _ = b.yOrigin), (!n || (s = n.split(" ")).length < 2) && (d = t.getBBox(), 0 === d.x && 0 === d.y && d.width + d.height === 0 && (d = {
                    x: parseFloat(t.hasAttribute("x") ? t.getAttribute("x") : t.hasAttribute("cx") ? t.getAttribute("cx") : 0) || 0,
                    y: parseFloat(t.hasAttribute("y") ? t.getAttribute("y") : t.hasAttribute("cy") ? t.getAttribute("cy") : 0) || 0,
                    width: 0,
                    height: 0
                }), e = lt(e).split(" "), s = [(-1 !== e[0].indexOf("%") ? parseFloat(e[0]) / 100 * d.width : parseFloat(e[0])) + d.x, (-1 !== e[1].indexOf("%") ? parseFloat(e[1]) / 100 * d.height : parseFloat(e[1])) + d.y]), i.xOrigin = h = parseFloat(s[0]), i.yOrigin = u = parseFloat(s[1]), n && w !== Gt && (p = w[0], d = w[1], f = w[2], m = w[3], g = w[4], v = w[5], (y = p * m - d * f) && (l = h * (m / y) + u * (-f / y) + (f * v - m * g) / y, c = h * (-d / y) + u * (p / y) - (p * v - d * g) / y, h = i.xOrigin = s[0] = l, u = i.yOrigin = s[1] = c)), b && (a && (i.xOffset = b.xOffset, i.yOffset = b.yOffset, b = i), r || r !== !1 && o.defaultSmoothOrigin !== !1 ? (l = h - x, c = u - _, b.xOffset += l * w[0] + c * w[2] - l, b.yOffset += l * w[1] + c * w[3] - c) : b.xOffset = b.yOffset = 0), a || t.setAttribute("data-svg-origin", s.join(" "))
            }, Ft = function (t) {
                var e,
                    i = U("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
                    n = this.parentNode, r = this.nextSibling, a = this.style.cssText;
                if (zt.appendChild(i), i.appendChild(this), this.style.display = "block", t) try {
                    e = this.getBBox(), this._originalGetBBox = this.getBBox, this.getBBox = Ft
                } catch (t) {
                } else this._originalGetBBox && (e = this._originalGetBBox());
                return r ? n.insertBefore(this, r) : n.appendChild(this), zt.removeChild(i), this.style.cssText = a, e
            }, Ht = function (t) {
                try {
                    return t.getBBox()
                } catch (e) {
                    return Ft.call(t, !0)
                }
            }, Ut = function (t) {
                return !(!It || !t.getCTM || t.parentNode && !t.ownerSVGElement || !Ht(t))
            }, Gt = [1, 0, 0, 1, 0, 0], jt = function (t, e) {
                var i, n, r, a, o, s, l, c = t._gsTransform || new Dt, h = 1e5, u = t.style;
                if (Lt ? n = tt(t, Ct, null, !0) : t.currentStyle && (n = t.currentStyle.filter.match(/(M11|M12|M21|M22)=[\d\-\.e]+/gi), n = n && 4 === n.length ? [n[0].substr(4), Number(n[2].substr(4)), Number(n[1].substr(4)), n[3].substr(4), c.x || 0, c.y || 0].join(",") : ""), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, Lt && i && !t.offsetParent && (a = u.display, u.display = "block", l = t.parentNode, l && t.offsetParent || (o = 1, s = t.nextSibling, zt.appendChild(t)), n = tt(t, Ct, null, !0), i = !n || "none" === n || "matrix(1, 0, 0, 1, 0, 0)" === n, a ? u.display = a : Yt(u, "display"), o && (s ? l.insertBefore(t, s) : l ? l.appendChild(t) : zt.removeChild(t))), (c.svg || t.getCTM && Ut(t)) && (i && -1 !== (u[Lt] + "").indexOf("matrix") && (n = u[Lt], i = 0), r = t.getAttribute("transform"), i && r && (r = t.transform.baseVal.consolidate().matrix, n = "matrix(" + r.a + "," + r.b + "," + r.c + "," + r.d + "," + r.e + "," + r.f + ")", i = 0)), i) return Gt;
                for (r = (n || "").match(y) || [], Mt = r.length; --Mt > -1;) a = Number(r[Mt]), r[Mt] = (o = a - (a |= 0)) ? (1e5 * o + (0 > o ? -.5 : .5) | 0) / 1e5 + a : a;
                return e && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r
            }, Vt = V.getTransform = function (t, i, n, r) {
                if (t._gsTransform && n && !r) return t._gsTransform;
                var a, s, l, c, h, u, p = n ? t._gsTransform || new Dt : new Dt, d = p.scaleX < 0, f = 2e-5, m = 1e5,
                    g = Ot ? parseFloat(tt(t, Rt, i, !1, "0 0 0").split(" ")[2]) || p.zOrigin || 0 : 0,
                    v = parseFloat(o.defaultTransformPerspective) || 0;
                if (p.svg = !(!t.getCTM || !Ut(t)), p.svg && (Bt(t, tt(t, Rt, i, !1, "50% 50%") + "", p, t.getAttribute("data-svg-origin")), At = o.useSVGTransformAttr || kt), (a = jt(t)) !== Gt) {
                    if (16 === a.length) {
                        var y, x, _, b, w, M = a[0], T = a[1], S = a[2], E = a[3], A = a[4], P = a[5], L = a[6], C = a[7],
                            R = a[8], O = a[9], D = a[10], I = a[12], N = a[13], z = a[14], B = a[11], F = Math.atan2(L, D);
                        p.zOrigin && (z = -p.zOrigin, I = R * z - a[12], N = O * z - a[13], z = D * z + p.zOrigin - a[14]), p.rotationX = F * k, F && (b = Math.cos(-F), w = Math.sin(-F), y = A * b + R * w, x = P * b + O * w, _ = L * b + D * w, R = A * -w + R * b, O = P * -w + O * b, D = L * -w + D * b, B = C * -w + B * b, A = y, P = x, L = _), F = Math.atan2(-S, D), p.rotationY = F * k, F && (b = Math.cos(-F), w = Math.sin(-F), y = M * b - R * w, x = T * b - O * w, _ = S * b - D * w, O = T * w + O * b, D = S * w + D * b, B = E * w + B * b, M = y, T = x, S = _), F = Math.atan2(T, M), p.rotation = F * k, F && (b = Math.cos(F), w = Math.sin(F), y = M * b + T * w, x = A * b + P * w, _ = R * b + O * w, T = T * b - M * w, P = P * b - A * w, O = O * b - R * w, M = y, A = x, R = _), p.rotationX && Math.abs(p.rotationX) + Math.abs(p.rotation) > 359.9 && (p.rotationX = p.rotation = 0, p.rotationY = 180 - p.rotationY), F = Math.atan2(A, P), p.scaleX = (Math.sqrt(M * M + T * T + S * S) * m + .5 | 0) / m, p.scaleY = (Math.sqrt(P * P + L * L) * m + .5 | 0) / m, p.scaleZ = (Math.sqrt(R * R + O * O + D * D) * m + .5 | 0) / m, M /= p.scaleX, A /= p.scaleY, T /= p.scaleX, P /= p.scaleY, Math.abs(F) > f ? (p.skewX = F * k, A = 0, "simple" !== p.skewType && (p.scaleY *= 1 / Math.cos(F))) : p.skewX = 0, p.perspective = B ? 1 / (0 > B ? -B : B) : 0, p.x = I, p.y = N, p.z = z, p.svg && (p.x -= p.xOrigin - (p.xOrigin * M - p.yOrigin * A), p.y -= p.yOrigin - (p.yOrigin * T - p.xOrigin * P))
                    } else if (!Ot || r || !a.length || p.x !== a[4] || p.y !== a[5] || !p.rotationX && !p.rotationY) {
                        var H = a.length >= 6, U = H ? a[0] : 1, G = a[1] || 0, j = a[2] || 0, V = H ? a[3] : 1;
                        p.x = a[4] || 0, p.y = a[5] || 0, l = Math.sqrt(U * U + G * G), c = Math.sqrt(V * V + j * j), h = U || G ? Math.atan2(G, U) * k : p.rotation || 0, u = j || V ? Math.atan2(j, V) * k + h : p.skewX || 0, p.scaleX = l, p.scaleY = c, p.rotation = h, p.skewX = u, Ot && (p.rotationX = p.rotationY = p.z = 0, p.perspective = v, p.scaleZ = 1), p.svg && (p.x -= p.xOrigin - (p.xOrigin * U + p.yOrigin * j), p.y -= p.yOrigin - (p.xOrigin * G + p.yOrigin * V))
                    }
                    Math.abs(p.skewX) > 90 && Math.abs(p.skewX) < 270 && (d ? (p.scaleX *= -1, p.skewX += p.rotation <= 0 ? 180 : -180, p.rotation += p.rotation <= 0 ? 180 : -180) : (p.scaleY *= -1, p.skewX += p.skewX <= 0 ? 180 : -180)), p.zOrigin = g;
                    for (s in p) p[s] < f && p[s] > -f && (p[s] = 0)
                }
                return n && (t._gsTransform = p, p.svg && (At && t.style[Lt] ? e.delayedCall(.001, function () {
                    Yt(t.style, Lt)
                }) : !At && t.getAttribute("transform") && e.delayedCall(.001, function () {
                    t.removeAttribute("transform")
                }))), p
            }, Wt = function (t) {
                var e, i, n = this.data, r = -n.rotation * z, a = r + n.skewX * z, o = 1e5,
                    s = (Math.cos(r) * n.scaleX * o | 0) / o, l = (Math.sin(r) * n.scaleX * o | 0) / o,
                    c = (Math.sin(a) * -n.scaleY * o | 0) / o, h = (Math.cos(a) * n.scaleY * o | 0) / o, u = this.t.style,
                    p = this.t.currentStyle;
                if (p) {
                    i = l, l = -c, c = -i, e = p.filter, u.filter = "";
                    var d, f, g = this.t.offsetWidth, v = this.t.offsetHeight, y = "absolute" !== p.position,
                        x = "progid:DXImageTransform.Microsoft.Matrix(M11=" + s + ", M12=" + l + ", M21=" + c + ", M22=" + h,
                        _ = n.x + g * n.xPercent / 100, b = n.y + v * n.yPercent / 100;
                    if (null != n.ox && (d = (n.oxp ? g * n.ox * .01 : n.ox) - g / 2, f = (n.oyp ? v * n.oy * .01 : n.oy) - v / 2, _ += d - (d * s + f * l), b += f - (d * c + f * h)), y ? (d = g / 2, f = v / 2, x += ", Dx=" + (d - (d * s + f * l) + _) + ", Dy=" + (f - (d * c + f * h) + b) + ")") : x += ", sizingMethod='auto expand')", -1 !== e.indexOf("DXImageTransform.Microsoft.Matrix(") ? u.filter = e.replace(/progid\:DXImageTransform\.Microsoft\.Matrix\(.+?\)/i, x) : u.filter = x + " " + e, (0 === t || 1 === t) && 1 === s && 0 === l && 0 === c && 1 === h && (y && -1 === x.indexOf("Dx=0, Dy=0") || M.test(e) && 100 !== parseFloat(RegExp.$1) || -1 === e.indexOf(e.indexOf("Alpha")) && u.removeAttribute("filter")), !y) {
                        var T, S, E, A = 8 > m ? 1 : -1;
                        for (d = n.ieOffsetX || 0, f = n.ieOffsetY || 0, n.ieOffsetX = Math.round((g - ((0 > s ? -s : s) * g + (0 > l ? -l : l) * v)) / 2 + _), n.ieOffsetY = Math.round((v - ((0 > h ? -h : h) * v + (0 > c ? -c : c) * g)) / 2 + b), Mt = 0; 4 > Mt; Mt++) S = ot[Mt], T = p[S], i = -1 !== T.indexOf("px") ? parseFloat(T) : et(this.t, S, parseFloat(T), T.replace(w, "")) || 0, E = i !== n[S] ? 2 > Mt ? -n.ieOffsetX : -n.ieOffsetY : 2 > Mt ? d - n.ieOffsetX : f - n.ieOffsetY, u[S] = (n[S] = Math.round(i - E * (0 === Mt || 2 === Mt ? 1 : A))) + "px"
                    }
                }
            }, qt = V.set3DTransformRatio = V.setTransformRatio = function (t) {
                var e, i, n, r, a, o, s, l, c, h, u, p, f, m, g, v, y, x, _, b, w, M, T, S = this.data, E = this.t.style,
                    A = S.rotation, P = S.rotationX, L = S.rotationY, C = S.scaleX, R = S.scaleY, O = S.scaleZ, D = S.x,
                    I = S.y, N = S.z, k = S.svg, B = S.perspective, F = S.force3D, H = S.skewY, U = S.skewX;
                if (H && (U += H, A += H), ((1 === t || 0 === t) && "auto" === F && (this.tween._totalTime === this.tween._totalDuration || !this.tween._totalTime) || !F) && !N && !B && !L && !P && 1 === O || At && k || !Ot) return void (A || U || k ? (A *= z, M = U * z, T = 1e5, i = Math.cos(A) * C, a = Math.sin(A) * C, n = Math.sin(A - M) * -R, o = Math.cos(A - M) * R, M && "simple" === S.skewType && (e = Math.tan(M - H * z), e = Math.sqrt(1 + e * e), n *= e, o *= e, H && (e = Math.tan(H * z), e = Math.sqrt(1 + e * e), i *= e, a *= e)), k && (D += S.xOrigin - (S.xOrigin * i + S.yOrigin * n) + S.xOffset, I += S.yOrigin - (S.xOrigin * a + S.yOrigin * o) + S.yOffset, At && (S.xPercent || S.yPercent) && (g = this.t.getBBox(), D += .01 * S.xPercent * g.width, I += .01 * S.yPercent * g.height), g = 1e-6, g > D && D > -g && (D = 0), g > I && I > -g && (I = 0)), _ = (i * T | 0) / T + "," + (a * T | 0) / T + "," + (n * T | 0) / T + "," + (o * T | 0) / T + "," + D + "," + I + ")", k && At ? this.t.setAttribute("transform", "matrix(" + _) : E[Lt] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix(" : "matrix(") + _) : E[Lt] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix(" : "matrix(") + C + ",0,0," + R + "," + D + "," + I + ")");
                if (d && (g = 1e-4, g > C && C > -g && (C = O = 2e-5), g > R && R > -g && (R = O = 2e-5), !B || S.z || S.rotationX || S.rotationY || (B = 0)), A || U) A *= z, v = i = Math.cos(A), y = a = Math.sin(A), U && (A -= U * z, v = Math.cos(A), y = Math.sin(A), "simple" === S.skewType && (e = Math.tan((U - H) * z), e = Math.sqrt(1 + e * e), v *= e, y *= e, S.skewY && (e = Math.tan(H * z), e = Math.sqrt(1 + e * e), i *= e, a *= e))), n = -y, o = v; else {
                    if (!(L || P || 1 !== O || B || k)) return void (E[Lt] = (S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) translate3d(" : "translate3d(") + D + "px," + I + "px," + N + "px)" + (1 !== C || 1 !== R ? " scale(" + C + "," + R + ")" : ""));
                    i = o = 1, n = a = 0
                }
                h = 1, r = s = l = c = u = p = 0, f = B ? -1 / B : 0, m = S.zOrigin, g = 1e-6, b = ",", w = "0", A = L * z, A && (v = Math.cos(A), y = Math.sin(A), l = -y, u = f * -y, r = i * y, s = a * y, h = v, f *= v, i *= v, a *= v), A = P * z, A && (v = Math.cos(A), y = Math.sin(A), e = n * v + r * y, x = o * v + s * y, c = h * y, p = f * y, r = n * -y + r * v, s = o * -y + s * v, h *= v, f *= v, n = e, o = x), 1 !== O && (r *= O, s *= O, h *= O, f *= O), 1 !== R && (n *= R, o *= R, c *= R, p *= R), 1 !== C && (i *= C, a *= C, l *= C, u *= C), (m || k) && (m && (D += r * -m, I += s * -m, N += h * -m + m), k && (D += S.xOrigin - (S.xOrigin * i + S.yOrigin * n) + S.xOffset, I += S.yOrigin - (S.xOrigin * a + S.yOrigin * o) + S.yOffset), g > D && D > -g && (D = w), g > I && I > -g && (I = w), g > N && N > -g && (N = 0)), _ = S.xPercent || S.yPercent ? "translate(" + S.xPercent + "%," + S.yPercent + "%) matrix3d(" : "matrix3d(", _ += (g > i && i > -g ? w : i) + b + (g > a && a > -g ? w : a) + b + (g > l && l > -g ? w : l),
                    _ += b + (g > u && u > -g ? w : u) + b + (g > n && n > -g ? w : n) + b + (g > o && o > -g ? w : o), P || L || 1 !== O ? (_ += b + (g > c && c > -g ? w : c) + b + (g > p && p > -g ? w : p) + b + (g > r && r > -g ? w : r), _ += b + (g > s && s > -g ? w : s) + b + (g > h && h > -g ? w : h) + b + (g > f && f > -g ? w : f) + b) : _ += ",0,0,0,0,1,0,", _ += D + b + I + b + N + b + (B ? 1 + -N / B : 1) + ")", E[Lt] = _
            };
        c = Dt.prototype, c.x = c.y = c.z = c.skewX = c.skewY = c.rotation = c.rotationX = c.rotationY = c.zOrigin = c.xPercent = c.yPercent = c.xOffset = c.yOffset = 0, c.scaleX = c.scaleY = c.scaleZ = 1, St("transform,scale,scaleX,scaleY,scaleZ,x,y,z,rotation,rotationX,rotationY,rotationZ,skewX,skewY,shortRotation,shortRotationX,shortRotationY,shortRotationZ,transformOrigin,svgOrigin,transformPerspective,directionalRotation,parseTransform,force3D,skewType,xPercent,yPercent,smoothOrigin", {
            parser: function (t, e, i, n, a, s, l) {
                if (n._lastParsedTransform === l) return a;
                n._lastParsedTransform = l;
                var c = l.scale && "function" == typeof l.scale ? l.scale : 0;
                c && (l.scale = c(v, t));
                var h, u, p, d, f, m, y, x, _, b = t._gsTransform, w = t.style, M = 1e-6, T = Pt.length, S = l, E = {},
                    A = "transformOrigin", P = Vt(t, r, !0, S.parseTransform),
                    L = S.transform && ("function" == typeof S.transform ? S.transform(v, g) : S.transform);
                if (P.skewType = S.skewType || P.skewType || o.defaultSkewType, n._transform = P, "rotationZ" in S && (S.rotation = S.rotationZ), L && "string" == typeof L && Lt) u = G.style, u[Lt] = L, u.display = "block", u.position = "absolute", -1 !== L.indexOf("%") && (u.width = tt(t, "width"), u.height = tt(t, "height")), H.body.appendChild(G), h = Vt(G, null, !1), "simple" === P.skewType && (h.scaleY *= Math.cos(h.skewX * z)), P.svg && (m = P.xOrigin, y = P.yOrigin, h.x -= P.xOffset, h.y -= P.yOffset, (S.transformOrigin || S.svgOrigin) && (L = {}, Bt(t, lt(S.transformOrigin), L, S.svgOrigin, S.smoothOrigin, !0), m = L.xOrigin, y = L.yOrigin, h.x -= L.xOffset - P.xOffset, h.y -= L.yOffset - P.yOffset), (m || y) && (x = jt(G, !0), h.x -= m - (m * x[0] + y * x[2]), h.y -= y - (m * x[1] + y * x[3]))), H.body.removeChild(G), h.perspective || (h.perspective = P.perspective), null != S.xPercent && (h.xPercent = ht(S.xPercent, P.xPercent)), null != S.yPercent && (h.yPercent = ht(S.yPercent, P.yPercent)); else if ("object" == typeof S) {
                    if (h = {
                        scaleX: ht(null != S.scaleX ? S.scaleX : S.scale, P.scaleX),
                        scaleY: ht(null != S.scaleY ? S.scaleY : S.scale, P.scaleY),
                        scaleZ: ht(S.scaleZ, P.scaleZ),
                        x: ht(S.x, P.x),
                        y: ht(S.y, P.y),
                        z: ht(S.z, P.z),
                        xPercent: ht(S.xPercent, P.xPercent),
                        yPercent: ht(S.yPercent, P.yPercent),
                        perspective: ht(S.transformPerspective, P.perspective)
                    }, null != (f = S.directionalRotation)) if ("object" == typeof f) for (u in f) S[u] = f[u]; else S.rotation = f;
                    "string" == typeof S.x && -1 !== S.x.indexOf("%") && (h.x = 0, h.xPercent = ht(S.x, P.xPercent)), "string" == typeof S.y && -1 !== S.y.indexOf("%") && (h.y = 0, h.yPercent = ht(S.y, P.yPercent)), h.rotation = ut("rotation" in S ? S.rotation : "shortRotation" in S ? S.shortRotation + "_short" : P.rotation, P.rotation, "rotation", E), Ot && (h.rotationX = ut("rotationX" in S ? S.rotationX : "shortRotationX" in S ? S.shortRotationX + "_short" : P.rotationX || 0, P.rotationX, "rotationX", E), h.rotationY = ut("rotationY" in S ? S.rotationY : "shortRotationY" in S ? S.shortRotationY + "_short" : P.rotationY || 0, P.rotationY, "rotationY", E)), h.skewX = ut(S.skewX, P.skewX), h.skewY = ut(S.skewY, P.skewY)
                }
                for (Ot && null != S.force3D && (P.force3D = S.force3D, d = !0), (p = P.force3D || P.z || P.rotationX || P.rotationY || h.z || h.rotationX || h.rotationY || h.perspective) || null == S.scale || (h.scaleZ = 1); --T > -1;) _ = Pt[T], ((L = h[_] - P[_]) > 1e-6 || -1e-6 > L || null != S[_] || null != B[_]) && (d = !0, a = new _t(P, _, P[_], L, a), _ in E && (a.e = E[_]), a.xs0 = 0, a.plugin = s, n._overwriteProps.push(a.n));
                return L = "function" == typeof S.transformOrigin ? S.transformOrigin(v, g) : S.transformOrigin, P.svg && (L || S.svgOrigin) && (m = P.xOffset, y = P.yOffset, Bt(t, lt(L), h, S.svgOrigin, S.smoothOrigin), a = bt(P, "xOrigin", (b ? P : h).xOrigin, h.xOrigin, a, A), a = bt(P, "yOrigin", (b ? P : h).yOrigin, h.yOrigin, a, A), (m !== P.xOffset || y !== P.yOffset) && (a = bt(P, "xOffset", b ? m : P.xOffset, P.xOffset, a, A), a = bt(P, "yOffset", b ? y : P.yOffset, P.yOffset, a, A)), L = "0px 0px"), (L || Ot && p && P.zOrigin) && (Lt ? (d = !0, _ = Rt, L || (L = (tt(t, _, r, !1, "50% 50%") + "").split(" "), L = L[0] + " " + L[1] + " " + P.zOrigin + "px"), L += "", a = new _t(w, _, 0, 0, a, -1, A), a.b = w[_], a.plugin = s, Ot ? (u = P.zOrigin, L = L.split(" "), P.zOrigin = (L.length > 2 ? parseFloat(L[2]) : u) || 0, a.xs0 = a.e = L[0] + " " + (L[1] || "50%") + " 0px", a = new _t(P, "zOrigin", 0, 0, a, -1, a.n), a.b = u, a.xs0 = a.e = P.zOrigin) : a.xs0 = a.e = L) : lt(L + "", P)), d && (n._transformType = P.svg && At || !p && 3 !== this._transformType ? 2 : 3), c && (l.scale = c), a
            }, allowFunc: !0, prefix: !0
        }), St("boxShadow", {
            defaultValue: "0px 0px 0px 0px #999",
            prefix: !0,
            color: !0,
            multi: !0,
            keyword: "inset"
        }), St("clipPath", {
            defaultValue: "inset(0px)",
            prefix: !0,
            multi: !0,
            formatter: vt("inset(0px 0px 0px 0px)", !1, !0)
        }), St("borderRadius", {
            defaultValue: "0px", parser: function (t, e, i, a, o, s) {
                e = this.format(e);
                var l, c, h, u, p, d, f, m, g, v, y, x, _, b, w, M,
                    T = ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomRightRadius", "borderBottomLeftRadius"],
                    S = t.style;
                for (g = parseFloat(t.offsetWidth), v = parseFloat(t.offsetHeight), l = e.split(" "), c = 0; c < T.length; c++) this.p.indexOf("border") && (T[c] = Q(T[c])), p = u = tt(t, T[c], r, !1, "0px"), -1 !== p.indexOf(" ") && (u = p.split(" "), p = u[0], u = u[1]), d = h = l[c], f = parseFloat(p), x = p.substr((f + "").length), _ = "=" === d.charAt(1), _ ? (m = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), m *= parseFloat(d), y = d.substr((m + "").length - (0 > m ? 1 : 0)) || "") : (m = parseFloat(d), y = d.substr((m + "").length)), "" === y && (y = n[i] || x), y !== x && (b = et(t, "borderLeft", f, x), w = et(t, "borderTop", f, x), "%" === y ? (p = b / g * 100 + "%", u = w / v * 100 + "%") : "em" === y ? (M = et(t, "borderLeft", 1, "em"), p = b / M + "em", u = w / M + "em") : (p = b + "px", u = w + "px"), _ && (d = parseFloat(p) + m + y, h = parseFloat(u) + m + y)), o = wt(S, T[c], p + " " + u, d + " " + h, !1, "0px", o);
                return o
            }, prefix: !0, formatter: vt("0px 0px 0px 0px", !1, !0)
        }), St("borderBottomLeftRadius,borderBottomRightRadius,borderTopLeftRadius,borderTopRightRadius", {
            defaultValue: "0px",
            parser: function (t, e, i, n, a, o) {
                return wt(t.style, i, this.format(tt(t, i, r, !1, "0px 0px")), this.format(e), !1, "0px", a)
            },
            prefix: !0,
            formatter: vt("0px 0px", !1, !0)
        }), St("backgroundPosition", {
            defaultValue: "0 0", parser: function (t, e, i, n, a, o) {
                var s, l, c, h, u, p, d = "background-position", f = r || K(t, null),
                    g = this.format((f ? m ? f.getPropertyValue(d + "-x") + " " + f.getPropertyValue(d + "-y") : f.getPropertyValue(d) : t.currentStyle.backgroundPositionX + " " + t.currentStyle.backgroundPositionY) || "0 0"),
                    v = this.format(e);
                if (-1 !== g.indexOf("%") != (-1 !== v.indexOf("%")) && v.split(",").length < 2 && (p = tt(t, "backgroundImage").replace(/(^(?:url\(\"|url\())|(?:(\"\))$|\)$)/gi, "")) && "none" !== p) {
                    for (s = g.split(" "), l = v.split(" "), j.setAttribute("src", p), c = 2; --c > -1;) g = s[c], (h = -1 !== g.indexOf("%")) !== (-1 !== l[c].indexOf("%")) && (u = 0 === c ? t.offsetWidth - j.width : t.offsetHeight - j.height, s[c] = h ? parseFloat(g) / 100 * u + "px" : parseFloat(g) / u * 100 + "%");
                    g = s.join(" ")
                }
                return this.parseComplex(t.style, g, v, a, o)
            }, formatter: lt
        }), St("backgroundSize", {
            defaultValue: "0 0", formatter: function (t) {
                return t += "", "co" === t.substr(0, 2) ? t : lt(-1 === t.indexOf(" ") ? t + " " + t : t)
            }
        }), St("perspective", {defaultValue: "0px", prefix: !0}), St("perspectiveOrigin", {
            defaultValue: "50% 50%",
            prefix: !0
        }), St("transformStyle", {prefix: !0}), St("backfaceVisibility", {prefix: !0}), St("userSelect", {prefix: !0}), St("margin", {parser: yt("marginTop,marginRight,marginBottom,marginLeft")}), St("padding", {parser: yt("paddingTop,paddingRight,paddingBottom,paddingLeft")}), St("clip", {
            defaultValue: "rect(0px,0px,0px,0px)",
            parser: function (t, e, i, n, a, o) {
                var s, l, c;
                return 9 > m ? (l = t.currentStyle, c = 8 > m ? " " : ",", s = "rect(" + l.clipTop + c + l.clipRight + c + l.clipBottom + c + l.clipLeft + ")", e = this.format(e).split(",").join(c)) : (s = this.format(tt(t, this.p, r, !1, this.dflt)), e = this.format(e)), this.parseComplex(t.style, s, e, a, o)
            }
        }), St("textShadow", {
            defaultValue: "0px 0px 0px #999",
            color: !0,
            multi: !0
        }), St("autoRound,strictUnits", {
            parser: function (t, e, i, n, r) {
                return r
            }
        }), St("border", {
            defaultValue: "0px solid #000", parser: function (t, e, i, n, a, o) {
                var s = tt(t, "borderTopWidth", r, !1, "0px"), l = this.format(e).split(" "), c = l[0].replace(w, "");
                return "px" !== c && (s = parseFloat(s) / et(t, "borderTopWidth", 1, c) + c), this.parseComplex(t.style, this.format(s + " " + tt(t, "borderTopStyle", r, !1, "solid") + " " + tt(t, "borderTopColor", r, !1, "#000")), l.join(" "), a, o)
            }, color: !0, formatter: function (t) {
                var e = t.split(" ");
                return e[0] + " " + (e[1] || "solid") + " " + (t.match(gt) || ["#000"])[0]
            }
        }), St("borderWidth", {parser: yt("borderTopWidth,borderRightWidth,borderBottomWidth,borderLeftWidth")}), St("float,cssFloat,styleFloat", {
            parser: function (t, e, i, n, r, a) {
                var o = t.style, s = "cssFloat" in o ? "cssFloat" : "styleFloat";
                return new _t(o, s, 0, 0, r, -1, i, !1, 0, o[s], e)
            }
        });
        var Xt = function (t) {
            var e, i = this.t, n = i.filter || tt(this.data, "filter") || "", r = this.s + this.c * t | 0;
            100 === r && (-1 === n.indexOf("atrix(") && -1 === n.indexOf("radient(") && -1 === n.indexOf("oader(") ? (i.removeAttribute("filter"), e = !tt(this.data, "filter")) : (i.filter = n.replace(/alpha\(opacity *=.+?\)/i, ""), e = !0)), e || (this.xn1 && (i.filter = n = n || "alpha(opacity=" + r + ")"), -1 === n.indexOf("pacity") ? 0 === r && this.xn1 || (i.filter = n + " alpha(opacity=" + r + ")") : i.filter = n.replace(M, "opacity=" + r))
        };
        St("opacity,alpha,autoAlpha", {
            defaultValue: "1", parser: function (t, e, i, n, a, o) {
                var s = parseFloat(tt(t, "opacity", r, !1, "1")), l = t.style, c = "autoAlpha" === i;
                return "string" == typeof e && "=" === e.charAt(1) && (e = ("-" === e.charAt(0) ? -1 : 1) * parseFloat(e.substr(2)) + s), c && 1 === s && "hidden" === tt(t, "visibility", r) && 0 !== e && (s = 0), q ? a = new _t(l, "opacity", s, e - s, a) : (a = new _t(l, "opacity", 100 * s, 100 * (e - s), a), a.xn1 = c ? 1 : 0, l.zoom = 1, a.type = 2, a.b = "alpha(opacity=" + a.s + ")", a.e = "alpha(opacity=" + (a.s + a.c) + ")", a.data = t, a.plugin = o, a.setRatio = Xt), c && (a = new _t(l, "visibility", 0, 0, a, -1, null, !1, 0, 0 !== s ? "inherit" : "hidden", 0 === e ? "hidden" : "inherit"), a.xs0 = "inherit", n._overwriteProps.push(a.n), n._overwriteProps.push(i)), a
            }
        });
        var Yt = function (t, e) {
            e && (t.removeProperty ? (("ms" === e.substr(0, 2) || "webkit" === e.substr(0, 6)) && (e = "-" + e), t.removeProperty(e.replace(A, "-$1").toLowerCase())) : t.removeAttribute(e))
        }, Jt = function (t) {
            if (this.t._gsClassPT = this, 1 === t || 0 === t) {
                this.t.setAttribute("class", 0 === t ? this.b : this.e);
                for (var e = this.data, i = this.t.style; e;) e.v ? i[e.p] = e.v : Yt(i, e.p), e = e._next;
                1 === t && this.t._gsClassPT === this && (this.t._gsClassPT = null)
            } else this.t.getAttribute("class") !== this.e && this.t.setAttribute("class", this.e)
        };
        St("className", {
            parser: function (t, e, n, a, o, s, l) {
                var c, h, u, p, d, f = t.getAttribute("class") || "", m = t.style.cssText;
                if (o = a._classNamePT = new _t(t, n, 0, 0, o, 2), o.setRatio = Jt, o.pr = -11, i = !0, o.b = f, h = nt(t, r), u = t._gsClassPT) {
                    for (p = {}, d = u.data; d;) p[d.p] = 1, d = d._next;
                    u.setRatio(1)
                }
                return t._gsClassPT = o, o.e = "=" !== e.charAt(1) ? e : f.replace(new RegExp("(?:\\s|^)" + e.substr(2) + "(?![\\w-])"), "") + ("+" === e.charAt(0) ? " " + e.substr(2) : ""), t.setAttribute("class", o.e), c = rt(t, h, nt(t), l, p), t.setAttribute("class", f), o.data = c.firstMPT, t.style.cssText = m, o = o.xfirst = a.parse(t, c.difs, o, s)
            }
        });
        var Zt = function (t) {
            if ((1 === t || 0 === t) && this.data._totalTime === this.data._totalDuration && "isFromStart" !== this.data.data) {
                var e, i, n, r, a, o = this.t.style, s = l.transform.parse;
                if ("all" === this.e) o.cssText = "", r = !0; else for (e = this.e.split(" ").join("").split(","), n = e.length; --n > -1;) i = e[n], l[i] && (l[i].parse === s ? r = !0 : i = "transformOrigin" === i ? Rt : l[i].p), Yt(o, i);
                r && (Yt(o, Lt), (a = this.t._gsTransform) && (a.svg && (this.t.removeAttribute("data-svg-origin"), this.t.removeAttribute("transform")), delete this.t._gsTransform))
            }
        };
        for (St("clearProps", {
            parser: function (t, e, n, r, a) {
                return a = new _t(t, n, 0, 0, a, 2), a.setRatio = Zt, a.e = e, a.pr = -10, a.data = r._tween, i = !0, a
            }
        }), c = "bezier,throwProps,physicsProps,physics2D".split(","), Mt = c.length; Mt--;) Et(c[Mt]);
        c = o.prototype, c._firstPT = c._lastParsedTransform = c._transform = null, c._onInitTween = function (t, e, s, c) {
            if (!t.nodeType) return !1;
            this._target = g = t, this._tween = s, this._vars = e, v = c, h = e.autoRound, i = !1, n = e.suffixMap || o.suffixMap, r = K(t, ""), a = this._overwriteProps;
            var d, m, y, x, _, b, w, M, S, E = t.style;
            if (u && "" === E.zIndex && ("auto" === (d = tt(t, "zIndex", r)) || "" === d) && this._addLazySet(E, "zIndex", 0), "string" == typeof e && (x = E.cssText, d = nt(t, r), E.cssText = x + ";" + e, d = rt(t, d, nt(t)).difs, !q && T.test(e) && (d.opacity = parseFloat(RegExp.$1)), e = d, E.cssText = x), e.className ? this._firstPT = m = l.className.parse(t, e.className, "className", this, null, null, e) : this._firstPT = m = this.parse(t, e, null), this._transformType) {
                for (S = 3 === this._transformType, Lt ? p && (u = !0, "" === E.zIndex && ("auto" === (w = tt(t, "zIndex", r)) || "" === w) && this._addLazySet(E, "zIndex", 0), f && this._addLazySet(E, "WebkitBackfaceVisibility", this._vars.WebkitBackfaceVisibility || (S ? "visible" : "hidden"))) : E.zoom = 1, y = m; y && y._next;) y = y._next;
                M = new _t(t, "transform", 0, 0, null, 2), this._linkCSSP(M, null, y), M.setRatio = Lt ? qt : Wt, M.data = this._transform || Vt(t, r, !0), M.tween = s, M.pr = -1, a.pop()
            }
            if (i) {
                for (; m;) {
                    for (b = m._next, y = x; y && y.pr > m.pr;) y = y._next;
                    (m._prev = y ? y._prev : _) ? m._prev._next = m : x = m, (m._next = y) ? y._prev = m : _ = m, m = b
                }
                this._firstPT = x
            }
            return !0
        }, c.parse = function (t, e, i, a) {
            var o, s, c, u, p, d, f, m, y, x, _ = t.style;
            for (o in e) {
                if (d = e[o], s = l[o], "function" != typeof d || s && s.allowFunc || (d = d(v, g)), s) i = s.parse(t, d, o, this, i, a, e); else {
                    if ("--" === o.substr(0, 2)) {
                        this._tween._propLookup[o] = this._addTween.call(this._tween, t.style, "setProperty", K(t).getPropertyValue(o) + "", d + "", o, !1, o);
                        continue
                    }
                    p = tt(t, o, r) + "", y = "string" == typeof d, "color" === o || "fill" === o || "stroke" === o || -1 !== o.indexOf("Color") || y && E.test(d) ? (y || (d = ft(d), d = (d.length > 3 ? "rgba(" : "rgb(") + d.join(",") + ")"), i = wt(_, o, p, d, !0, "transparent", i, 0, a)) : y && N.test(d) ? i = wt(_, o, p, d, !0, null, i, 0, a) : (c = parseFloat(p), f = c || 0 === c ? p.substr((c + "").length) : "", ("" === p || "auto" === p) && ("width" === o || "height" === o ? (c = st(t, o, r), f = "px") : "left" === o || "top" === o ? (c = it(t, o, r), f = "px") : (c = "opacity" !== o ? 0 : 1, f = "")), x = y && "=" === d.charAt(1), x ? (u = parseInt(d.charAt(0) + "1", 10), d = d.substr(2), u *= parseFloat(d), m = d.replace(w, "")) : (u = parseFloat(d), m = y ? d.replace(w, "") : ""), "" === m && (m = o in n ? n[o] : f), d = u || 0 === u ? (x ? u + c : u) + m : e[o], f !== m && ("" !== m || "lineHeight" === o) && (u || 0 === u) && c && (c = et(t, o, c, f), "%" === m ? (c /= et(t, o, 100, "%") / 100, e.strictUnits !== !0 && (p = c + "%")) : "em" === m || "rem" === m || "vw" === m || "vh" === m ? c /= et(t, o, 1, m) : "px" !== m && (u = et(t, o, u, m), m = "px"), x && (u || 0 === u) && (d = u + c + m)), x && (u += c), !c && 0 !== c || !u && 0 !== u ? void 0 !== _[o] && (d || d + "" != "NaN" && null != d) ? (i = new _t(_, o, u || c || 0, 0, i, -1, o, !1, 0, p, d), i.xs0 = "none" !== d || "display" !== o && -1 === o.indexOf("Style") ? d : p) : Y("invalid " + o + " tween value: " + e[o]) : (i = new _t(_, o, c, u - c, i, 0, o, h !== !1 && ("px" === m || "zIndex" === o), 0, p, d), i.xs0 = m))
                }
                a && i && !i.plugin && (i.plugin = a)
            }
            return i
        }, c.setRatio = function (t) {
            var e, i, n, r = this._firstPT, a = 1e-6;
            if (1 !== t || this._tween._time !== this._tween._duration && 0 !== this._tween._time) if (t || this._tween._time !== this._tween._duration && 0 !== this._tween._time || this._tween._rawPrevTime === -1e-6) for (; r;) {
                if (e = r.c * t + r.s, r.r ? e = r.r(e) : 1e-6 > e && e > -1e-6 && (e = 0), r.type) if (1 === r.type) if (2 === (n = r.l)) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2; else if (3 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3; else if (4 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4; else if (5 === n) r.t[r.p] = r.xs0 + e + r.xs1 + r.xn1 + r.xs2 + r.xn2 + r.xs3 + r.xn3 + r.xs4 + r.xn4 + r.xs5; else {
                    for (i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                    r.t[r.p] = i
                } else -1 === r.type ? r.t[r.p] = r.xs0 : r.setRatio && r.setRatio(t); else r.t[r.p] = e + r.xs0;
                r = r._next
            } else for (; r;) 2 !== r.type ? r.t[r.p] = r.b : r.setRatio(t), r = r._next; else for (; r;) {
                if (2 !== r.type) if (r.r && -1 !== r.type) if (e = r.r(r.s + r.c), r.type) {
                    if (1 === r.type) {
                        for (n = r.l, i = r.xs0 + e + r.xs1, n = 1; n < r.l; n++) i += r["xn" + n] + r["xs" + (n + 1)];
                        r.t[r.p] = i
                    }
                } else r.t[r.p] = e + r.xs0; else r.t[r.p] = r.e; else r.setRatio(t);
                r = r._next
            }
        }, c._enableTransforms = function (t) {
            this._transform = this._transform || Vt(this._target, r, !0), this._transformType = this._transform.svg && At || !t && 3 !== this._transformType ? 2 : 3
        };
        var $t = function (t) {
            this.t[this.p] = this.e, this.data._linkCSSP(this, this._next, null, !0)
        };
        c._addLazySet = function (t, e, i) {
            var n = this._firstPT = new _t(t, e, 0, 0, this._firstPT, 2);
            n.e = i, n.setRatio = $t, n.data = this
        }, c._linkCSSP = function (t, e, i, n) {
            return t && (e && (e._prev = t), t._next && (t._next._prev = t._prev), t._prev ? t._prev._next = t._next : this._firstPT === t && (this._firstPT = t._next, n = !0), i ? i._next = t : n || null !== this._firstPT || (this._firstPT = t), t._next = e, t._prev = i), t
        }, c._mod = function (t) {
            for (var e = this._firstPT; e;) "function" == typeof t[e.p] && (e.r = t[e.p]), e = e._next
        }, c._kill = function (e) {
            var i, n, r, a = e;
            if (e.autoAlpha || e.alpha) {
                a = {};
                for (n in e) a[n] = e[n];
                a.opacity = 1, a.autoAlpha && (a.visibility = 1)
            }
            for (e.className && (i = this._classNamePT) && (r = i.xfirst, r && r._prev ? this._linkCSSP(r._prev, i._next, r._prev._prev) : r === this._firstPT && (this._firstPT = i._next), i._next && this._linkCSSP(i._next, i._next._next, r._prev), this._classNamePT = null), i = this._firstPT; i;) i.plugin && i.plugin !== n && i.plugin._kill && (i.plugin._kill(e), n = i.plugin), i = i._next;
            return t.prototype._kill.call(this, a)
        };
        var Qt = function (t, e, i) {
            var n, r, a, o;
            if (t.slice) for (r = t.length; --r > -1;) Qt(t[r], e, i); else for (n = t.childNodes, r = n.length; --r > -1;) a = n[r], o = a.type, a.style && (e.push(nt(a)), i && i.push(a)), 1 !== o && 9 !== o && 11 !== o || !a.childNodes.length || Qt(a, e, i)
        };
        return o.cascadeTo = function (t, i, n) {
            var r, a, o, s, l = e.to(t, i, n), c = [l], h = [], u = [], p = [], d = e._internals.reservedProps;
            for (t = l._targets || l.target, Qt(t, h, p), l.render(i, !0, !0), Qt(t, u), l.render(0, !0, !0), l._enabled(!0), r = p.length; --r > -1;) if (a = rt(p[r], h[r], u[r]), a.firstMPT) {
                a = a.difs;
                for (o in n) d[o] && (a[o] = n[o]);
                s = {};
                for (o in a) s[o] = h[r][o];
                c.push(e.fromTo(p[r], i, s, a))
            }
            return c
        }, t.activate([o]), o
    }, !0), function () {
        var t = _gsScope._gsDefine.plugin({
            propName: "roundProps",
            version: "1.7.0",
            priority: -1,
            API: 2,
            init: function (t, e, i) {
                return this._tween = i, !0
            }
        }), e = function (t) {
            var e = 1 > t ? Math.pow(10, (t + "").length - 2) : 1;
            return function (i) {
                return (Math.round(i / t) * t * e | 0) / e
            }
        }, i = function (t, e) {
            for (; t;) t.f || t.blob || (t.m = e || Math.round), t = t._next
        }, n = t.prototype;
        n._onInitAllProps = function () {
            var t, n, r, a, o = this._tween, s = o.vars.roundProps, l = {}, c = o._propLookup.roundProps;
            if ("object" != typeof s || s.push) for ("string" == typeof s && (s = s.split(",")), r = s.length; --r > -1;) l[s[r]] = Math.round; else for (a in s) l[a] = e(s[a]);
            for (a in l) for (t = o._firstPT; t;) n = t._next, t.pg ? t.t._mod(l) : t.n === a && (2 === t.f && t.t ? i(t.t._firstPT, l[a]) : (this._add(t.t, a, t.s, t.c, l[a]), n && (n._prev = t._prev), t._prev ? t._prev._next = n : o._firstPT === t && (o._firstPT = n), t._next = t._prev = null, o._propLookup[a] = c)), t = n;
            return !1
        }, n._add = function (t, e, i, n, r) {
            this._addTween(t, e, i, i + n, e, r || Math.round), this._overwriteProps.push(e)
        }
    }(), function () {
        _gsScope._gsDefine.plugin({
            propName: "attr", API: 2, version: "0.6.1", init: function (t, e, i, n) {
                var r, a;
                if ("function" != typeof t.setAttribute) return !1;
                for (r in e) a = e[r], "function" == typeof a && (a = a(n, t)), this._addTween(t, "setAttribute", t.getAttribute(r) + "", a + "", r, !1, r), this._overwriteProps.push(r);
                return !0
            }
        })
    }(), _gsScope._gsDefine.plugin({
        propName: "directionalRotation",
        version: "0.3.1",
        API: 2,
        init: function (t, e, i, n) {
            "object" != typeof e && (e = {rotation: e}), this.finals = {};
            var r, a, o, s, l, c, h = e.useRadians === !0 ? 2 * Math.PI : 360, u = 1e-6;
            for (r in e) "useRadians" !== r && (s = e[r], "function" == typeof s && (s = s(n, t)), c = (s + "").split("_"), a = c[0], o = parseFloat("function" != typeof t[r] ? t[r] : t[r.indexOf("set") || "function" != typeof t["get" + r.substr(3)] ? r : "get" + r.substr(3)]()), s = this.finals[r] = "string" == typeof a && "=" === a.charAt(1) ? o + parseInt(a.charAt(0) + "1", 10) * Number(a.substr(2)) : Number(a) || 0, l = s - o, c.length && (a = c.join("_"), -1 !== a.indexOf("short") && (l %= h) !== l % (h / 2) && (l = 0 > l ? l + h : l - h), -1 !== a.indexOf("_cw") && 0 > l ? l = (l + 9999999999 * h) % h - (l / h | 0) * h : -1 !== a.indexOf("ccw") && l > 0 && (l = (l - 9999999999 * h) % h - (l / h | 0) * h)), (l > 1e-6 || -1e-6 > l) && (this._addTween(t, r, o, o + l, r), this._overwriteProps.push(r)));
            return !0
        },
        set: function (t) {
            var e;
            if (1 !== t) this._super.setRatio.call(this, t); else for (e = this._firstPT; e;) e.f ? e.t[e.p](this.finals[e.p]) : e.t[e.p] = this.finals[e.p], e = e._next
        }
    })._autoCSS = !0, _gsScope._gsDefine("easing.Back", ["easing.Ease"], function (t) {
        var e, i, n, r, a = _gsScope.GreenSockGlobals || _gsScope, o = a.com.greensock, s = 2 * Math.PI,
            l = Math.PI / 2, c = o._class, h = function (e, i) {
                var n = c("easing." + e, function () {
                }, !0), r = n.prototype = new t;
                return r.constructor = n, r.getRatio = i, n
            }, u = t.register || function () {
            }, p = function (t, e, i, n, r) {
                var a = c("easing." + t, {easeOut: new e, easeIn: new i, easeInOut: new n}, !0);
                return u(a, t), a
            }, d = function (t, e, i) {
                this.t = t, this.v = e, i && (this.next = i, i.prev = this, this.c = i.v - e, this.gap = i.t - t)
            }, f = function (e, i) {
                var n = c("easing." + e, function (t) {
                    this._p1 = t || 0 === t ? t : 1.70158, this._p2 = 1.525 * this._p1
                }, !0), r = n.prototype = new t;
                return r.constructor = n, r.getRatio = i, r.config = function (t) {
                    return new n(t)
                }, n
            }, m = p("Back", f("BackOut", function (t) {
                return (t -= 1) * t * ((this._p1 + 1) * t + this._p1) + 1
            }), f("BackIn", function (t) {
                return t * t * ((this._p1 + 1) * t - this._p1)
            }), f("BackInOut", function (t) {
                return (t *= 2) < 1 ? .5 * t * t * ((this._p2 + 1) * t - this._p2) : .5 * ((t -= 2) * t * ((this._p2 + 1) * t + this._p2) + 2)
            })), g = c("easing.SlowMo", function (t, e, i) {
                e = e || 0 === e ? e : .7, null == t ? t = .7 : t > 1 && (t = 1), this._p = 1 !== t ? e : 0, this._p1 = (1 - t) / 2, this._p2 = t, this._p3 = this._p1 + this._p2, this._calcEnd = i === !0
            }, !0), v = g.prototype = new t;
        return v.constructor = g, v.getRatio = function (t) {
            var e = t + (.5 - t) * this._p;
            return t < this._p1 ? this._calcEnd ? 1 - (t = 1 - t / this._p1) * t : e - (t = 1 - t / this._p1) * t * t * t * e : t > this._p3 ? this._calcEnd ? 1 === t ? 0 : 1 - (t = (t - this._p3) / this._p1) * t : e + (t - e) * (t = (t - this._p3) / this._p1) * t * t * t : this._calcEnd ? 1 : e
        }, g.ease = new g(.7, .7), v.config = g.config = function (t, e, i) {
            return new g(t, e, i)
        }, e = c("easing.SteppedEase", function (t, e) {
            t = t || 1, this._p1 = 1 / t, this._p2 = t + (e ? 0 : 1), this._p3 = e ? 1 : 0
        }, !0), v = e.prototype = new t, v.constructor = e, v.getRatio = function (t) {
            return 0 > t ? t = 0 : t >= 1 && (t = .999999999), ((this._p2 * t | 0) + this._p3) * this._p1
        }, v.config = e.config = function (t, i) {
            return new e(t, i)
        }, i = c("easing.ExpoScaleEase", function (t, e, i) {
            this._p1 = Math.log(e / t), this._p2 = e - t, this._p3 = t, this._ease = i
        }, !0), v = i.prototype = new t, v.constructor = i, v.getRatio = function (t) {
            return this._ease && (t = this._ease.getRatio(t)), (this._p3 * Math.exp(this._p1 * t) - this._p3) / this._p2
        }, v.config = i.config = function (t, e, n) {
            return new i(t, e, n)
        }, n = c("easing.RoughEase", function (e) {
            e = e || {};
            for (var i, n, r, a, o, s, l = e.taper || "none", c = [], h = 0, u = 0 | (e.points || 20), p = u, f = e.randomize !== !1, m = e.clamp === !0, g = e.template instanceof t ? e.template : null, v = "number" == typeof e.strength ? .4 * e.strength : .4; --p > -1;) i = f ? Math.random() : 1 / u * p, n = g ? g.getRatio(i) : i, "none" === l ? r = v : "out" === l ? (a = 1 - i, r = a * a * v) : "in" === l ? r = i * i * v : .5 > i ? (a = 2 * i, r = a * a * .5 * v) : (a = 2 * (1 - i), r = a * a * .5 * v), f ? n += Math.random() * r - .5 * r : p % 2 ? n += .5 * r : n -= .5 * r, m && (n > 1 ? n = 1 : 0 > n && (n = 0)), c[h++] = {
                x: i,
                y: n
            };
            for (c.sort(function (t, e) {
                return t.x - e.x
            }), s = new d(1, 1, null), p = u; --p > -1;) o = c[p], s = new d(o.x, o.y, s);
            this._prev = new d(0, 0, 0 !== s.t ? s : s.next)
        }, !0), v = n.prototype = new t, v.constructor = n, v.getRatio = function (t) {
            var e = this._prev;
            if (t > e.t) {
                for (; e.next && t >= e.t;) e = e.next;
                e = e.prev
            } else for (; e.prev && t <= e.t;) e = e.prev;
            return this._prev = e, e.v + (t - e.t) / e.gap * e.c
        }, v.config = function (t) {
            return new n(t)
        }, n.ease = new n, p("Bounce", h("BounceOut", function (t) {
            return 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
        }), h("BounceIn", function (t) {
            return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : 2 / 2.75 > t ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + .75) : 2.5 / 2.75 > t ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + .9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + .984375)
        }), h("BounceInOut", function (t) {
            var e = .5 > t;
            return t = e ? 1 - 2 * t : 2 * t - 1, t = 1 / 2.75 > t ? 7.5625 * t * t : 2 / 2.75 > t ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : 2.5 / 2.75 > t ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375, e ? .5 * (1 - t) : .5 * t + .5
        })), p("Circ", h("CircOut", function (t) {
            return Math.sqrt(1 - (t -= 1) * t)
        }), h("CircIn", function (t) {
            return -(Math.sqrt(1 - t * t) - 1)
        }), h("CircInOut", function (t) {
            return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
        })), r = function (e, i, n) {
            var r = c("easing." + e, function (t, e) {
                this._p1 = t >= 1 ? t : 1, this._p2 = (e || n) / (1 > t ? t : 1), this._p3 = this._p2 / s * (Math.asin(1 / this._p1) || 0), this._p2 = s / this._p2
            }, !0), a = r.prototype = new t;
            return a.constructor = r, a.getRatio = i, a.config = function (t, e) {
                return new r(t, e)
            }, r
        }, p("Elastic", r("ElasticOut", function (t) {
            return this._p1 * Math.pow(2, -10 * t) * Math.sin((t - this._p3) * this._p2) + 1
        }, .3), r("ElasticIn", function (t) {
            return -(this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2))
        }, .3), r("ElasticInOut", function (t) {
            return (t *= 2) < 1 ? -.5 * (this._p1 * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2)) : this._p1 * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - this._p3) * this._p2) * .5 + 1
        }, .45)), p("Expo", h("ExpoOut", function (t) {
            return 1 - Math.pow(2, -10 * t)
        }), h("ExpoIn", function (t) {
            return Math.pow(2, 10 * (t - 1)) - .001
        }), h("ExpoInOut", function (t) {
            return (t *= 2) < 1 ? .5 * Math.pow(2, 10 * (t - 1)) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
        })), p("Sine", h("SineOut", function (t) {
            return Math.sin(t * l)
        }), h("SineIn", function (t) {
            return 1 - Math.cos(t * l)
        }), h("SineInOut", function (t) {
            return -.5 * (Math.cos(Math.PI * t) - 1)
        })), c("easing.EaseLookup", {
            find: function (e) {
                return t.map[e]
            }
        }, !0), u(a.SlowMo, "SlowMo", "ease,"), u(n, "RoughEase", "ease,"), u(e, "SteppedEase", "ease,"), m
    }, !0)
}), _gsScope._gsDefine && _gsScope._gsQueue.pop()(), function (t, e) {
    "use strict";
    var i = {}, n = t.document, r = t.GreenSockGlobals = t.GreenSockGlobals || t, a = r[e];
    if (a) return "undefined" != typeof module && module.exports && (module.exports = a), a;
    var o, s, l, c, h, u = function (t) {
        var e, i = t.split("."), n = r;
        for (e = 0; e < i.length; e++) n[i[e]] = n = n[i[e]] || {};
        return n
    }, p = u("com.greensock"), d = 1e-8, f = function (t) {
        var e, i = [], n = t.length;
        for (e = 0; e !== n; i.push(t[e++])) ;
        return i
    }, m = function () {
    }, g = function () {
        var t = Object.prototype.toString, e = t.call([]);
        return function (i) {
            return null != i && (i instanceof Array || "object" == typeof i && !!i.push && t.call(i) === e)
        }
    }(), v = {}, y = function (n, a, o, s) {
        this.sc = v[n] ? v[n].sc : [], v[n] = this, this.gsClass = null, this.func = o;
        var l = [];
        this.check = function (c) {
            for (var h, p, d, f, m = a.length, g = m; --m > -1;) (h = v[a[m]] || new y(a[m], [])).gsClass ? (l[m] = h.gsClass, g--) : c && h.sc.push(this);
            if (0 === g && o) {
                if (p = ("com.greensock." + n).split("."), d = p.pop(), f = u(p.join("."))[d] = this.gsClass = o.apply(o, l), s) if (r[d] = i[d] = f, "undefined" != typeof module && module.exports) if (n === e) {
                    module.exports = i[e] = f;
                    for (m in i) f[m] = i[m]
                } else i[e] && (i[e][d] = f); else "function" == typeof define && define.amd && define((t.GreenSockAMDPath ? t.GreenSockAMDPath + "/" : "") + n.split(".").pop(), [], function () {
                    return f
                });
                for (m = 0; m < this.sc.length; m++) this.sc[m].check()
            }
        }, this.check(!0)
    }, x = t._gsDefine = function (t, e, i, n) {
        return new y(t, e, i, n)
    }, _ = p._class = function (t, e, i) {
        return e = e || function () {
        }, x(t, [], function () {
            return e
        }, i), e
    };
    x.globals = r;
    var b = [0, 0, 1, 1], w = _("easing.Ease", function (t, e, i, n) {
        this._func = t, this._type = i || 0, this._power = n || 0, this._params = e ? b.concat(e) : b
    }, !0), M = w.map = {}, T = w.register = function (t, e, i, n) {
        for (var r, a, o, s, l = e.split(","), c = l.length, h = (i || "easeIn,easeOut,easeInOut").split(","); --c > -1;) for (a = l[c], r = n ? _("easing." + a, null, !0) : p.easing[a] || {}, o = h.length; --o > -1;) s = h[o], M[a + "." + s] = M[s + a] = r[s] = t.getRatio ? t : t[s] || new t
    };
    for (l = w.prototype, l._calcEnd = !1, l.getRatio = function (t) {
        if (this._func) return this._params[0] = t, this._func.apply(null, this._params);
        var e = this._type, i = this._power, n = 1 === e ? 1 - t : 2 === e ? t : .5 > t ? 2 * t : 2 * (1 - t);
        return 1 === i ? n *= n : 2 === i ? n *= n * n : 3 === i ? n *= n * n * n : 4 === i && (n *= n * n * n * n), 1 === e ? 1 - n : 2 === e ? n : .5 > t ? n / 2 : 1 - n / 2
    }, o = ["Linear", "Quad", "Cubic", "Quart", "Quint,Strong"], s = o.length; --s > -1;) l = o[s] + ",Power" + s, T(new w(null, null, 1, s), l, "easeOut", !0), T(new w(null, null, 2, s), l, "easeIn" + (0 === s ? ",easeNone" : "")), T(new w(null, null, 3, s), l, "easeInOut");
    M.linear = p.easing.Linear.easeIn, M.swing = p.easing.Quad.easeInOut;
    var S = _("events.EventDispatcher", function (t) {
        this._listeners = {}, this._eventTarget = t || this
    });
    l = S.prototype, l.addEventListener = function (t, e, i, n, r) {
        r = r || 0;
        var a, o, s = this._listeners[t], l = 0;
        for (this !== c || h || c.wake(), null == s && (this._listeners[t] = s = []), o = s.length; --o > -1;) a = s[o], a.c === e && a.s === i ? s.splice(o, 1) : 0 === l && a.pr < r && (l = o + 1);
        s.splice(l, 0, {c: e, s: i, up: n, pr: r})
    }, l.removeEventListener = function (t, e) {
        var i, n = this._listeners[t];
        if (n) for (i = n.length; --i > -1;) if (n[i].c === e) return void n.splice(i, 1)
    }, l.dispatchEvent = function (t) {
        var e, i, n, r = this._listeners[t];
        if (r) for (e = r.length, e > 1 && (r = r.slice(0)), i = this._eventTarget; --e > -1;) (n = r[e]) && (n.up ? n.c.call(n.s || i, {
            type: t,
            target: i
        }) : n.c.call(n.s || i))
    };
    var E = t.requestAnimationFrame, A = t.cancelAnimationFrame, P = Date.now || function () {
        return (new Date).getTime()
    }, L = P();
    for (o = ["ms", "moz", "webkit", "o"], s = o.length; --s > -1 && !E;) E = t[o[s] + "RequestAnimationFrame"], A = t[o[s] + "CancelAnimationFrame"] || t[o[s] + "CancelRequestAnimationFrame"];
    _("Ticker", function (t, e) {
        var i, r, a, o, s, l = this, u = P(), p = !(e === !1 || !E) && "auto", d = 500, f = 33, g = "tick",
            v = function (t) {
                var e, n, c = P() - L;
                c > d && (u += c - f), L += c, l.time = (L - u) / 1e3, e = l.time - s, (!i || e > 0 || t === !0) && (l.frame++, s += e + (e >= o ? .004 : o - e), n = !0), t !== !0 && (a = r(v)), n && l.dispatchEvent("tick")
            };
        S.call(l), l.time = l.frame = 0, l.tick = function () {
            v(!0)
        }, l.lagSmoothing = function (t, e) {
            return arguments.length ? (d = t || 1e8, void (f = Math.min(e, d, 0))) : 1e8 > d
        }, l.sleep = function () {
            null != a && (p && A ? A(a) : clearTimeout(a), r = m, a = null, l === c && (h = !1))
        }, l.wake = function (t) {
            null !== a ? l.sleep() : t ? u += -L + (L = P()) : l.frame > 10 && (L = P() - d + 5), r = 0 === i ? m : p && E ? E : function (t) {
                return setTimeout(t, 1e3 * (s - l.time) + 1 | 0)
            }, l === c && (h = !0), v(2)
        }, l.fps = function (t) {
            return arguments.length ? (i = t, o = 1 / (i || 60), s = this.time + o, void l.wake()) : i
        }, l.useRAF = function (t) {
            return arguments.length ? (l.sleep(), p = t, void l.fps(i)) : p
        }, l.fps(t), setTimeout(function () {
            "auto" === p && l.frame < 5 && "hidden" !== (n || {}).visibilityState && l.useRAF(!1)
        }, 1500)
    }), l = p.Ticker.prototype = new p.events.EventDispatcher, l.constructor = p.Ticker;
    var C = _("core.Animation", function (t, e) {
        if (this.vars = e = e || {}, this._duration = this._totalDuration = t || 0, this._delay = Number(e.delay) || 0, this._timeScale = 1, this._active = !!e.immediateRender, this.data = e.data, this._reversed = !!e.reversed, Q) {
            h || c.wake();
            var i = this.vars.useFrames ? Z : Q;
            i.add(this, i._time), this.vars.paused && this.paused(!0)
        }
    });
    c = C.ticker = new p.Ticker, l = C.prototype, l._dirty = l._gc = l._initted = l._paused = !1, l._totalTime = l._time = 0, l._rawPrevTime = -1, l._next = l._last = l._onUpdate = l._timeline = l.timeline = null, l._paused = !1;
    var R = function () {
        h && P() - L > 2e3 && ("hidden" !== (n || {}).visibilityState || !c.lagSmoothing()) && c.wake();
        var t = setTimeout(R, 2e3);
        t.unref && t.unref()
    };
    R(), l.play = function (t, e) {
        return null != t && this.seek(t, e), this.reversed(!1).paused(!1)
    }, l.pause = function (t, e) {
        return null != t && this.seek(t, e), this.paused(!0)
    }, l.resume = function (t, e) {
        return null != t && this.seek(t, e), this.paused(!1)
    }, l.seek = function (t, e) {
        return this.totalTime(Number(t), e !== !1)
    }, l.restart = function (t, e) {
        return this.reversed(!1).paused(!1).totalTime(t ? -this._delay : 0, e !== !1, !0)
    }, l.reverse = function (t, e) {
        return null != t && this.seek(t || this.totalDuration(), e), this.reversed(!0).paused(!1)
    }, l.render = function (t, e, i) {
    }, l.invalidate = function () {
        return this._time = this._totalTime = 0, this._initted = this._gc = !1, this._rawPrevTime = -1, (this._gc || !this.timeline) && this._enabled(!0), this
    }, l.isActive = function () {
        var t, e = this._timeline, i = this._startTime;
        return !e || !this._gc && !this._paused && e.isActive() && (t = e.rawTime(!0)) >= i && t < i + this.totalDuration() / this._timeScale - d
    }, l._enabled = function (t, e) {
        return h || c.wake(), this._gc = !t, this._active = this.isActive(), e !== !0 && (t && !this.timeline ? this._timeline.add(this, this._startTime - this._delay) : !t && this.timeline && this._timeline._remove(this, !0)), !1
    }, l._kill = function (t, e) {
        return this._enabled(!1, !1)
    }, l.kill = function (t, e) {
        return this._kill(t, e), this
    }, l._uncache = function (t) {
        for (var e = t ? this : this.timeline; e;) e._dirty = !0, e = e.timeline;
        return this
    }, l._swapSelfInParams = function (t) {
        for (var e = t.length, i = t.concat(); --e > -1;) "{self}" === t[e] && (i[e] = this);
        return i
    }, l._callback = function (t) {
        var e = this.vars, i = e[t], n = e[t + "Params"], r = e[t + "Scope"] || e.callbackScope || this;
        switch (n ? n.length : 0) {
            case 0:
                i.call(r);
                break;
            case 1:
                i.call(r, n[0]);
                break;
            case 2:
                i.call(r, n[0], n[1]);
                break;
            default:
                i.apply(r, n)
        }
    }, l.eventCallback = function (t, e, i, n) {
        if ("on" === (t || "").substr(0, 2)) {
            var r = this.vars;
            if (1 === arguments.length) return r[t];
            null == e ? delete r[t] : (r[t] = e, r[t + "Params"] = g(i) && -1 !== i.join("").indexOf("{self}") ? this._swapSelfInParams(i) : i, r[t + "Scope"] = n), "onUpdate" === t && (this._onUpdate = e)
        }
        return this
    }, l.delay = function (t) {
        return arguments.length ? (this._timeline.smoothChildTiming && this.startTime(this._startTime + t - this._delay), this._delay = t, this) : this._delay
    }, l.duration = function (t) {
        return arguments.length ? (this._duration = this._totalDuration = t, this._uncache(!0), this._timeline.smoothChildTiming && this._time > 0 && this._time < this._duration && 0 !== t && this.totalTime(this._totalTime * (t / this._duration), !0), this) : (this._dirty = !1, this._duration)
    }, l.totalDuration = function (t) {
        return this._dirty = !1, arguments.length ? this.duration(t) : this._totalDuration
    }, l.time = function (t, e) {
        return arguments.length ? (this._dirty && this.totalDuration(), this.totalTime(t > this._duration ? this._duration : t, e)) : this._time
    }, l.totalTime = function (t, e, i) {
        if (h || c.wake(), !arguments.length) return this._totalTime;
        if (this._timeline) {
            if (0 > t && !i && (t += this.totalDuration()), this._timeline.smoothChildTiming) {
                this._dirty && this.totalDuration();
                var n = this._totalDuration, r = this._timeline;
                if (t > n && !i && (t = n),
                    this._startTime = (this._paused ? this._pauseTime : r._time) - (this._reversed ? n - t : t) / this._timeScale, r._dirty || this._uncache(!1), r._timeline) for (; r._timeline;) r._timeline._time !== (r._startTime + r._totalTime) / r._timeScale && r.totalTime(r._totalTime, !0), r = r._timeline
            }
            this._gc && this._enabled(!0, !1), (this._totalTime !== t || 0 === this._duration) && (z.length && K(), this.render(t, e, !1), z.length && K())
        }
        return this
    }, l.progress = l.totalProgress = function (t, e) {
        var i = this.duration();
        return arguments.length ? this.totalTime(i * t, e) : i ? this._time / i : this.ratio
    }, l.startTime = function (t) {
        return arguments.length ? (t !== this._startTime && (this._startTime = t, this.timeline && this.timeline._sortChildren && this.timeline.add(this, t - this._delay)), this) : this._startTime
    }, l.endTime = function (t) {
        return this._startTime + (0 != t ? this.totalDuration() : this.duration()) / this._timeScale
    }, l.timeScale = function (t) {
        if (!arguments.length) return this._timeScale;
        var e, i;
        for (t = t || d, this._timeline && this._timeline.smoothChildTiming && (e = this._pauseTime, i = e || 0 === e ? e : this._timeline.totalTime(), this._startTime = i - (i - this._startTime) * this._timeScale / t), this._timeScale = t, i = this.timeline; i && i.timeline;) i._dirty = !0, i.totalDuration(), i = i.timeline;
        return this
    }, l.reversed = function (t) {
        return arguments.length ? (t != this._reversed && (this._reversed = t, this.totalTime(this._timeline && !this._timeline.smoothChildTiming ? this.totalDuration() - this._totalTime : this._totalTime, !0)), this) : this._reversed
    }, l.paused = function (t) {
        if (!arguments.length) return this._paused;
        var e, i, n = this._timeline;
        return t != this._paused && n && (h || t || c.wake(), e = n.rawTime(), i = e - this._pauseTime, !t && n.smoothChildTiming && (this._startTime += i, this._uncache(!1)), this._pauseTime = t ? e : null, this._paused = t, this._active = this.isActive(), !t && 0 !== i && this._initted && this.duration() && (e = n.smoothChildTiming ? this._totalTime : (e - this._startTime) / this._timeScale, this.render(e, e === this._totalTime, !0))), this._gc && !t && this._enabled(!0, !1), this
    };
    var O = _("core.SimpleTimeline", function (t) {
        C.call(this, 0, t), this.autoRemoveChildren = this.smoothChildTiming = !0
    });
    l = O.prototype = new C, l.constructor = O, l.kill()._gc = !1, l._first = l._last = l._recent = null, l._sortChildren = !1, l.add = l.insert = function (t, e, i, n) {
        var r, a;
        if (t._startTime = Number(e || 0) + t._delay, t._paused && this !== t._timeline && (t._pauseTime = this.rawTime() - (t._timeline.rawTime() - t._pauseTime)), t.timeline && t.timeline._remove(t, !0), t.timeline = t._timeline = this, t._gc && t._enabled(!0, !0), r = this._last, this._sortChildren) for (a = t._startTime; r && r._startTime > a;) r = r._prev;
        return r ? (t._next = r._next, r._next = t) : (t._next = this._first, this._first = t), t._next ? t._next._prev = t : this._last = t, t._prev = r, this._recent = t, this._timeline && this._uncache(!0), this
    }, l._remove = function (t, e) {
        return t.timeline === this && (e || t._enabled(!1, !0), t._prev ? t._prev._next = t._next : this._first === t && (this._first = t._next), t._next ? t._next._prev = t._prev : this._last === t && (this._last = t._prev), t._next = t._prev = t.timeline = null, t === this._recent && (this._recent = this._last), this._timeline && this._uncache(!0)), this
    }, l.render = function (t, e, i) {
        var n, r = this._first;
        for (this._totalTime = this._time = this._rawPrevTime = t; r;) n = r._next, (r._active || t >= r._startTime && !r._paused && !r._gc) && (r._reversed ? r.render((r._dirty ? r.totalDuration() : r._totalDuration) - (t - r._startTime) * r._timeScale, e, i) : r.render((t - r._startTime) * r._timeScale, e, i)), r = n
    }, l.rawTime = function () {
        return h || c.wake(), this._totalTime
    };
    var D = _("TweenLite", function (e, i, n) {
        // console.log(e);
        if (C.call(this, i, n), this.render = D.prototype.render, null == e) throw "Cannot tween a null target.";
        this.target = e = "string" != typeof e ? e : D.selector(e) || e;
        var r, a, o,
            s = e.jquery || e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType),
            l = this.vars.overwrite;
        if (this._overwrite = l = null == l ? J[D.defaultOverwrite] : "number" == typeof l ? l >> 0 : J[l], (s || e instanceof Array || e.push && g(e)) && "number" != typeof e[0]) for (this._targets = o = f(e), this._propLookup = [], this._siblings = [], r = 0; r < o.length; r++) a = o[r], a ? "string" != typeof a ? a.length && a !== t && a[0] && (a[0] === t || a[0].nodeType && a[0].style && !a.nodeType) ? (o.splice(r--, 1), this._targets = o = o.concat(f(a))) : (this._siblings[r] = tt(a, this, !1), 1 === l && this._siblings[r].length > 1 && it(a, this, null, 1, this._siblings[r])) : "string" == typeof (a = o[r--] = D.selector(a)) && o.splice(r + 1, 1) : o.splice(r--, 1); else this._propLookup = {}, this._siblings = tt(e, this, !1), 1 === l && this._siblings.length > 1 && it(e, this, null, 1, this._siblings);
        (this.vars.immediateRender || 0 === i && 0 === this._delay && this.vars.immediateRender !== !1) && (this._time = -d, this.render(Math.min(0, -this._delay)))
    }, !0), I = function (e) {
        return e && e.length && e !== t && e[0] && (e[0] === t || e[0].nodeType && e[0].style && !e.nodeType)
    }, N = function (t, e) {
        var i, n = {};
        for (i in t) Y[i] || i in e && "transform" !== i && "x" !== i && "y" !== i && "width" !== i && "height" !== i && "className" !== i && "border" !== i || !(!W[i] || W[i] && W[i]._autoCSS) || (n[i] = t[i], delete t[i]);
        t.css = n
    };
    l = D.prototype = new C, l.constructor = D, l.kill()._gc = !1, l.ratio = 0, l._firstPT = l._targets = l._overwrittenProps = l._startAt = null, l._notifyPluginsOfEnabled = l._lazy = !1, D.version = "2.1.2", D.defaultEase = l._ease = new w(null, null, 1, 1), D.defaultOverwrite = "auto", D.ticker = c, D.autoSleep = 120, D.lagSmoothing = function (t, e) {
        c.lagSmoothing(t, e)
    }, D.selector = t.$ || t.jQuery || function (e) {
        var i = t.$ || t.jQuery;
        return i ? (D.selector = i, i(e)) : (n || (n = t.document), n ? n.querySelectorAll ? n.querySelectorAll(e) : n.getElementById("#" === e.charAt(0) ? e.substr(1) : e) : e)
    };
    var z = [], k = {}, B = /(?:(-|-=|\+=)?\d*\.?\d*(?:e[\-+]?\d+)?)[0-9]/gi, F = /[\+-]=-?[\.\d]/, H = function (t) {
            for (var e, i = this._firstPT, n = 1e-6; i;) e = i.blob ? 1 === t && null != this.end ? this.end : t ? this.join("") : this.start : i.c * t + i.s, i.m ? e = i.m.call(this._tween, e, this._target || i.t, this._tween) : 1e-6 > e && e > -1e-6 && !i.blob && (e = 0), i.f ? i.fp ? i.t[i.p](i.fp, e) : i.t[i.p](e) : i.t[i.p] = e, i = i._next
        }, U = function (t) {
            return (1e3 * t | 0) / 1e3 + ""
        }, G = function (t, e, i, n) {
            var r, a, o, s, l, c, h, u = [], p = 0, d = "", f = 0;
            for (u.start = t, u.end = e, t = u[0] = t + "", e = u[1] = e + "", i && (i(u), t = u[0], e = u[1]), u.length = 0, r = t.match(B) || [], a = e.match(B) || [], n && (n._next = null, n.blob = 1, u._firstPT = u._applyPT = n), l = a.length, s = 0; l > s; s++) h = a[s], c = e.substr(p, e.indexOf(h, p) - p), d += c || !s ? c : ",", p += c.length, f ? f = (f + 1) % 5 : "rgba(" === c.substr(-5) && (f = 1), h === r[s] || r.length <= s ? d += h : (d && (u.push(d), d = ""), o = parseFloat(r[s]), u.push(o), u._firstPT = {
                _next: u._firstPT,
                t: u,
                p: u.length - 1,
                s: o,
                c: ("=" === h.charAt(1) ? parseInt(h.charAt(0) + "1", 10) * parseFloat(h.substr(2)) : parseFloat(h) - o) || 0,
                f: 0,
                m: f && 4 > f ? Math.round : U
            }), p += h.length;
            return d += e.substr(p), d && u.push(d), u.setRatio = H, F.test(e) && (u.end = null), u
        }, j = function (t, e, i, n, r, a, o, s, l) {
            "function" == typeof n && (n = n(l || 0, t));
            var c, h = typeof t[e],
                u = "function" !== h ? "" : e.indexOf("set") || "function" != typeof t["get" + e.substr(3)] ? e : "get" + e.substr(3),
                p = "get" !== i ? i : u ? o ? t[u](o) : t[u]() : t[e], d = "string" == typeof n && "=" === n.charAt(1),
                f = {
                    t: t,
                    p: e,
                    s: p,
                    f: "function" === h,
                    pg: 0,
                    n: r || e,
                    m: a ? "function" == typeof a ? a : Math.round : 0,
                    pr: 0,
                    c: d ? parseInt(n.charAt(0) + "1", 10) * parseFloat(n.substr(2)) : parseFloat(n) - p || 0
                };
            return ("number" != typeof p || "number" != typeof n && !d) && (o || isNaN(p) || !d && isNaN(n) || "boolean" == typeof p || "boolean" == typeof n ? (f.fp = o, c = G(p, d ? parseFloat(f.s) + f.c + (f.s + "").replace(/[0-9\-\.]/g, "") : n, s || D.defaultStringFilter, f), f = {
                t: c,
                p: "setRatio",
                s: 0,
                c: 1,
                f: 2,
                pg: 0,
                n: r || e,
                pr: 0,
                m: 0
            }) : (f.s = parseFloat(p), d || (f.c = parseFloat(n) - f.s || 0))), f.c ? ((f._next = this._firstPT) && (f._next._prev = f), this._firstPT = f, f) : void 0
        }, V = D._internals = {isArray: g, isSelector: I, lazyTweens: z, blobDif: G}, W = D._plugins = {},
        q = V.tweenLookup = {}, X = 0, Y = V.reservedProps = {
            ease: 1,
            delay: 1,
            overwrite: 1,
            onComplete: 1,
            onCompleteParams: 1,
            onCompleteScope: 1,
            useFrames: 1,
            runBackwards: 1,
            startAt: 1,
            onUpdate: 1,
            onUpdateParams: 1,
            onUpdateScope: 1,
            onStart: 1,
            onStartParams: 1,
            onStartScope: 1,
            onReverseComplete: 1,
            onReverseCompleteParams: 1,
            onReverseCompleteScope: 1,
            onRepeat: 1,
            onRepeatParams: 1,
            onRepeatScope: 1,
            easeParams: 1,
            yoyo: 1,
            immediateRender: 1,
            repeat: 1,
            repeatDelay: 1,
            data: 1,
            paused: 1,
            reversed: 1,
            autoCSS: 1,
            lazy: 1,
            onOverwrite: 1,
            callbackScope: 1,
            stringFilter: 1,
            id: 1,
            yoyoEase: 1,
            stagger: 1
        }, J = {none: 0, all: 1, auto: 2, concurrent: 3, allOnStart: 4, preexisting: 5, true: 1, false: 0},
        Z = C._rootFramesTimeline = new O, Q = C._rootTimeline = new O, $ = 30, K = V.lazyRender = function () {
            var t, e, i = z.length;
            for (k = {}, t = 0; i > t; t++) (e = z[t]) && e._lazy !== !1 && (e.render(e._lazy[0], e._lazy[1], !0), e._lazy = !1);
            z.length = 0
        };
    Q._startTime = c.time, Z._startTime = c.frame, Q._active = Z._active = !0, setTimeout(K, 1), C._updateRoot = D.render = function () {
        var t, e, i;
        if (z.length && K(), Q.render((c.time - Q._startTime) * Q._timeScale, !1, !1), Z.render((c.frame - Z._startTime) * Z._timeScale, !1, !1), z.length && K(), c.frame >= $) {
            $ = c.frame + (parseInt(D.autoSleep, 10) || 120);
            for (i in q) {
                for (e = q[i].tweens, t = e.length; --t > -1;) e[t]._gc && e.splice(t, 1);
                0 === e.length && delete q[i]
            }
            if ((!(i = Q._first) || i._paused) && D.autoSleep && !Z._first && 1 === c._listeners.tick.length) {
                for (; i && i._paused;) i = i._next;
                i || c.sleep()
            }
        }
    }, c.addEventListener("tick", C._updateRoot);
    var tt = function (t, e, i) {
        var n, r, a = t._gsTweenID;
        if (q[a || (t._gsTweenID = a = "t" + X++)] || (q[a] = {
            target: t,
            tweens: []
        }), e && (n = q[a].tweens, n[r = n.length] = e, i)) for (; --r > -1;) n[r] === e && n.splice(r, 1);
        return q[a].tweens
    }, et = function (t, e, i, n) {
        var r, a, o = t.vars.onOverwrite;
        return o && (r = o(t, e, i, n)), o = D.onOverwrite, o && (a = o(t, e, i, n)), r !== !1 && a !== !1
    }, it = function (t, e, i, n, r) {
        var a, o, s, l;
        if (1 === n || n >= 4) {
            for (l = r.length, a = 0; l > a; a++) if ((s = r[a]) !== e) s._gc || s._kill(null, t, e) && (o = !0); else if (5 === n) break;
            return o
        }
        var c, h = e._startTime + d, u = [], p = 0, f = 0 === e._duration;
        for (a = r.length; --a > -1;) (s = r[a]) === e || s._gc || s._paused || (s._timeline !== e._timeline ? (c = c || nt(e, 0, f), 0 === nt(s, c, f) && (u[p++] = s)) : s._startTime <= h && s._startTime + s.totalDuration() / s._timeScale > h && ((f || !s._initted) && h - s._startTime <= 2 * d || (u[p++] = s)));
        for (a = p; --a > -1;) if (s = u[a], l = s._firstPT, 2 === n && s._kill(i, t, e) && (o = !0), 2 !== n || !s._firstPT && s._initted && l) {
            if (2 !== n && !et(s, e)) continue;
            s._enabled(!1, !1) && (o = !0)
        }
        return o
    }, nt = function (t, e, i) {
        for (var n = t._timeline, r = n._timeScale, a = t._startTime; n._timeline;) {
            if (a += n._startTime, r *= n._timeScale, n._paused) return -100;
            n = n._timeline
        }
        return a /= r, a > e ? a - e : i && a === e || !t._initted && 2 * d > a - e ? d : (a += t.totalDuration() / t._timeScale / r) > e + d ? 0 : a - e - d
    };
    l._init = function () {
        var t, e, i, n, r, a, o = this.vars, s = this._overwrittenProps, l = this._duration, c = !!o.immediateRender,
            h = o.ease, u = this._startAt;
        if (o.startAt) {
            u && (u.render(-1, !0), u.kill()), r = {};
            for (n in o.startAt) r[n] = o.startAt[n];
            if (r.data = "isStart", r.overwrite = !1, r.immediateRender = !0, r.lazy = c && o.lazy !== !1, r.startAt = r.delay = null, r.onUpdate = o.onUpdate, r.onUpdateParams = o.onUpdateParams, r.onUpdateScope = o.onUpdateScope || o.callbackScope || this, this._startAt = D.to(this.target || {}, 0, r), c) if (this._time > 0) this._startAt = null; else if (0 !== l) return
        } else if (o.runBackwards && 0 !== l) if (u) u.render(-1, !0), u.kill(), this._startAt = null; else {
            0 !== this._time && (c = !1), i = {};
            for (n in o) Y[n] && "autoCSS" !== n || (i[n] = o[n]);
            if (i.overwrite = 0, i.data = "isFromStart", i.lazy = c && o.lazy !== !1, i.immediateRender = c, this._startAt = D.to(this.target, 0, i), c) {
                if (0 === this._time) return
            } else this._startAt._init(), this._startAt._enabled(!1), this.vars.immediateRender && (this._startAt = null)
        }
        if (this._ease = h = h ? h instanceof w ? h : "function" == typeof h ? new w(h, o.easeParams) : M[h] || D.defaultEase : D.defaultEase, o.easeParams instanceof Array && h.config && (this._ease = h.config.apply(h, o.easeParams)), this._easeType = this._ease._type, this._easePower = this._ease._power, this._firstPT = null, this._targets) for (a = this._targets.length, t = 0; a > t; t++) this._initProps(this._targets[t], this._propLookup[t] = {}, this._siblings[t], s ? s[t] : null, t) && (e = !0); else e = this._initProps(this.target, this._propLookup, this._siblings, s, 0);
        if (e && D._onPluginEvent("_onInitAllProps", this), s && (this._firstPT || "function" != typeof this.target && this._enabled(!1, !1)), o.runBackwards) for (i = this._firstPT; i;) i.s += i.c, i.c = -i.c, i = i._next;
        this._onUpdate = o.onUpdate, this._initted = !0
    }, l._initProps = function (e, i, n, r, a) {
        var o, s, l, c, h, u;
        if (null == e) return !1;
        k[e._gsTweenID] && K(), this.vars.css || e.style && e !== t && e.nodeType && W.css && this.vars.autoCSS !== !1 && N(this.vars, e);
        for (o in this.vars) if (u = this.vars[o], Y[o]) u && (u instanceof Array || u.push && g(u)) && -1 !== u.join("").indexOf("{self}") && (this.vars[o] = u = this._swapSelfInParams(u, this)); else if (W[o] && (c = new W[o])._onInitTween(e, this.vars[o], this, a)) {
            for (this._firstPT = h = {
                _next: this._firstPT,
                t: c,
                p: "setRatio",
                s: 0,
                c: 1,
                f: 1,
                n: o,
                pg: 1,
                pr: c._priority,
                m: 0
            }, s = c._overwriteProps.length; --s > -1;) i[c._overwriteProps[s]] = this._firstPT;
            (c._priority || c._onInitAllProps) && (l = !0), (c._onDisable || c._onEnable) && (this._notifyPluginsOfEnabled = !0), h._next && (h._next._prev = h)
        } else i[o] = j.call(this, e, o, "get", u, o, 0, null, this.vars.stringFilter, a);
        return r && this._kill(r, e) ? this._initProps(e, i, n, r, a) : this._overwrite > 1 && this._firstPT && n.length > 1 && it(e, this, i, this._overwrite, n) ? (this._kill(i, e), this._initProps(e, i, n, r, a)) : (this._firstPT && (this.vars.lazy !== !1 && this._duration || this.vars.lazy && !this._duration) && (k[e._gsTweenID] = !0), l)
    }, l.render = function (t, e, i) {
        var n, r, a, o, s = this, l = s._time, c = s._duration, h = s._rawPrevTime;
        if (t >= c - d && t >= 0) s._totalTime = s._time = c, s.ratio = s._ease._calcEnd ? s._ease.getRatio(1) : 1, s._reversed || (n = !0, r = "onComplete", i = i || s._timeline.autoRemoveChildren), 0 === c && (s._initted || !s.vars.lazy || i) && (s._startTime === s._timeline._duration && (t = 0), (0 > h || 0 >= t && t >= -d || h === d && "isPause" !== s.data) && h !== t && (i = !0, h > d && (r = "onReverseComplete")), s._rawPrevTime = o = !e || t || h === t ? t : d); else if (d > t) s._totalTime = s._time = 0, s.ratio = s._ease._calcEnd ? s._ease.getRatio(0) : 0, (0 !== l || 0 === c && h > 0) && (r = "onReverseComplete", n = s._reversed), t > -d ? t = 0 : 0 > t && (s._active = !1, 0 === c && (s._initted || !s.vars.lazy || i) && (h >= 0 && (h !== d || "isPause" !== s.data) && (i = !0), s._rawPrevTime = o = !e || t || h === t ? t : d)), (!s._initted || s._startAt && s._startAt.progress()) && (i = !0); else if (s._totalTime = s._time = t, s._easeType) {
            var u = t / c, p = s._easeType, f = s._easePower;
            (1 === p || 3 === p && u >= .5) && (u = 1 - u), 3 === p && (u *= 2), 1 === f ? u *= u : 2 === f ? u *= u * u : 3 === f ? u *= u * u * u : 4 === f && (u *= u * u * u * u), s.ratio = 1 === p ? 1 - u : 2 === p ? u : .5 > t / c ? u / 2 : 1 - u / 2
        } else s.ratio = s._ease.getRatio(t / c);
        if (s._time !== l || i) {
            if (!s._initted) {
                if (s._init(), !s._initted || s._gc) return;
                if (!i && s._firstPT && (s.vars.lazy !== !1 && s._duration || s.vars.lazy && !s._duration)) return s._time = s._totalTime = l, s._rawPrevTime = h, z.push(s), void (s._lazy = [t, e]);
                s._time && !n ? s.ratio = s._ease.getRatio(s._time / c) : n && s._ease._calcEnd && (s.ratio = s._ease.getRatio(0 === s._time ? 0 : 1))
            }
            for (s._lazy !== !1 && (s._lazy = !1), s._active || !s._paused && s._time !== l && t >= 0 && (s._active = !0), 0 === l && (s._startAt && (t >= 0 ? s._startAt.render(t, !0, i) : r || (r = "_dummyGS")), s.vars.onStart && (0 !== s._time || 0 === c) && (e || s._callback("onStart"))), a = s._firstPT; a;) a.f ? a.t[a.p](a.c * s.ratio + a.s) : a.t[a.p] = a.c * s.ratio + a.s, a = a._next;
            s._onUpdate && (0 > t && s._startAt && t !== -1e-4 && s._startAt.render(t, !0, i), e || (s._time !== l || n || i) && s._callback("onUpdate")), r && (!s._gc || i) && (0 > t && s._startAt && !s._onUpdate && t !== -1e-4 && s._startAt.render(t, !0, i), n && (s._timeline.autoRemoveChildren && s._enabled(!1, !1), s._active = !1), !e && s.vars[r] && s._callback(r), 0 === c && s._rawPrevTime === d && o !== d && (s._rawPrevTime = 0))
        }
    }, l._kill = function (t, e, i) {
        if ("all" === t && (t = null), null == t && (null == e || e === this.target)) return this._lazy = !1, this._enabled(!1, !1);
        e = "string" != typeof e ? e || this._targets || this.target : D.selector(e) || e;
        var n, r, a, o, s, l, c, h, u,
            p = i && this._time && i._startTime === this._startTime && this._timeline === i._timeline,
            d = this._firstPT;
        if ((g(e) || I(e)) && "number" != typeof e[0]) for (n = e.length; --n > -1;) this._kill(t, e[n], i) && (l = !0); else {
            if (this._targets) {
                for (n = this._targets.length; --n > -1;) if (e === this._targets[n]) {
                    s = this._propLookup[n] || {}, this._overwrittenProps = this._overwrittenProps || [], r = this._overwrittenProps[n] = t ? this._overwrittenProps[n] || {} : "all";
                    break
                }
            } else {
                if (e !== this.target) return !1;
                s = this._propLookup, r = this._overwrittenProps = t ? this._overwrittenProps || {} : "all"
            }
            if (s) {
                if (c = t || s, h = t !== r && "all" !== r && t !== s && ("object" != typeof t || !t._tempKill), i && (D.onOverwrite || this.vars.onOverwrite)) {
                    for (a in c) s[a] && (u || (u = []), u.push(a));
                    if ((u || !t) && !et(this, i, e, u)) return !1
                }
                for (a in c) (o = s[a]) && (p && (o.f ? o.t[o.p](o.s) : o.t[o.p] = o.s, l = !0), o.pg && o.t._kill(c) && (l = !0), o.pg && 0 !== o.t._overwriteProps.length || (o._prev ? o._prev._next = o._next : o === this._firstPT && (this._firstPT = o._next), o._next && (o._next._prev = o._prev), o._next = o._prev = null), delete s[a]), h && (r[a] = 1);
                !this._firstPT && this._initted && d && this._enabled(!1, !1)
            }
        }
        return l
    }, l.invalidate = function () {
        this._notifyPluginsOfEnabled && D._onPluginEvent("_onDisable", this);
        var t = this._time;
        return this._firstPT = this._overwrittenProps = this._startAt = this._onUpdate = null, this._notifyPluginsOfEnabled = this._active = this._lazy = !1, this._propLookup = this._targets ? {} : [], C.prototype.invalidate.call(this), this.vars.immediateRender && (this._time = -d, this.render(t, !1, this.vars.lazy !== !1)), this
    }, l._enabled = function (t, e) {
        if (h || c.wake(), t && this._gc) {
            var i, n = this._targets;
            if (n) for (i = n.length; --i > -1;) this._siblings[i] = tt(n[i], this, !0); else this._siblings = tt(this.target, this, !0)
        }
        return C.prototype._enabled.call(this, t, e), !(!this._notifyPluginsOfEnabled || !this._firstPT) && D._onPluginEvent(t ? "_onEnable" : "_onDisable", this)
    }, D.to = function (t, e, i) {
        return new D(t, e, i)
    }, D.from = function (t, e, i) {
        return i.runBackwards = !0, i.immediateRender = 0 != i.immediateRender, new D(t, e, i)
    }, D.fromTo = function (t, e, i, n) {
        return n.startAt = i, n.immediateRender = 0 != n.immediateRender && 0 != i.immediateRender, new D(t, e, n)
    }, D.delayedCall = function (t, e, i, n, r) {
        return new D(e, 0, {
            delay: t,
            onComplete: e,
            onCompleteParams: i,
            callbackScope: n,
            onReverseComplete: e,
            onReverseCompleteParams: i,
            immediateRender: !1,
            lazy: !1,
            useFrames: r,
            overwrite: 0
        })
    }, D.set = function (t, e) {
        return new D(t, 0, e)
    }, D.getTweensOf = function (t, e) {
        if (null == t) return [];
        t = "string" != typeof t ? t : D.selector(t) || t;
        var i, n, r, a;
        if ((g(t) || I(t)) && "number" != typeof t[0]) {
            for (i = t.length, n = []; --i > -1;) n = n.concat(D.getTweensOf(t[i], e));
            for (i = n.length; --i > -1;) for (a = n[i], r = i; --r > -1;) a === n[r] && n.splice(i, 1)
        } else if (t._gsTweenID) for (n = tt(t).concat(), i = n.length; --i > -1;) (n[i]._gc || e && !n[i].isActive()) && n.splice(i, 1);
        return n || []
    }, D.killTweensOf = D.killDelayedCallsTo = function (t, e, i) {
        "object" == typeof e && (i = e, e = !1);
        for (var n = D.getTweensOf(t, e), r = n.length; --r > -1;) n[r]._kill(i, t)
    };
    var rt = _("plugins.TweenPlugin", function (t, e) {
        this._overwriteProps = (t || "").split(","), this._propName = this._overwriteProps[0], this._priority = e || 0, this._super = rt.prototype
    }, !0);
    if (l = rt.prototype, rt.version = "1.19.0", rt.API = 2, l._firstPT = null, l._addTween = j, l.setRatio = H, l._kill = function (t) {
        var e, i = this._overwriteProps, n = this._firstPT;
        if (null != t[this._propName]) this._overwriteProps = []; else for (e = i.length; --e > -1;) null != t[i[e]] && i.splice(e, 1);
        for (; n;) null != t[n.n] && (n._next && (n._next._prev = n._prev), n._prev ? (n._prev._next = n._next, n._prev = null) : this._firstPT === n && (this._firstPT = n._next)), n = n._next;
        return !1
    }, l._mod = l._roundProps = function (t) {
        for (var e, i = this._firstPT; i;) e = t[this._propName] || null != i.n && t[i.n.split(this._propName + "_").join("")], e && "function" == typeof e && (2 === i.f ? i.t._applyPT.m = e : i.m = e), i = i._next
    }, D._onPluginEvent = function (t, e) {
        var i, n, r, a, o, s = e._firstPT;
        if ("_onInitAllProps" === t) {
            for (; s;) {
                for (o = s._next, n = r; n && n.pr > s.pr;) n = n._next;
                (s._prev = n ? n._prev : a) ? s._prev._next = s : r = s, (s._next = n) ? n._prev = s : a = s, s = o
            }
            s = e._firstPT = r
        }
        for (; s;) s.pg && "function" == typeof s.t[t] && s.t[t]() && (i = !0), s = s._next;
        return i
    }, rt.activate = function (t) {
        for (var e = t.length; --e > -1;) t[e].API === rt.API && (W[(new t[e])._propName] = t[e]);
        return !0
    }, x.plugin = function (t) {
        if (!(t && t.propName && t.init && t.API)) throw"illegal plugin definition.";
        var e, i = t.propName, n = t.priority || 0, r = t.overwriteProps, a = {
            init: "_onInitTween",
            set: "setRatio",
            kill: "_kill",
            round: "_mod",
            mod: "_mod",
            initAll: "_onInitAllProps"
        }, o = _("plugins." + i.charAt(0).toUpperCase() + i.substr(1) + "Plugin", function () {
            rt.call(this, i, n), this._overwriteProps = r || []
        }, t.global === !0), s = o.prototype = new rt(i);
        s.constructor = o, o.API = t.API;
        for (e in a) "function" == typeof t[e] && (s[a[e]] = t[e]);
        return o.version = t.version, rt.activate([o]), o
    }, o = t._gsQueue) {
        for (s = 0; s < o.length; s++) o[s]();
        for (l in v) v[l].func || t.console.log("GSAP encountered missing dependency: " + l)
    }
    h = !1
}("undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window, "TweenMax");
var ImprovedNoise = function () {
    function t(t) {
        return t * t * t * (t * (6 * t - 15) + 10)
    }

    function e(t, e, i) {
        return e + t * (i - e)
    }

    function i(t, e, i, n) {
        var r = 15 & t, a = r < 8 ? e : i, o = r < 4 ? i : 12 == r || 14 == r ? e : n;
        return (0 == (1 & r) ? a : -a) + (0 == (2 & r) ? o : -o)
    }

    for (var n = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], r = 0; r < 256; r++) n[256 + r] = n[r];
    return {
        noise: function (r, a, o) {
            var s = Math.floor(r), l = Math.floor(a), c = Math.floor(o), h = 255 & s, u = 255 & l, p = 255 & c;
            r -= s, a -= l, o -= c;
            var d = r - 1, f = a - 1, m = o - 1, g = t(r), v = t(a), y = t(o), x = n[h] + u, _ = n[x] + p,
                b = n[x + 1] + p, w = n[h + 1] + u, M = n[w] + p, T = n[w + 1] + p;
            return e(y, e(v, e(g, i(n[_], r, a, o), i(n[M], d, a, o)), e(g, i(n[b], r, f, o), i(n[T], d, f, o))), e(v, e(g, i(n[_ + 1], r, a, m), i(n[M + 1], d, a, o - 1)), e(g, i(n[b + 1], r, f, m), i(n[T + 1], d, f, m))))
        }
    }
}, currentRandom = Math.random;
Marsaglia.createRandomized = function () {
    var t = new Date;
    return new Marsaglia(t / 6e4 & 4294967295, 4294967295 & t)
};
var noiseProfile = {generator: void 0, octaves: 4, fallout: .5, seed: void 0}, Render = Render || {};
Render.SVGLineJSON = function (t, e, i, n, r, a, o, s) {
    this.svgPath = t, this.parent = a, this.repeat = n, this.currRepeat = .49, this.speed = r, this.color = e, this.opacity = i, this.container = new THREE.Object3D, this.animate = o, this.export = s, this.elements = [], this.init()
}, Render.SVGLineJSON.prototype = {
    init: function () {
        var t = this, e = (new THREE.TextureLoader).load("dash.png");
        e.wrapS = THREE.RepeatWrapping, e.wrapT = THREE.RepeatWrapping, this.tex = e, this.material = new MeshLineMaterial({
            map: e,
            useMap: !0,
            color: this.color,
            opacity: this.opacity,
            resolution: t.parent.resolution,
            sizeAttenuation: !0,
            lineWidth: 5,
            near: t.parent.camera.near,
            far: t.parent.camera.far,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0,
            repeat: new THREE.Vector2(this.currRepeat, 1)
        }), this.material.uniforms.offset.value.x = -.23, $.getJSON(this.svgPath, function (e) {
            var i = new THREE.Geometry;
            e.forEach(function (t) {
                i.vertices.push(new THREE.Vector3(t.x, t.y, 0))
            }), t.makeLine(i)
        }), this.animate ? TweenMax.to(this.material.uniforms.offset.value, 2, {
            x: .26,
            ease: Quint.easeInOut,
            onComplete: function () {
                TweenMax.to(t.material.uniforms.repeat.value, 2, {
                    x: t.repeat,
                    ease: Quint.easeIn
                }), TweenMax.to(t.material.uniforms.offset.value, 2, {
                    x: 1 / t.repeat,
                    ease: Quint.easeIn,
                    onComplete: function () {
                        t.animatedIn = !0
                    }
                })
            }
        }) : (t.animatedIn = !0, this.material.uniforms.offset.value.x = 1 / t.repeat, this.material.uniforms.repeat.value.x = t.repeat, this.material.uniforms.opacity.value = 0, TweenMax.to(this.material.uniforms.opacity, 2.5, {
            value: 1,
            delay: 2 + 1 * Math.random()
        })), this.count = 0, TweenMax.delayedCall(3, function () {
            t.export && console.log(JSON.stringify(t.elements))
        })
    }, makeLine: function (t) {
        var e = new MeshLine;
        e.setGeometry(t);
        var i = new THREE.Mesh(e.geometry, this.material);
        return i.position.x = -224, i.position.y = 224, i.rotation.x = Math.PI, this.container.add(i), i
    }, update: function () {
        this.animatedIn && (this.material.uniforms.offset.value.x += .7 * this.speed)
    }
};
var Render = Render || {};
Render.SVGArrowJSON = function (t, e, i, n, r) {
    this.parent = r, this.repeat = i, this.speed = n, this.color = t, this.opacity = e, this.container = new THREE.Object3D, this.mesh = new THREE.Object3D, this.shouldAnimate = !0, this.init()
}, Render.SVGArrowJSON.prototype = {
    init: function () {
        var t = this;
        this.material = new MeshLineMaterial({
            useMap: !1,
            color: this.color,
            opacity: this.opacity,
            resolution: t.parent.resolution,
            sizeAttenuation: !0,
            lineWidth: 2,
            near: t.parent.camera.near,
            far: t.parent.camera.far,
            depthWrite: !1,
            depthTest: !1,
            transparent: !0,
            repeat: new THREE.Vector2(this.repeat, 1)
        }), this.mesh.position.x = -2e3, this.container.add(this.mesh), this.container.rotation.z = Math.PI / 4, this.container.scale.set(2, 2, 2), $.getJSON("arrow.json", function (e) {
            var i = new THREE.Geometry;
            e.forEach(function (t) {
                i.vertices.push(new THREE.Vector3(t.x, t.y, 0))
            }), t.makeLine(i)
        }), TweenMax.delayedCall(this.speed + 4, this.animate.bind(this)), this.count = 0
    }, animate: function () {
        var t = this;
        this.shouldAnimate && TweenMax.fromTo(this.mesh.position, 2.8, {x: -2e3}, {
            x: 0,
            delay: 3 * Math.random(),
            ease: Quint.easeOut,
            onComplete: function () {
                TweenMax.to(t.mesh.position, 1.4, {
                    x: 2e3, ease: Quint.easeIn, onComplete: function () {
                        for (var e = 550 * (Math.random() - .5); Math.abs(e) < 200;) e = 550 * (Math.random() - .5);
                        t.container.position.z = 500 * (Math.random() - .5), t.container.position.x = e, t.container.position.y = -e, t.animate()
                    }
                })
            }
        })
    }, makeLine: function (t) {
        var e = new MeshLine;
        e.setGeometry(t);
        var i = new THREE.Mesh(e.geometry, this.material);
        return i.position.x = -448, i.position.y = 224, i.rotation.x = Math.PI, this.mesh.add(i), i
    }
};
var Render = Render || {};
Render.HorizontalLine = function (t, e, i, n, r) {
    this.parent = r, this.repeat = i, this.speed = n, this.color = t, this.opacity = e, this.container = new THREE.Object3D, this.dir = 1, Math.random() > .5 && (this.dir = -1), this.init()
}, Render.HorizontalLine.prototype = {
    init: function () {
        var t = this, e = (new THREE.TextureLoader).load("dash.png");
        e.wrapS = THREE.RepeatWrapping, e.wrapT = THREE.RepeatWrapping, e.repeat.set(this.repeat, 1), this.tex = e, this.material = new THREE.MeshBasicMaterial({
            map: e,
            color: this.color,
            transparent: !0,
            opacity: 0
        }), this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(100, 5, 1, 1), this.material), this.container.add(this.mesh), TweenMax.to(this.material, 1, {
            opacity: this.opacity,
            delay: 4 + 2 * Math.random()
        })
    }, update: function () {
        this.tex.offset.x += this.speed * this.dir * .7
    }
};
var Render = Render || {};
Render.Square = function (t, e, i, n, r) {
    this.parent = r, this.repeat = i, this.speed = n, this.color = t, this.opacity = e, this.container = new THREE.Object3D, this.dir = 1, Math.random() > .5 && (this.dir = -1), this.init()
}, Render.Square.prototype = {
    init: function () {
        var t = this, e = (new THREE.TextureLoader).load("dash.png");
        e.wrapS = THREE.RepeatWrapping, e.wrapT = THREE.RepeatWrapping, e.repeat.set(this.repeat, 1), this.tex = e, this.material = new THREE.MeshBasicMaterial({
            map: e,
            color: this.color,
            transparent: !0,
            opacity: 0
        }), this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(25, 25, 1, 1), this.material), this.container.add(this.mesh), TweenMax.to(this.material, 1, {
            opacity: this.opacity,
            delay: 4 + 2 * Math.random()
        })
    }, update: function () {
        this.tex.offset.x += this.speed * this.dir
    }
};
var Render = Render || {};
Render.AngledLine = function (t, e, i, n, r, a) {
    this.parent = r, this.offset = 0, a && (this.offset = a), this.speed = n, this.color = t, this.opacity = e, this.container = new THREE.Object3D, this.dir = 1, Math.random() > .5 && (this.dir = -1), this.shouldAnimate = !0, this.init()
}, Render.AngledLine.prototype = {
    init: function () {
        var t = this;
        this.material = new THREE.MeshBasicMaterial({
            color: this.color,
            transparent: !0,
            opacity: this.opacity
        }), this.mesh = new THREE.Mesh(new THREE.PlaneBufferGeometry(3e3, 1, 1, 1), this.material), this.mesh.position.x = -3e3, this.container.rotation.z = Math.PI / 4, this.container.add(this.mesh), TweenMax.delayedCall(this.speed + 4, this.animate.bind(this))
    }, animate: function () {
        var t = this;
        this.shouldAnimate && TweenMax.fromTo(this.mesh.position, 2.8, {x: -3e3}, {
            x: 0,
            delay: 3 * Math.random(),
            ease: Quint.easeOut,
            onComplete: function () {
                TweenMax.to(t.mesh.position, 2.8, {
                    x: 3e3, ease: Quint.easeOut, onComplete: function () {
                        for (var e = 600 * (Math.random() - .5); Math.abs(e) < 200;) e = 600 * (Math.random() - .5);
                        t.container.position.z = 1e3 * (Math.random() - .5), t.container.position.x = e, t.container.position.y = -e + t.offset, t.animate()
                    }
                })
            }
        })
    }, update: function () {
        this.tex.offset.x += this.speed * this.dir
    }
};
var Render = Render || {};
Render.Hero = function () {
    this.el = document.querySelector("#hero"), this.scrollEl = document.querySelector("#hero .scroll"), this.isActive = !0, this.init()
}, Render.Hero.prototype = {
    init: function () {
        var t = this;
        this.scene = new THREE.Scene, this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, .1, 1e4), this.camera.position.z = 1e3, this.camera.lookAt(new THREE.Vector3), this.renderer = new THREE.WebGLRenderer({antialias: !0}), this.renderer.setSize(window.innerWidth, window.innerHeight), this.renderer.setClearColor(1315860, 1), this.renderer.setPixelRatio(window.devicePixelRatio), this.el.appendChild(this.renderer.domElement), this.renderer.autoClearColor = !0, this.resolution = new THREE.Vector2(window.innerWidth, window.innerHeight), this.logoOutlineGrey = new Render.SVGLineJSON("logo_outline.json", new THREE.Color(16316664), .2, 2, .005, this, !0), this.scene.add(this.logoOutlineGrey.container), this.logoOutlineWhite = new Render.SVGLineJSON("logo_outline.json", new THREE.Color(16316664), 1, 7, .01, this), this.scene.add(this.logoOutlineWhite.container), this.logoOutlineWhite.container.position.z = 20, this.logoInnerGrey = new Render.SVGLineJSON("logo_inner.json", new THREE.Color(16316664), .2, 1, .005, this, !0), this.scene.add(this.logoInnerGrey.container), this.logoInnerOrange = new Render.SVGLineJSON("logo_inner.json", new THREE.Color(16736563), 1, 2, .01, this), this.scene.add(this.logoInnerOrange.container), this.logoInnerOrange.container.position.z = 20, this.logoSquare = new Render.SVGLineJSON("logo_square.json", new THREE.Color(16736563), 1, .3, .01, this), this.scene.add(this.logoSquare.container), this.logoSquare.container.position.z = 25, this.hLines = [];
        for (var e = 0; e < 7; e++) {
            var i = new Render.HorizontalLine(new THREE.Color(16316664), 1, .1 * Math.random() + .2, .005 * Math.random() + .005, this);
            for (i.container.position.x = 700 * (Math.random() - .5); Math.abs(i.container.position.x) < 200;) i.container.position.x = 700 * (Math.random() - .5);
            for (i.container.position.y = 600 * (Math.random() - .5); Math.abs(i.container.position.y) < 200;) i.container.position.y = 600 * (Math.random() - .5);
            i.container.position.z = 1e3 * (Math.random() - .5), i.container.scale.x = 2 * (Math.random() - .5) + 1, i.container.scale.y = Math.random() - .5 + 1, t.scene.add(i.container), t.hLines.push(i)
        }
        for (var e = 0; e < 3; e++) {
            var i = new Render.HorizontalLine(new THREE.Color(16736563), 1, .1 * Math.random() + .2, .005 * Math.random() + .005, this);
            for (i.container.position.x = 700 * (Math.random() - .5); Math.abs(i.container.position.x) < 200;) i.container.position.x = 700 * (Math.random() - .5);
            for (i.container.position.y = 600 * (Math.random() - .5); Math.abs(i.container.position.y) < 200;) i.container.position.y = 600 * (Math.random() - .5);
            i.container.position.z = 1e3 * (Math.random() - .5), i.container.scale.x = Math.random() - .5 + 1, i.container.scale.y = Math.random() - .5 + 1, t.scene.add(i.container), t.hLines.push(i)
        }
        for (var e = 0; e < 3; e++) {
            var i = new Render.Square(new THREE.Color(16736563), 1, .1 * Math.random() + .2, .01 * Math.random() + .01, this);
            for (i.container.position.x = 700 * (Math.random() - .5); Math.abs(i.container.position.x) < 200;) i.container.position.x = 700 * (Math.random() - .5);
            for (i.container.position.y = 600 * (Math.random() - .5); Math.abs(i.container.position.y) < 200;) i.container.position.y = 600 * (Math.random() - .5);
            var n = Math.random() - .5 + 1;
            i.container.scale.x = n, i.container.scale.y = n, i.container.position.z = 1e3 * (Math.random() - .5), t.scene.add(i.container), t.hLines.push(i)
        }
        this.heroArrows = [], this.fadeOnOut = [];
        for (var e = 0; e < 3; e++) {
            var i = new Render.HorizontalLine(new THREE.Color(16777215), .2, .1 * Math.random() + .2, .005 * Math.random() + .005, this);
            for (i.container.position.x = 1500 * (Math.random() - .5); Math.abs(i.container.position.x) < 200;) i.container.position.x = 1500 * (Math.random() - .5);
            for (i.container.position.y = 1200 * (Math.random() - .5); Math.abs(i.container.position.y) < 200;) i.container.position.y = 1200 * (Math.random() - .5);
            i.container.position.z = 1e3 * -Math.random(), i.container.position.y -= 1e3, i.container.scale.x = Math.random() - .5 + 1, i.container.scale.y = Math.random() - .5 + 1, t.scene.add(i.container), t.hLines.push(i)
        }
        for (var e = 0; e < 3; e++) {
            var i = new Render.HorizontalLine(new THREE.Color(16777215), .2, .1 * Math.random() + .2, .005 * Math.random() + .005, this);
            for (i.container.position.x = 1500 * (Math.random() - .5); Math.abs(i.container.position.x) < 200;) i.container.position.x = 1500 * (Math.random() - .5);
            for (i.container.position.y = 1200 * (Math.random() - .5); Math.abs(i.container.position.y) < 200;) i.container.position.y = 1200 * (Math.random() - .5);
            i.container.position.z = 1e3 * -Math.random(), i.container.position.y -= 2e3, i.container.scale.x = Math.random() - .5 + 1, i.container.scale.y = Math.random() - .5 + 1, t.scene.add(i.container), t.hLines.push(i)
        }
        for (var e = 0; e < 2; e++) {
            for (var i = new Render.AngledLine(new THREE.Color(16316664), 1, .1 * Math.random() + .2, 5 * Math.random(), this), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r, i.container.position.z = 1e3 * (Math.random() - .5), t.heroArrows.push(i), t.fadeOnOut.push(i), t.scene.add(i.container)
        }
        for (var e = 0; e < 1; e++) {
            for (var i = new Render.AngledLine(new THREE.Color(16316664), .2, .1 * Math.random() + .2, 5 * Math.random(), this), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r, i.container.position.z = 1e3 * (Math.random() - .5), t.heroArrows.push(i), t.scene.add(i.container)
        }
        for (var e = 0; e < 3; e++) {
            for (var i = new Render.AngledLine(new THREE.Color(16316664), .2, .1 * Math.random() + .2, 5 * Math.random(), this, -1e3), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r - 1e3, i.container.position.z = 1e3 * (Math.random() - .5), t.scene.add(i.container)
        }
        for (var e = 0; e < 3; e++) {
            for (var i = new Render.AngledLine(new THREE.Color(16316664), .2, .1 * Math.random() + .2, 5 * Math.random(), this, -2e3), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r - 2e3, i.container.position.z = 1e3 * (Math.random() - .5), t.scene.add(i.container)
        }
        for (var e = 0; e < 3; e++) {
            for (var i = new Render.AngledLine(new THREE.Color(16316664), .2, .1 * Math.random() + .2, 5 * Math.random(), this, -3e3), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r - 3e3, i.container.position.z = 1e3 * (Math.random() - .5), t.scene.add(i.container)
        }
        for (var e = 0; e < 1; e++) {
            for (var i = new Render.SVGArrowJSON(new THREE.Color(16316664), 1, .1 * Math.random() + .2, 5 * Math.random(), this), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r, i.container.position.z = 1e3 * (Math.random() - .5), t.heroArrows.push(i), t.fadeOnOut.push(i), t.scene.add(i.container)
        }
        for (var e = 0; e < 1; e++) {
            for (var i = new Render.SVGArrowJSON(new THREE.Color(16316664), .2, .1 * Math.random() + .2, 5 * Math.random(), this), r = 500 * (Math.random() - .5); Math.abs(r) < 200;) r = 500 * (Math.random() - .5);
            i.container.position.x = r, i.container.position.y = -r, i.container.position.z = 1e3 * (Math.random() - .5), t.heroArrows.push(i), t.fadeOnOut.push(i), t.scene.add(i.container)
        }
        this.mX = 0, this.mY = 0, window.addEventListener("mousemove", this.onMouseMove.bind(this)), this.scrollEl.addEventListener("click", function () {
            site.getNextSection()
        }), this.loop(), setTimeout(function () {
            TweenMax.fromTo(document.querySelector(".page-homepage .header"), 1.5, {opacity: 0, y: 50}, {
                opacity: 1,
                y: 0,
                ease: Quint.easeInOut,
                delay: 2
            }), TweenMax.fromTo(document.querySelector(".page-homepage #pagination"), 1.5, {
                opacity: 0,
                y: 50
            }, {
                opacity: 1,
                y: 0,
                ease: Quint.easeInOut,
                delay: 2.1
            }), TweenMax.fromTo(document.querySelector(".page-homepage .scroll"), 1.5, {opacity: 0, y: 50}, {
                opacity: 1,
                y: 0,
                ease: Quint.easeInOut,
                delay: 2.2
            }), TweenMax.fromTo(document.querySelector(".page-homepage .footer"), 1.5, {opacity: 0, y: 50}, {
                opacity: 1,
                y: 0,
                ease: Quint.easeInOut,
                delay: 2.3
            })
        }, 1500)
    }, animateOut: function () {
        var t = this;
        this.isActive = !1, TweenMax.to(this.camera.rotation, 1.5, {
            y: 0,
            x: 0,
            z: 0,
            ease: Expo.easeOut
        }), this.fadeOnOut.forEach(function (t, e) {
            TweenMax.to(t.material, .5, {opacity: 0})
        }), t.heroArrows.forEach(function (t, e) {
            t.shouldAnimate = !1
        }), TweenMax.to(this.scrollEl, 1.5, {
            y: -window.innerHeight,
            ease: Expo.easeOut
        }), TweenMax.to(this.scrollEl, .3, {autoAlpha: 0})
    }, getSection: function (t) {
        var e = this;
        TweenMax.to(this.camera.position, 1.5, {
            y: -1e3 * t, x: 0, ease: Expo.easeOut, onUpdate: function () {
                e.isActive = !1
            }
        })
    }, animateIn: function () {
        var t = this;
        this.fadeOnOut.forEach(function (t, e) {
            TweenMax.to(t.material, .5, {opacity: t.opacity})
        }), TweenMax.to(this.camera.position, 1.5, {
            y: 0,
            x: 0,
            ease: Expo.easeOut
        }), TweenMax.to(this.camera.rotation, 1.5, {
            y: 0, x: 0, z: 0, ease: Expo.easeOut, onComplete: function () {
                t.isActive = !0
            }
        }), t.heroArrows.forEach(function (t, e) {
            t.shouldAnimate = !0, TweenMax.delayedCall(t.speed, t.animate.bind(t))
        }), TweenMax.fromTo(this.scrollEl, 1.5, {y: -window.innerHeight}, {
            y: 0,
            ease: Expo.easeOut
        }), TweenMax.to(this.scrollEl, .3, {autoAlpha: 1, delay: .5})
    }, onMouseMove: function (t) {
        this.mX = .3 * (t.clientX - window.innerWidth / 2), this.mY = .3 * (t.clientY - window.innerHeight / 2)
    }, loop: function () {
        requestAnimationFrame(this.loop.bind(this)), this.renderer.render(this.scene, this.camera), this.isActive && (this.camera.position.x += .1 * (this.mX - this.camera.position.x), this.camera.position.y += .1 * (-this.mY - this.camera.position.y), this.camera.lookAt(this.scene.position)), this.logoOutlineGrey.update(), this.logoOutlineWhite.update(), this.logoInnerGrey.update(), this.logoInnerOrange.update(), this.logoSquare.update(), this.hLines.forEach(function (t, e) {
            t.update()
        })
    }, resize: function () {
        this.renderer.setSize(window.innerWidth, window.innerHeight), this.camera.aspect = window.innerWidth / window.innerHeight, this.camera.updateProjectionMatrix(), this.resolution.set(window.innerWidth, window.innerHeight)
    }
};
var Render = Render || {};
Render.About = function () {
    this.el = document.querySelector("#about"), this.animEls = this.el.querySelectorAll(".anim"), this.boxEls = this.el.querySelectorAll(".stat-box"), this.numberEls = this.el.querySelectorAll(".stat-number"), this.dotEl = this.el.querySelector(".title .dot"), this.rectEl = this.el.querySelector(".watch-button rect"), this.numbers = [this.numberEls[0].dataset.number, this.numberEls[1].dataset.number, this.numberEls[2].dataset.number], this.currNumbers = {
        videos: 0,
        views: 0,
        editors: 0
    }, this.isActive = !1, this.noise = new ImprovedNoise, this.init()
}, Render.About.prototype = {
    init: function () {
        var t = this
    }, animateOut: function (t) {
        var e = this;
        this.isActive = !1, t ? TweenMax.to(this.el, 1, {
            autoAlpha: 0,
            y: -window.innerHeight,
            ease: Expo.easeOut
        }) : TweenMax.to(this.el, 1, {autoAlpha: 0, y: window.innerHeight, ease: Expo.easeOut})
    }, animateIn: function (t) {
        var e = this;
        TweenMax.set(this.el, {
            autoAlpha: 1,
            y: 0
        }), TweenMax.killTweensOf(this.animEls), t ? TweenMax.staggerFromTo(this.animEls, 2, {
            opacity: 0,
            y: 150
        }, {
            opacity: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: .5
        }, .07) : TweenMax.staggerFromTo(this.animEls, 2, {opacity: 0, y: -150}, {
            opacity: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: .3
        }, -.07), TweenMax.staggerFromTo(this.boxEls, 1, {scaleX: 0}, {
            scaleX: 1,
            ease: Expo.easeOut,
            delay: .8
        }, .1), TweenMax.set(this.dotEl, {opacity: 0}), this.threshold = -1, this.start = new Date, TweenMax.to(this, 4, {
            threshold: 1,
            delay: .5,
            onUpdate: function () {
                var t = Date.now() - e.start;
                e.noise.noise(.01 * t, 0, 0) > e.threshold ? TweenMax.set(e.dotEl, {opacity: 0}) : TweenMax.set(e.dotEl, {opacity: 1})
            }
        }), TweenMax.fromTo(this.rectEl, 1.5, {strokeDashoffset: 370}, {
            strokeDashoffset: 0,
            ease: Expo.easeInOut,
            delay: .8
        }), TweenMax.fromTo(this.currNumbers, 2, {videos: 0}, {
            videos: this.numbers[0],
            ease: Sine.easeOut,
            delay: .5,
            onUpdate: function () {
                e.numberEls[0].innerHTML = Math.floor(e.currNumbers.videos) + e.numberEls[0].dataset.suffix + "+"
            }
        }), TweenMax.fromTo(this.currNumbers, 2, {views: 0}, {
            views: this.numbers[1],
            ease: Sine.easeOut,
            delay: .5,
            onUpdate: function () {
                e.numberEls[1].innerHTML = Math.floor(e.currNumbers.views) + e.numberEls[1].dataset.suffix + "+"
            }
        }), TweenMax.fromTo(this.currNumbers, 2, {editors: 0}, {
            editors: this.numbers[2],
            ease: Sine.easeOut,
            delay: .5,
            onUpdate: function () {
                e.numberEls[2].innerHTML = Math.floor(e.currNumbers.editors) + e.numberEls[2].dataset.suffix + "+"
            }
        })
    }, resize: function () {
    }
};
var Render = Render || {};
Render.Services = function () {
    this.el = document.querySelector("#services"), this.animEls = this.el.querySelectorAll(".anim"), this.iconEls = this.el.querySelectorAll(".icon"), this.dotEl = this.el.querySelector(".title .dot"), this.rectEl = this.el.querySelector(".watch-button rect"), this.titleRectEl = this.el.querySelector(".title-rect"), this.isActive = !1, this.noise = new ImprovedNoise, this.init()
}, Render.Services.prototype = {
    init: function () {
        var t = this;
        $(this.iconEls).hover(function () {
            if (t.isActive) {
                var e = this.querySelectorAll("li"), i = 28 * e.length, n = -i / 2;
                TweenMax.to(this, .7, {
                    y: n,
                    ease: Expo.easeOut
                }), TweenMax.set(this, {height: i + 95 + "px"}), TweenMax.staggerFromTo(e, .5, {
                    opacity: 0,
                    y: 30
                }, {opacity: 1, y: 0, ease: Expo.easeOut}, .03)
            }
        }, function () {
            var t = this;
            TweenMax.to(this, .3, {
                y: 0, ease: Expo.easeOut, onComplete: function () {
                }
            }), TweenMax.set(t, {height: "95px"});
            var e = this.querySelectorAll("li");
            TweenMax.killTweensOf(e), TweenMax.to(e, .05, {opacity: 0})
        })
    }, animateOut: function (t) {
        var e = this;
        this.isActive = !1, t ? TweenMax.to(this.el, 1, {
            autoAlpha: 0,
            y: -window.innerHeight,
            ease: Expo.easeOut
        }) : TweenMax.to(this.el, 1, {autoAlpha: 0, y: window.innerHeight, ease: Expo.easeOut})
    }, animateIn: function (t) {
        var e = this;
        this.isActive = !0, TweenMax.set(this.el, {
            autoAlpha: 1,
            y: 0
        }), TweenMax.killTweensOf(this.animEls), t ? TweenMax.staggerFromTo(this.animEls, 2, {
            opacity: 0,
            y: 150
        }, {
            opacity: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: .5
        }, .07) : TweenMax.staggerFromTo(this.animEls, 2, {opacity: 0, y: -150}, {
            opacity: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: .3
        }, -.07), TweenMax.set(this.dotEl, {opacity: 0}), this.threshold = -1, this.start = new Date, TweenMax.to(this, 4, {
            threshold: 1,
            delay: .5,
            onUpdate: function () {
                var t = Date.now() - e.start;
                e.noise.noise(.01 * t, 0, 0) > e.threshold ? TweenMax.set(e.dotEl, {opacity: 0}) : TweenMax.set(e.dotEl, {opacity: 1})
            }
        }), TweenMax.fromTo(this.rectEl, 1.5, {strokeDashoffset: 452}, {
            strokeDashoffset: 0,
            ease: Expo.easeInOut,
            delay: .8
        }), TweenMax.fromTo(this.titleRectEl, 1.5, {strokeDashoffset: 557}, {
            strokeDashoffset: 0,
            ease: Expo.easeInOut,
            delay: .5
        })
    }, resize: function () {
    }
};
var Render = Render || {};
Render.Clients = function () {
    this.el = document.querySelector("#clients"), this.animEls = this.el.querySelectorAll(".anim"), this.dotEl = this.el.querySelector(".title .dot"), this.lineEl = this.el.querySelector(".title .title-line"), this.rectEl = this.el.querySelector(".watch-button rect"), this.clientsContainerEls = this.el.querySelectorAll(".client-image-container"), this.clientsImgEls = this.el.querySelectorAll(".client-image-container img"), this.clientsNameEls = this.el.querySelectorAll(".client-name"), this.isActive = !1, this.noise = new ImprovedNoise, this.init()
}, Render.Clients.prototype = {
    init: function () {
        var t = this
    }, animateOut: function (t) {
        var e = this;
        this.isActive = !1, TweenMax.to(this.el, 1, {autoAlpha: 0, y: window.innerHeight, ease: Expo.easeOut})
    }, animateIn: function (t) {
        var e = this;
        this.isActive = !0, TweenMax.set(this.el, {
            autoAlpha: 1,
            y: 0
        }), TweenMax.killTweensOf(this.animEls), TweenMax.staggerFromTo(this.animEls, 2, {
            opacity: 0,
            y: 150
        }, {opacity: 1, y: 0, ease: Expo.easeOut, delay: .43}, .07), TweenMax.fromTo(this.lineEl, 1, {
            scaleX: 0,
            transformOrigin: "0% 50%"
        }, {
            scaleX: 1,
            ease: Expo.easeInOut,
            delay: .5
        }), TweenMax.set(this.dotEl, {opacity: 0}), this.threshold = -1, this.start = new Date, TweenMax.to(this, 4, {
            threshold: 1,
            delay: .5,
            onUpdate: function () {
                var t = Date.now() - e.start;
                e.noise.noise(.01 * t, 0, 0) > e.threshold ? TweenMax.set(e.dotEl, {opacity: 0}) : TweenMax.set(e.dotEl, {opacity: 1})
            }
        }), TweenMax.staggerFromTo(this.clientsContainerEls, 2, {
            opacity: 0,
            x: -70,
            y: 100,
            rotation: -65
        }, {
            opacity: 1,
            x: 0,
            y: 0,
            rotation: -50,
            ease: Expo.easeOut,
            delay: .7
        }, -.07), TweenMax.staggerFromTo(this.clientsImgEls, 2, {rotation: 65}, {
            rotation: 50,
            ease: Expo.easeOut,
            delay: .7
        }, -.07), TweenMax.staggerFromTo(this.clientsNameEls, 2, {opacity: 0, y: 80}, {
            opacity: 1,
            y: 0,
            ease: Expo.easeOut,
            delay: .7
        }, -.07), TweenMax.fromTo(this.rectEl, 1.5, {strokeDashoffset: 452}, {
            strokeDashoffset: 0,
            ease: Expo.easeInOut,
            delay: .8
        })
    }, resize: function () {
    }
};
var ImprovedNoise = function () {
    function t(t) {
        return t * t * t * (t * (6 * t - 15) + 10)
    }

    function e(t, e, i) {
        return e + t * (i - e)
    }

    function i(t, e, i, n) {
        var r = 15 & t, a = r < 8 ? e : i, o = r < 4 ? i : 12 == r || 14 == r ? e : n;
        return (0 == (1 & r) ? a : -a) + (0 == (2 & r) ? o : -o)
    }

    for (var n = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180], r = 0; r < 256; r++) n[256 + r] = n[r];
    return {
        noise: function (r, a, o) {
            var s = Math.floor(r), l = Math.floor(a), c = Math.floor(o), h = 255 & s, u = 255 & l, p = 255 & c;
            r -= s, a -= l, o -= c;
            var d = r - 1, f = a - 1, m = o - 1, g = t(r), v = t(a), y = t(o), x = n[h] + u, _ = n[x] + p,
                b = n[x + 1] + p, w = n[h + 1] + u, M = n[w] + p, T = n[w + 1] + p;
            return e(y, e(v, e(g, i(n[_], r, a, o), i(n[M], d, a, o)), e(g, i(n[b], r, f, o), i(n[T], d, f, o))), e(v, e(g, i(n[_ + 1], r, a, m), i(n[M + 1], d, a, o - 1)), e(g, i(n[b + 1], r, f, m), i(n[T + 1], d, f, m))))
        }
    }
}, currentRandom = Math.random;
Marsaglia.createRandomized = function () {
    var t = new Date;
    return new Marsaglia(t / 6e4 & 4294967295, 4294967295 & t)
};
var noiseProfile = {generator: void 0, octaves: 4, fallout: .5, seed: void 0}, Render = Render || {}, isWindows = !0;
navigator.userAgent.indexOf("Mac OS X") != -1 && (isWindows = !1), Render.Site = function () {
    this.sections = [], this.currSection = 0, this.scrollAmount = 1, isWindows && (this.scrollAmount = 0), this.paginationEl = document.querySelector("#pagination")
}, Render.Site.prototype = {
    init: function () {
        var t = this;
        this.sectionEls = document.querySelectorAll(".section"), this.sectionEls.forEach(function (e, i) {
            var n;
            switch (e.id) {
                case"hero":
                    n = new Render.Hero;
                    break;
                case"about":
                    n = new Render.About;
                    break;
                case"services":
                    n = new Render.Services;
                    break;
                case"clients":
                    n = new Render.Clients
            }
            if (null != n) {
                t.sections.push(n);
                var r = document.createElement("div");
                r.classList.add("bullet"), i == t.currSection && r.classList.add("active"), t.paginationEl.appendChild(r)
            }
        }), this.bulletEls = this.paginationEl.querySelectorAll(".bullet"), window.addEventListener("resize", this.onResize.bind(this), !1), document.body.addEventListener("touchstart", function (e) {
            t.startY = e.touches[0].clientY, t.startX = e.touches[0].clientX
        }), document.body.addEventListener("touchmove", function (e) {
            e.preventDefault(), t.scrollLock || (t.deltaY = t.startY - e.touches[0].clientY, t.deltaX = t.startX - e.touches[0].clientX, Math.abs(t.deltaY) > Math.abs(t.deltaX) && (t.deltaY > 3 && !t.isAnimating && t.getNextSection(), t.deltaY < -3 && !t.isAnimating && t.getPrevSection()))
        }, {passive: !1});
        var e = new Date, i = 0;
        $(window).mousewheel(function (n) {
            var r = new Date, a = r - e;
            e = r, Math.abs(n.deltaY) > Math.abs(n.deltaX) && (n.deltaY < 0 && n.deltaY < i || n.deltaY > 0 && n.deltaY > i || n.deltaY == i && a > 50) && (t.isAnimating || Math.abs(n.deltaY) > t.scrollAmount && (n.deltaY > 0 ? t.getPrevSection() : t.getNextSection())), i = n.deltaY
        }), $(this.bulletEls).click(function () {
            var e = $(t.bulletEls).index(this);
            t.getSection(e)
        })
    }, getSection: function (t) {
        var e = this;
        if (t != this.currSection) {
            var i = !1;
            t > this.currSection && (i = !0), this.sections[this.currSection].animateOut(i), this.currSection = t, this.sections[this.currSection].animateIn(i), e.isAnimating = !0, TweenMax.delayedCall(1, function () {
                e.isAnimating = !1
            }), 0 != this.currSection && this.sections[0].getSection(this.currSection), $(this.bulletEls).removeClass("active"), this.bulletEls[this.currSection].classList.add("active")
        }
    }, getPrevSection: function () {
        var t = this;
        this.currSection - 1 >= 0 && (this.sections[this.currSection].animateOut(), this.currSection -= 1, this.sections[this.currSection].animateIn(), t.isAnimating = !0, TweenMax.delayedCall(1, function () {
            t.isAnimating = !1
        }), 0 != this.currSection && this.sections[0].getSection(this.currSection)), $(this.bulletEls).removeClass("active"), this.bulletEls[this.currSection].classList.add("active")
    }, getNextSection: function () {
        var t = this;
        this.currSection + 1 <= this.sections.length - 1 && (this.sections[this.currSection].animateOut(!0), this.currSection += 1, this.sections[this.currSection].animateIn(!0), t.isAnimating = !0, TweenMax.delayedCall(1, function () {
            t.isAnimating = !1
        }), 0 != this.currSection && this.sections[0].getSection(this.currSection)), $(this.bulletEls).removeClass("active"), this.bulletEls[this.currSection].classList.add("active")
    }, onResize: function () {
        this.sections.forEach(function (t, e) {
            t.resize()
        })
    }
};
var site = new Render.Site;
site.init();